//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AuthApiBase {
  authToken = "";
  protected constructor() {}

  // Enforce always return empty string as baseUrl
  getBaseUrl(defaultUrl: string, baseUrl: string) {
    return "";
  }

  setAuthToken(token: string) {
    this.authToken = token;
  }

  protected transformOptions(options: any): Promise<any> {
    if (this.authToken) {
      options.headers['authorization'] =  `Bearer ${this.authToken}`;
    }
    return Promise.resolve(options);
  }
}

export class CatalogModuleAssociationsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    getProductAssociations(productId: string): Promise<ProductAssociation[]> {
        let url_ = this.baseUrl + "/api/catalog/products/associations/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductAssociations(_response);
        });
    }

    protected processGetProductAssociations(response: Response): Promise<ProductAssociation[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAssociation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductAssociation[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getProductsAssociations(body?: string[] | undefined): Promise<ProductAssociation[]> {
        let url_ = this.baseUrl + "/api/catalog/products/associations/get/multiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductsAssociations(_response);
        });
    }

    protected processGetProductsAssociations(response: Response): Promise<ProductAssociation[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAssociation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductAssociation[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAssociations(body?: ProductAssociation[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products/associations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateAssociations(_response);
        });
    }

    protected processUpdateAssociations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    delete(ids?: string[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products/associations?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body?: ProductAssociationSearchCriteria | undefined): Promise<ProductAssociationSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/products/associations/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ProductAssociationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductAssociationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductAssociationSearchResult>(null as any);
    }
}

export class CatalogModuleCatalogsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCatalogs(body?: CatalogSearchCriteria | undefined): Promise<CatalogSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchCatalogs(_response);
        });
    }

    protected processSearchCatalogs(response: Response): Promise<CatalogSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getCatalog(id: string): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCatalog(_response);
        });
    }

    protected processGetCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(null as any);
    }

    /**
     * @return Success
     */
    deleteCatalog(id: string): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteCatalog(_response);
        });
    }

    protected processDeleteCatalog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getNewCatalog(): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/getnew";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewCatalog(_response);
        });
    }

    protected processGetNewCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(null as any);
    }

    /**
     * @return Success
     */
    getNewVirtualCatalog(): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/getnewvirtual";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewVirtualCatalog(_response);
        });
    }

    protected processGetNewVirtualCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCatalog(body?: Catalog | undefined): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateCatalog(_response);
        });
    }

    protected processCreateCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCatalog(body?: Catalog | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/catalogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateCatalog(_response);
        });
    }

    protected processUpdateCatalog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CatalogModuleCategoriesClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    getCategory(id: string): Promise<Category> {
        let url_ = this.baseUrl + "/api/catalog/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCategory(_response);
        });
    }

    protected processGetCategory(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(null as any);
    }

    /**
     * @param ids (optional) 
     * @param respGroup (optional) 
     * @return Success
     */
    getCategoriesByIds(ids?: string[] | undefined, respGroup?: string | undefined): Promise<Category[]> {
        let url_ = this.baseUrl + "/api/catalog/categories?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (respGroup === null)
            throw new Error("The parameter 'respGroup' cannot be null.");
        else if (respGroup !== undefined)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCategoriesByIds(_response);
        });
    }

    protected processGetCategoriesByIds(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateCategory(body?: Category | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateOrUpdateCategory(_response);
        });
    }

    protected processCreateOrUpdateCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteCategory(ids?: string[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/categories?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param respGroup (optional) 
     * @param body (optional) 
     * @return Success
     */
    getCategoriesByPlentyIds(respGroup?: string | undefined, body?: string[] | undefined): Promise<Category[]> {
        let url_ = this.baseUrl + "/api/catalog/categories/plenty?";
        if (respGroup === null)
            throw new Error("The parameter 'respGroup' cannot be null.");
        else if (respGroup !== undefined)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCategoriesByPlentyIds(_response);
        });
    }

    protected processGetCategoriesByPlentyIds(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(null as any);
    }

    /**
     * @param parentCategoryId (optional) 
     * @return Success
     */
    getNewCategory(catalogId: string, parentCategoryId?: string | undefined): Promise<Category> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/categories/newcategory?";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        if (parentCategoryId === null)
            throw new Error("The parameter 'parentCategoryId' cannot be null.");
        else if (parentCategoryId !== undefined)
            url_ += "parentCategoryId=" + encodeURIComponent("" + parentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewCategory(_response);
        });
    }

    protected processGetNewCategory(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(null as any);
    }
}

export class CatalogModuleIndexedSearchClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchProducts(body?: ProductIndexedSearchCriteria | undefined): Promise<ProductIndexedSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/search/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchProducts(_response);
        });
    }

    protected processSearchProducts(response: Response): Promise<ProductIndexedSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductIndexedSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductIndexedSearchResult>(null as any);
    }

    /**
     * @param catalogId (optional) 
     * @param query (optional) 
     * @param size (optional) 
     * @return Success
     */
    getProductSuggestions(catalogId?: string | undefined, query?: string | undefined, size?: number | undefined): Promise<SuggestionResponse> {
        let url_ = this.baseUrl + "/api/catalog/search/products/suggestions?";
        if (catalogId === null)
            throw new Error("The parameter 'catalogId' cannot be null.");
        else if (catalogId !== undefined)
            url_ += "CatalogId=" + encodeURIComponent("" + catalogId) + "&";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "Query=" + encodeURIComponent("" + query) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductSuggestions(_response);
        });
    }

    protected processGetProductSuggestions(response: Response): Promise<SuggestionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SuggestionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SuggestionResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCategories(body?: CategoryIndexedSearchCriteria | undefined): Promise<CategoryIndexedSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/search/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchCategories(_response);
        });
    }

    protected processSearchCategories(response: Response): Promise<CategoryIndexedSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryIndexedSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryIndexedSearchResult>(null as any);
    }
}

export class CatalogModuleListEntryClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    listItemsSearch(body?: CatalogListEntrySearchCriteria | undefined): Promise<ListEntrySearchResult> {
        let url_ = this.baseUrl + "/api/catalog/listentries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListItemsSearch(_response);
        });
    }

    protected processListItemsSearch(response: Response): Promise<ListEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListEntrySearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createLinks(body?: CategoryLink[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLinks(_response);
        });
    }

    protected processCreateLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bulkCreateLinks(body?: BulkLinkCreationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks/bulkcreate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBulkCreateLinks(_response);
        });
    }

    protected processBulkCreateLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchLinks(body?: LinkSearchCriteria | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchLinks(_response);
        });
    }

    protected processSearchLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteLinks(body?: CategoryLink[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteLinks(_response);
        });
    }

    protected processDeleteLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    move(body?: ListEntriesMoveRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentries/move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMove(_response);
        });
    }

    protected processMove(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delete(body?: CatalogListEntrySearchCriteria | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentries/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CatalogModuleProductsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param respGroup (optional) 
     * @return Success
     */
    getProductById(id: string, respGroup?: string | undefined): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (respGroup === null)
            throw new Error("The parameter 'respGroup' cannot be null.");
        else if (respGroup !== undefined)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductById(_response);
        });
    }

    protected processGetProductById(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @param responseGroup (optional) 
     * @param body (optional) 
     * @return Success
     */
    getByCodes(catalogId: string, responseGroup?: string | undefined, body?: string[] | undefined): Promise<CatalogProduct[]> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/products-by-codes?";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        if (responseGroup === null)
            throw new Error("The parameter 'responseGroup' cannot be null.");
        else if (responseGroup !== undefined)
            url_ += "responseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetByCodes(_response);
        });
    }

    protected processGetByCodes(response: Response): Promise<CatalogProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CatalogProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct[]>(null as any);
    }

    /**
     * @param ids (optional) 
     * @param respGroup (optional) 
     * @return Success
     */
    getProductByIds(ids?: string[] | undefined, respGroup?: string | undefined): Promise<CatalogProduct[]> {
        let url_ = this.baseUrl + "/api/catalog/products?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (respGroup === null)
            throw new Error("The parameter 'respGroup' cannot be null.");
        else if (respGroup !== undefined)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductByIds(_response);
        });
    }

    protected processGetProductByIds(response: Response): Promise<CatalogProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CatalogProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveProduct(body?: CatalogProduct | undefined): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveProduct(_response);
        });
    }

    protected processSaveProduct(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("Success", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteProduct(ids?: string[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProduct(_response);
        });
    }

    protected processDeleteProduct(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param respGroup (optional) 
     * @param body (optional) 
     * @return Success
     */
    getProductByPlentyIds(respGroup?: string | undefined, body?: string[] | undefined): Promise<CatalogProduct[]> {
        let url_ = this.baseUrl + "/api/catalog/products/plenty?";
        if (respGroup === null)
            throw new Error("The parameter 'respGroup' cannot be null.");
        else if (respGroup !== undefined)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProductByPlentyIds(_response);
        });
    }

    protected processGetProductByPlentyIds(response: Response): Promise<CatalogProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CatalogProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct[]>(null as any);
    }

    /**
     * @return Success
     */
    getNewProductByCatalog(catalogId: string): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/products/getnew";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewProductByCatalog(_response);
        });
    }

    protected processGetNewProductByCatalog(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @return Success
     */
    getNewProductByCatalogAndCategory(catalogId: string, categoryId: string): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/categories/{categoryId}/products/getnew";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewProductByCatalogAndCategory(_response);
        });
    }

    protected processGetNewProductByCatalogAndCategory(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @return Success
     */
    getNewVariation(productId: string): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products/{productId}/getnewvariation";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewVariation(_response);
        });
    }

    protected processGetNewVariation(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @return Success
     */
    cloneProduct(productId: string): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products/{productId}/clone";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCloneProduct(_response);
        });
    }

    protected processCloneProduct(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    productPartialUpdate(productId: string, language: string, body?: any | undefined): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products/{productId}/{language}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processProductPartialUpdate(_response);
        });
    }

    protected processProductPartialUpdate(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveProducts(body?: CatalogProduct[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveProducts(_response);
        });
    }

    protected processSaveProducts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CatalogModulePropertiesClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    getProperty(propertyId: string): Promise<Property> {
        let url_ = this.baseUrl + "/api/catalog/properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(null as any);
    }

    /**
     * @return Success
     */
    getNewCatalogProperty(catalogId: string): Promise<Property> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/properties/getnew";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewCatalogProperty(_response);
        });
    }

    protected processGetNewCatalogProperty(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(null as any);
    }

    /**
     * @return Success
     */
    getNewCategoryProperty(categoryId: string): Promise<Property> {
        let url_ = this.baseUrl + "/api/catalog/categories/{categoryId}/properties/getnew";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewCategoryProperty(_response);
        });
    }

    protected processGetNewCategoryProperty(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveProperty(body?: Property | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/properties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveProperty(_response);
        });
    }

    protected processSaveProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @param doDeleteValues (optional) 
     * @return Success
     */
    deleteProperty(id?: string | undefined, doDeleteValues?: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/properties?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (doDeleteValues === null)
            throw new Error("The parameter 'doDeleteValues' cannot be null.");
        else if (doDeleteValues !== undefined)
            url_ += "doDeleteValues=" + encodeURIComponent("" + doDeleteValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateName(body?: PropertyValidationRequest | undefined): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/api/catalog/properties/validate-name";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidateName(_response);
        });
    }

    protected processValidateName(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validatePropertyName(body?: CategoryPropertyValidationRequest | undefined): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/api/catalog/properties/validate-property-name";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidatePropertyName(_response);
        });
    }

    protected processValidatePropertyName(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }
}

export class CatalogModulePropertyDictionaryItemsClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchPropertyDictionaryItems(body?: PropertyDictionaryItemSearchCriteria | undefined): Promise<PropertyDictionaryItemSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/dictionaryitems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchPropertyDictionaryItems(_response);
        });
    }

    protected processSearchPropertyDictionaryItems(response: Response): Promise<PropertyDictionaryItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDictionaryItemSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PropertyDictionaryItemSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveChanges(body?: PropertyDictionaryItem[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/dictionaryitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSaveChanges(_response);
        });
    }

    protected processSaveChanges(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePropertyDictionaryItems(ids?: string[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/dictionaryitems?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePropertyDictionaryItems(_response);
        });
    }

    protected processDeletePropertyDictionaryItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class CatalogModuleVideosClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    getOptions(): Promise<VideoOptions> {
        let url_ = this.baseUrl + "/api/catalog/videos/options";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetOptions(_response);
        });
    }

    protected processGetOptions(response: Response): Promise<VideoOptions> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoOptions.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VideoOptions>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createVideo(body?: VideoCreateRequest | undefined): Promise<Video> {
        let url_ = this.baseUrl + "/api/catalog/videos/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateVideo(_response);
        });
    }

    protected processCreateVideo(response: Response): Promise<Video> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Video.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Video>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchVideos(body?: VideoSearchCriteria | undefined): Promise<VideoSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/videos/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchVideos(_response);
        });
    }

    protected processSearchVideos(response: Response): Promise<VideoSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VideoSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VideoSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body?: Video[] | undefined): Promise<Video[]> {
        let url_ = this.baseUrl + "/api/catalog/videos";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Video[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Video.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Video[]>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    delete(ids?: string[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/videos?";
        if (ids === null)
            throw new Error("The parameter 'ids' cannot be null.");
        else if (ids !== undefined)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Aggregation implements IAggregation {
    aggregationType?: string | undefined;
    field?: string | undefined;
    labels?: AggregationLabel[] | undefined;
    items?: AggregationItem[] | undefined;

    constructor(data?: IAggregation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aggregationType = _data["aggregationType"];
            this.field = _data["field"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(AggregationLabel.fromJS(item));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AggregationItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Aggregation {
        data = typeof data === 'object' ? data : {};
        let result = new Aggregation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationType"] = this.aggregationType;
        data["field"] = this.field;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAggregation {
    aggregationType?: string | undefined;
    field?: string | undefined;
    labels?: AggregationLabel[] | undefined;
    items?: AggregationItem[] | undefined;
}

export class AggregationItem implements IAggregationItem {
    value?: any | undefined;
    count?: number;
    isApplied?: boolean;
    labels?: AggregationLabel[] | undefined;
    requestedLowerBound?: string | undefined;
    requestedUpperBound?: string | undefined;
    includeLower?: boolean;
    includeUpper?: boolean;

    constructor(data?: IAggregationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.count = _data["count"];
            this.isApplied = _data["isApplied"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(AggregationLabel.fromJS(item));
            }
            this.requestedLowerBound = _data["requestedLowerBound"];
            this.requestedUpperBound = _data["requestedUpperBound"];
            this.includeLower = _data["includeLower"];
            this.includeUpper = _data["includeUpper"];
        }
    }

    static fromJS(data: any): AggregationItem {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["count"] = this.count;
        data["isApplied"] = this.isApplied;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["requestedLowerBound"] = this.requestedLowerBound;
        data["requestedUpperBound"] = this.requestedUpperBound;
        data["includeLower"] = this.includeLower;
        data["includeUpper"] = this.includeUpper;
        return data;
    }
}

export interface IAggregationItem {
    value?: any | undefined;
    count?: number;
    isApplied?: boolean;
    labels?: AggregationLabel[] | undefined;
    requestedLowerBound?: string | undefined;
    requestedUpperBound?: string | undefined;
    includeLower?: boolean;
    includeUpper?: boolean;
}

export class AggregationLabel implements IAggregationLabel {
    language?: string | undefined;
    label?: string | undefined;

    constructor(data?: IAggregationLabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): AggregationLabel {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationLabel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["label"] = this.label;
        return data;
    }
}

export interface IAggregationLabel {
    language?: string | undefined;
    label?: string | undefined;
}

export class Asset implements IAsset {
    mimeType?: string | undefined;
    size?: number;
    readonly readableSize?: string | undefined;
    binaryData?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    typeId?: string | undefined;
    group?: string | undefined;
    name?: string | undefined;
    outerId?: string | undefined;
    languageCode?: string | undefined;
    readonly isInherited?: boolean;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IAsset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mimeType = _data["mimeType"];
            this.size = _data["size"];
            (<any>this).readableSize = _data["readableSize"];
            this.binaryData = _data["binaryData"];
            this.relativeUrl = _data["relativeUrl"];
            this.url = _data["url"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.typeId = _data["typeId"];
            this.group = _data["group"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.languageCode = _data["languageCode"];
            (<any>this).isInherited = _data["isInherited"];
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Asset {
        data = typeof data === 'object' ? data : {};
        let result = new Asset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mimeType"] = this.mimeType;
        data["size"] = this.size;
        data["readableSize"] = this.readableSize;
        data["binaryData"] = this.binaryData;
        data["relativeUrl"] = this.relativeUrl;
        data["url"] = this.url;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["typeId"] = this.typeId;
        data["group"] = this.group;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IAsset {
    mimeType?: string | undefined;
    size?: number;
    readableSize?: string | undefined;
    binaryData?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    typeId?: string | undefined;
    group?: string | undefined;
    name?: string | undefined;
    outerId?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class BulkLinkCreationRequest implements IBulkLinkCreationRequest {
    searchCriteria?: CatalogListEntrySearchCriteria | undefined;
    categoryId?: string | undefined;
    catalogId?: string | undefined;

    constructor(data?: IBulkLinkCreationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCriteria = _data["searchCriteria"] ? CatalogListEntrySearchCriteria.fromJS(_data["searchCriteria"]) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.catalogId = _data["catalogId"];
        }
    }

    static fromJS(data: any): BulkLinkCreationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkLinkCreationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCriteria"] = this.searchCriteria ? this.searchCriteria.toJSON() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["catalogId"] = this.catalogId;
        return data;
    }
}

export interface IBulkLinkCreationRequest {
    searchCriteria?: CatalogListEntrySearchCriteria | undefined;
    categoryId?: string | undefined;
    catalogId?: string | undefined;
}

export class Catalog implements ICatalog {
    name?: string | undefined;
    isVirtual?: boolean;
    outerId?: string | undefined;
    readonly defaultLanguage?: CatalogLanguage | undefined;
    languages?: CatalogLanguage[] | undefined;
    properties?: Property[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isVirtual = _data["isVirtual"];
            this.outerId = _data["outerId"];
            (<any>this).defaultLanguage = _data["defaultLanguage"] ? CatalogLanguage.fromJS(_data["defaultLanguage"]) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(CatalogLanguage.fromJS(item));
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Catalog {
        data = typeof data === 'object' ? data : {};
        let result = new Catalog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isVirtual"] = this.isVirtual;
        data["outerId"] = this.outerId;
        data["defaultLanguage"] = this.defaultLanguage ? this.defaultLanguage.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalog {
    name?: string | undefined;
    isVirtual?: boolean;
    outerId?: string | undefined;
    defaultLanguage?: CatalogLanguage | undefined;
    languages?: CatalogLanguage[] | undefined;
    properties?: Property[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CatalogLanguage implements ICatalogLanguage {
    catalogId?: string | undefined;
    isDefault?: boolean;
    priority?: number;
    languageCode?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalogLanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            this.isDefault = _data["isDefault"];
            this.priority = _data["priority"];
            this.languageCode = _data["languageCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogLanguage {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogLanguage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        data["isDefault"] = this.isDefault;
        data["priority"] = this.priority;
        data["languageCode"] = this.languageCode;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalogLanguage {
    catalogId?: string | undefined;
    isDefault?: boolean;
    priority?: number;
    languageCode?: string | undefined;
    id?: string | undefined;
}

export class CatalogListEntrySearchCriteria implements ICatalogListEntrySearchCriteria {
    code?: string | undefined;
    vendorId?: string | undefined;
    vendorIds?: string[] | undefined;
    productType?: string | undefined;
    productTypes?: string[] | undefined;
    excludeProductType?: string | undefined;
    excludeProductTypes?: string[] | undefined;
    withHidden?: boolean;
    hideDirectLinkedCategories?: boolean;
    mainProductId?: string | undefined;
    searchInChildren?: boolean;
    searchInVariations?: boolean;
    onlyBuyable?: boolean | undefined;
    onlyWithTrackingInventory?: boolean | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    categoryId?: string | undefined;
    categoryIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICatalogListEntrySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.vendorId = _data["vendorId"];
            if (Array.isArray(_data["vendorIds"])) {
                this.vendorIds = [] as any;
                for (let item of _data["vendorIds"])
                    this.vendorIds!.push(item);
            }
            this.productType = _data["productType"];
            if (Array.isArray(_data["productTypes"])) {
                this.productTypes = [] as any;
                for (let item of _data["productTypes"])
                    this.productTypes!.push(item);
            }
            this.excludeProductType = _data["excludeProductType"];
            if (Array.isArray(_data["excludeProductTypes"])) {
                this.excludeProductTypes = [] as any;
                for (let item of _data["excludeProductTypes"])
                    this.excludeProductTypes!.push(item);
            }
            this.withHidden = _data["withHidden"];
            this.hideDirectLinkedCategories = _data["hideDirectLinkedCategories"];
            this.mainProductId = _data["mainProductId"];
            this.searchInChildren = _data["searchInChildren"];
            this.searchInVariations = _data["searchInVariations"];
            this.onlyBuyable = _data["onlyBuyable"];
            this.onlyWithTrackingInventory = _data["onlyWithTrackingInventory"];
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CatalogListEntrySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogListEntrySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["vendorId"] = this.vendorId;
        if (Array.isArray(this.vendorIds)) {
            data["vendorIds"] = [];
            for (let item of this.vendorIds)
                data["vendorIds"].push(item);
        }
        data["productType"] = this.productType;
        if (Array.isArray(this.productTypes)) {
            data["productTypes"] = [];
            for (let item of this.productTypes)
                data["productTypes"].push(item);
        }
        data["excludeProductType"] = this.excludeProductType;
        if (Array.isArray(this.excludeProductTypes)) {
            data["excludeProductTypes"] = [];
            for (let item of this.excludeProductTypes)
                data["excludeProductTypes"].push(item);
        }
        data["withHidden"] = this.withHidden;
        data["hideDirectLinkedCategories"] = this.hideDirectLinkedCategories;
        data["mainProductId"] = this.mainProductId;
        data["searchInChildren"] = this.searchInChildren;
        data["searchInVariations"] = this.searchInVariations;
        data["onlyBuyable"] = this.onlyBuyable;
        data["onlyWithTrackingInventory"] = this.onlyWithTrackingInventory;
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICatalogListEntrySearchCriteria {
    code?: string | undefined;
    vendorId?: string | undefined;
    vendorIds?: string[] | undefined;
    productType?: string | undefined;
    productTypes?: string[] | undefined;
    excludeProductType?: string | undefined;
    excludeProductTypes?: string[] | undefined;
    withHidden?: boolean;
    hideDirectLinkedCategories?: boolean;
    mainProductId?: string | undefined;
    searchInChildren?: boolean;
    searchInVariations?: boolean;
    onlyBuyable?: boolean | undefined;
    onlyWithTrackingInventory?: boolean | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    categoryId?: string | undefined;
    categoryIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CatalogProduct implements ICatalogProduct {
    productType?: string | undefined;
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    readonly outline?: string | undefined;
    readonly path?: string | undefined;
    readonly titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isActive?: boolean | undefined;
    isBuyable?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    readonly isInherited?: boolean;
    readonly parentCategoryIsActive?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalogProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productType = _data["productType"];
            this.code = _data["code"];
            this.manufacturerPartNumber = _data["manufacturerPartNumber"];
            this.gtin = _data["gtin"];
            this.name = _data["name"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            (<any>this).titularItemId = _data["titularItemId"];
            this.mainProductId = _data["mainProductId"];
            this.isActive = _data["isActive"];
            this.isBuyable = _data["isBuyable"];
            this.trackInventory = _data["trackInventory"];
            this.indexingDate = _data["indexingDate"] ? new Date(_data["indexingDate"].toString()) : <any>undefined;
            this.maxQuantity = _data["maxQuantity"];
            this.minQuantity = _data["minQuantity"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.packageType = _data["packageType"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.enableReview = _data["enableReview"];
            this.maxNumberOfDownload = _data["maxNumberOfDownload"];
            this.downloadExpiration = _data["downloadExpiration"] ? new Date(_data["downloadExpiration"].toString()) : <any>undefined;
            this.downloadType = _data["downloadType"];
            this.hasUserAgreement = _data["hasUserAgreement"];
            this.shippingType = _data["shippingType"];
            this.taxType = _data["taxType"];
            this.vendor = _data["vendor"];
            this.priority = _data["priority"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            if (Array.isArray(_data["excludedProperties"])) {
                this.excludedProperties = [] as any;
                for (let item of _data["excludedProperties"])
                    this.excludedProperties!.push(ExcludedProperty.fromJS(item));
            }
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValue.fromJS(item));
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets!.push(Asset.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(Variation.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(EditorialReview.fromJS(item));
            }
            if (Array.isArray(_data["associations"])) {
                this.associations = [] as any;
                for (let item of _data["associations"])
                    this.associations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["referencedAssociations"])) {
                this.referencedAssociations = [] as any;
                for (let item of _data["referencedAssociations"])
                    this.referencedAssociations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(Outline.fromJS(item));
            }
            (<any>this).isInherited = _data["isInherited"];
            (<any>this).parentCategoryIsActive = _data["parentCategoryIsActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogProduct {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productType"] = this.productType;
        data["code"] = this.code;
        data["manufacturerPartNumber"] = this.manufacturerPartNumber;
        data["gtin"] = this.gtin;
        data["name"] = this.name;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["titularItemId"] = this.titularItemId;
        data["mainProductId"] = this.mainProductId;
        data["isActive"] = this.isActive;
        data["isBuyable"] = this.isBuyable;
        data["trackInventory"] = this.trackInventory;
        data["indexingDate"] = this.indexingDate ? this.indexingDate.toISOString() : <any>undefined;
        data["maxQuantity"] = this.maxQuantity;
        data["minQuantity"] = this.minQuantity;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["packageType"] = this.packageType;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["enableReview"] = this.enableReview;
        data["maxNumberOfDownload"] = this.maxNumberOfDownload;
        data["downloadExpiration"] = this.downloadExpiration ? this.downloadExpiration.toISOString() : <any>undefined;
        data["downloadType"] = this.downloadType;
        data["hasUserAgreement"] = this.hasUserAgreement;
        data["shippingType"] = this.shippingType;
        data["taxType"] = this.taxType;
        data["vendor"] = this.vendor;
        data["priority"] = this.priority;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.excludedProperties)) {
            data["excludedProperties"] = [];
            for (let item of this.excludedProperties)
                data["excludedProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        if (Array.isArray(this.associations)) {
            data["associations"] = [];
            for (let item of this.associations)
                data["associations"].push(item.toJSON());
        }
        if (Array.isArray(this.referencedAssociations)) {
            data["referencedAssociations"] = [];
            for (let item of this.referencedAssociations)
                data["referencedAssociations"].push(item.toJSON());
        }
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item.toJSON());
        }
        data["isInherited"] = this.isInherited;
        data["parentCategoryIsActive"] = this.parentCategoryIsActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICatalogProduct {
    productType?: string | undefined;
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    outline?: string | undefined;
    path?: string | undefined;
    titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isActive?: boolean | undefined;
    isBuyable?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    isInherited?: boolean;
    parentCategoryIsActive?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CatalogSearchCriteria implements ICatalogSearchCriteria {
    catalogIds?: string[] | undefined;
    outerIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICatalogSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            if (Array.isArray(_data["outerIds"])) {
                this.outerIds = [] as any;
                for (let item of _data["outerIds"])
                    this.outerIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CatalogSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        if (Array.isArray(this.outerIds)) {
            data["outerIds"] = [];
            for (let item of this.outerIds)
                data["outerIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICatalogSearchCriteria {
    catalogIds?: string[] | undefined;
    outerIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CatalogSearchResult implements ICatalogSearchResult {
    totalCount?: number;
    results?: Catalog[] | undefined;

    constructor(data?: ICatalogSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Catalog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CatalogSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICatalogSearchResult {
    totalCount?: number;
    results?: Catalog[] | undefined;
}

export class Category implements ICategory {
    catalogId?: string | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    readonly outline?: string | undefined;
    path?: string | undefined;
    isVirtual?: boolean;
    level?: number;
    packageType?: string | undefined;
    priority?: number;
    isActive?: boolean | undefined;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    links?: CategoryLink[] | undefined;
    taxType?: string | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    enableDescription?: boolean | undefined;
    descriptions?: CategoryDescription[] | undefined;
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    outlines?: Outline[] | undefined;
    readonly isInherited?: boolean;
    readonly parentIsActive?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.name = _data["name"];
            (<any>this).outline = _data["outline"];
            this.path = _data["path"];
            this.isVirtual = _data["isVirtual"];
            this.level = _data["level"];
            this.packageType = _data["packageType"];
            this.priority = _data["priority"];
            this.isActive = _data["isActive"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            if (Array.isArray(_data["excludedProperties"])) {
                this.excludedProperties = [] as any;
                for (let item of _data["excludedProperties"])
                    this.excludedProperties!.push(ExcludedProperty.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            this.taxType = _data["taxType"];
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.enableDescription = _data["enableDescription"];
            if (Array.isArray(_data["descriptions"])) {
                this.descriptions = [] as any;
                for (let item of _data["descriptions"])
                    this.descriptions!.push(CategoryDescription.fromJS(item));
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(Outline.fromJS(item));
            }
            (<any>this).isInherited = _data["isInherited"];
            (<any>this).parentIsActive = _data["parentIsActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["isVirtual"] = this.isVirtual;
        data["level"] = this.level;
        data["packageType"] = this.packageType;
        data["priority"] = this.priority;
        data["isActive"] = this.isActive;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.excludedProperties)) {
            data["excludedProperties"] = [];
            for (let item of this.excludedProperties)
                data["excludedProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["taxType"] = this.taxType;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["enableDescription"] = this.enableDescription;
        if (Array.isArray(this.descriptions)) {
            data["descriptions"] = [];
            for (let item of this.descriptions)
                data["descriptions"].push(item.toJSON());
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item.toJSON());
        }
        data["isInherited"] = this.isInherited;
        data["parentIsActive"] = this.parentIsActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICategory {
    catalogId?: string | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    outline?: string | undefined;
    path?: string | undefined;
    isVirtual?: boolean;
    level?: number;
    packageType?: string | undefined;
    priority?: number;
    isActive?: boolean | undefined;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    links?: CategoryLink[] | undefined;
    taxType?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    enableDescription?: boolean | undefined;
    descriptions?: CategoryDescription[] | undefined;
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    outlines?: Outline[] | undefined;
    isInherited?: boolean;
    parentIsActive?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CategoryDescription implements ICategoryDescription {
    content?: string | undefined;
    descriptionType?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICategoryDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.descriptionType = _data["descriptionType"];
            this.languageCode = _data["languageCode"];
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CategoryDescription {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["descriptionType"] = this.descriptionType;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICategoryDescription {
    content?: string | undefined;
    descriptionType?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CategoryIndexedSearchCriteria implements ICategoryIndexedSearchCriteria {
    objectType?: string | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    outline?: string | undefined;
    outlines?: string[] | undefined;
    terms?: string[] | undefined;
    userGroups?: string[] | undefined;
    isFuzzySearch?: boolean;
    rawQuery?: string | undefined;
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICategoryIndexedSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.storeId = _data["storeId"];
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.outline = _data["outline"];
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(item);
            }
            if (Array.isArray(_data["terms"])) {
                this.terms = [] as any;
                for (let item of _data["terms"])
                    this.terms!.push(item);
            }
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.isFuzzySearch = _data["isFuzzySearch"];
            this.rawQuery = _data["rawQuery"];
            if (Array.isArray(_data["includeFields"])) {
                this.includeFields = [] as any;
                for (let item of _data["includeFields"])
                    this.includeFields!.push(item);
            }
            this.searchPhrase = _data["searchPhrase"];
            this.keyword = _data["keyword"];
            this.responseGroup = _data["responseGroup"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CategoryIndexedSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryIndexedSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["storeId"] = this.storeId;
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["outline"] = this.outline;
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item);
        }
        if (Array.isArray(this.terms)) {
            data["terms"] = [];
            for (let item of this.terms)
                data["terms"].push(item);
        }
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["isFuzzySearch"] = this.isFuzzySearch;
        data["rawQuery"] = this.rawQuery;
        if (Array.isArray(this.includeFields)) {
            data["includeFields"] = [];
            for (let item of this.includeFields)
                data["includeFields"].push(item);
        }
        data["searchPhrase"] = this.searchPhrase;
        data["keyword"] = this.keyword;
        data["responseGroup"] = this.responseGroup;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICategoryIndexedSearchCriteria {
    objectType?: string | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    outline?: string | undefined;
    outlines?: string[] | undefined;
    terms?: string[] | undefined;
    userGroups?: string[] | undefined;
    isFuzzySearch?: boolean;
    rawQuery?: string | undefined;
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CategoryIndexedSearchResult implements ICategoryIndexedSearchResult {
    totalCount?: number;
    items?: Category[] | undefined;
    aggregations?: Aggregation[] | undefined;

    constructor(data?: ICategoryIndexedSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Category.fromJS(item));
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(Aggregation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryIndexedSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryIndexedSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategoryIndexedSearchResult {
    totalCount?: number;
    items?: Category[] | undefined;
    aggregations?: Aggregation[] | undefined;
}

export class CategoryLink implements ICategoryLink {
    readonly entryId?: string | undefined;
    listEntryId?: string | undefined;
    listEntryType?: string | undefined;
    priority?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    readonly targetId?: string | undefined;
    readonly name?: string | undefined;

    constructor(data?: ICategoryLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).entryId = _data["entryId"];
            this.listEntryId = _data["listEntryId"];
            this.listEntryType = _data["listEntryType"];
            this.priority = _data["priority"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            (<any>this).targetId = _data["targetId"];
            (<any>this).name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryLink {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryId"] = this.entryId;
        data["listEntryId"] = this.listEntryId;
        data["listEntryType"] = this.listEntryType;
        data["priority"] = this.priority;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["targetId"] = this.targetId;
        data["name"] = this.name;
        return data;
    }
}

export interface ICategoryLink {
    entryId?: string | undefined;
    listEntryId?: string | undefined;
    listEntryType?: string | undefined;
    priority?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    targetId?: string | undefined;
    name?: string | undefined;
}

export class CategoryPropertyValidationRequest implements ICategoryPropertyValidationRequest {
    propertyName?: string | undefined;
    propertyType?: string | undefined;
    categoryId?: string | undefined;
    catalogId?: string | undefined;

    constructor(data?: ICategoryPropertyValidationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.propertyType = _data["propertyType"];
            this.categoryId = _data["categoryId"];
            this.catalogId = _data["catalogId"];
        }
    }

    static fromJS(data: any): CategoryPropertyValidationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryPropertyValidationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["propertyType"] = this.propertyType;
        data["categoryId"] = this.categoryId;
        data["catalogId"] = this.catalogId;
        return data;
    }
}

export interface ICategoryPropertyValidationRequest {
    propertyName?: string | undefined;
    propertyType?: string | undefined;
    categoryId?: string | undefined;
    catalogId?: string | undefined;
}

export class EditorialReview implements IEditorialReview {
    content?: string | undefined;
    reviewType?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IEditorialReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.reviewType = _data["reviewType"];
            this.languageCode = _data["languageCode"];
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditorialReview {
        data = typeof data === 'object' ? data : {};
        let result = new EditorialReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["reviewType"] = this.reviewType;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditorialReview {
    content?: string | undefined;
    reviewType?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ExcludedProperty implements IExcludedProperty {
    name?: string | undefined;
    isInherited?: boolean;

    constructor(data?: IExcludedProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isInherited = _data["isInherited"];
        }
    }

    static fromJS(data: any): ExcludedProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ExcludedProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isInherited"] = this.isInherited;
        return data;
    }
}

export interface IExcludedProperty {
    name?: string | undefined;
    isInherited?: boolean;
}

export class GeoDistanceFilter implements IGeoDistanceFilter {
    fieldName?: string | undefined;
    location?: GeoPoint | undefined;
    distance?: number;

    constructor(data?: IGeoDistanceFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.location = _data["location"] ? GeoPoint.fromJS(_data["location"]) : <any>undefined;
            this.distance = _data["distance"];
        }
    }

    static fromJS(data: any): GeoDistanceFilter {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistanceFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["distance"] = this.distance;
        return data;
    }
}

export interface IGeoDistanceFilter {
    fieldName?: string | undefined;
    location?: GeoPoint | undefined;
    distance?: number;
}

export class GeoPoint implements IGeoPoint {
    latitude?: number;
    longitude?: number;

    constructor(data?: IGeoPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): GeoPoint {
        data = typeof data === 'object' ? data : {};
        let result = new GeoPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IGeoPoint {
    latitude?: number;
    longitude?: number;
}

export class Image implements IImage {
    binaryData?: string | undefined;
    altText?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    typeId?: string | undefined;
    group?: string | undefined;
    name?: string | undefined;
    outerId?: string | undefined;
    languageCode?: string | undefined;
    readonly isInherited?: boolean;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.binaryData = _data["binaryData"];
            this.altText = _data["altText"];
            this.relativeUrl = _data["relativeUrl"];
            this.url = _data["url"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.typeId = _data["typeId"];
            this.group = _data["group"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.languageCode = _data["languageCode"];
            (<any>this).isInherited = _data["isInherited"];
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Image {
        data = typeof data === 'object' ? data : {};
        let result = new Image();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["binaryData"] = this.binaryData;
        data["altText"] = this.altText;
        data["relativeUrl"] = this.relativeUrl;
        data["url"] = this.url;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["typeId"] = this.typeId;
        data["group"] = this.group;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IImage {
    binaryData?: string | undefined;
    altText?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    typeId?: string | undefined;
    group?: string | undefined;
    name?: string | undefined;
    outerId?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class LinkSearchCriteria implements ILinkSearchCriteria {
    categoryIds?: string[] | undefined;
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ILinkSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): LinkSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new LinkSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ILinkSearchCriteria {
    categoryIds?: string[] | undefined;
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ListEntriesMoveRequest implements IListEntriesMoveRequest {
    catalog?: string | undefined;
    readonly catalogId?: string | undefined;
    category?: string | undefined;
    listEntries?: ListEntryBase[] | undefined;

    constructor(data?: IListEntriesMoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            (<any>this).catalogId = _data["catalogId"];
            this.category = _data["category"];
            if (Array.isArray(_data["listEntries"])) {
                this.listEntries = [] as any;
                for (let item of _data["listEntries"])
                    this.listEntries!.push(ListEntryBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListEntriesMoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntriesMoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["catalogId"] = this.catalogId;
        data["category"] = this.category;
        if (Array.isArray(this.listEntries)) {
            data["listEntries"] = [];
            for (let item of this.listEntries)
                data["listEntries"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListEntriesMoveRequest {
    catalog?: string | undefined;
    catalogId?: string | undefined;
    category?: string | undefined;
    listEntries?: ListEntryBase[] | undefined;
}

export class ListEntryBase implements IListEntryBase {
    type?: string | undefined;
    isActive?: boolean | undefined;
    imageUrl?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    links?: CategoryLink[] | undefined;
    outline?: string[] | undefined;
    path?: string[] | undefined;
    catalogId?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IListEntryBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.isActive = _data["isActive"];
            this.imageUrl = _data["imageUrl"];
            this.code = _data["code"];
            this.name = _data["name"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            if (Array.isArray(_data["outline"])) {
                this.outline = [] as any;
                for (let item of _data["outline"])
                    this.outline!.push(item);
            }
            if (Array.isArray(_data["path"])) {
                this.path = [] as any;
                for (let item of _data["path"])
                    this.path!.push(item);
            }
            this.catalogId = _data["catalogId"];
            this.seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ListEntryBase {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntryBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["isActive"] = this.isActive;
        data["imageUrl"] = this.imageUrl;
        data["code"] = this.code;
        data["name"] = this.name;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (Array.isArray(this.outline)) {
            data["outline"] = [];
            for (let item of this.outline)
                data["outline"].push(item);
        }
        if (Array.isArray(this.path)) {
            data["path"] = [];
            for (let item of this.path)
                data["path"].push(item);
        }
        data["catalogId"] = this.catalogId;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IListEntryBase {
    type?: string | undefined;
    isActive?: boolean | undefined;
    imageUrl?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    links?: CategoryLink[] | undefined;
    outline?: string[] | undefined;
    path?: string[] | undefined;
    catalogId?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ListEntrySearchResult implements IListEntrySearchResult {
    readonly listEntries?: ListEntryBase[] | undefined;
    totalCount?: number;
    results?: ListEntryBase[] | undefined;

    constructor(data?: IListEntrySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listEntries"])) {
                (<any>this).listEntries = [] as any;
                for (let item of _data["listEntries"])
                    (<any>this).listEntries!.push(ListEntryBase.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ListEntryBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntrySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listEntries)) {
            data["listEntries"] = [];
            for (let item of this.listEntries)
                data["listEntries"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListEntrySearchResult {
    listEntries?: ListEntryBase[] | undefined;
    totalCount?: number;
    results?: ListEntryBase[] | undefined;
}

export class NumericRange implements INumericRange {
    lower?: number | undefined;
    upper?: number | undefined;
    includeLower?: boolean;
    includeUpper?: boolean;

    constructor(data?: INumericRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lower = _data["lower"];
            this.upper = _data["upper"];
            this.includeLower = _data["includeLower"];
            this.includeUpper = _data["includeUpper"];
        }
    }

    static fromJS(data: any): NumericRange {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lower"] = this.lower;
        data["upper"] = this.upper;
        data["includeLower"] = this.includeLower;
        data["includeUpper"] = this.includeUpper;
        return data;
    }
}

export interface INumericRange {
    lower?: number | undefined;
    upper?: number | undefined;
    includeLower?: boolean;
    includeUpper?: boolean;
}

export class Outline implements IOutline {
    items?: OutlineItem[] | undefined;

    constructor(data?: IOutline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OutlineItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Outline {
        data = typeof data === 'object' ? data : {};
        let result = new Outline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOutline {
    items?: OutlineItem[] | undefined;
}

export class OutlineItem implements IOutlineItem {
    id?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    name?: string | undefined;
    hasVirtualParent?: boolean;

    constructor(data?: IOutlineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.name = _data["name"];
            this.hasVirtualParent = _data["hasVirtualParent"];
        }
    }

    static fromJS(data: any): OutlineItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutlineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["hasVirtualParent"] = this.hasVirtualParent;
        return data;
    }
}

export interface IOutlineItem {
    id?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    name?: string | undefined;
    hasVirtualParent?: boolean;
}

export class ProductAssociation implements IProductAssociation {
    type?: string | undefined;
    priority?: number;
    quantity?: number | undefined;
    itemId?: string | undefined;
    associatedObjectId?: string | undefined;
    associatedObjectType?: string | undefined;
    outerId?: string | undefined;
    readonly associatedObjectName?: string | undefined;
    readonly associatedObjectImg?: string | undefined;
    tags?: string[] | undefined;
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    id?: string | undefined;

    constructor(data?: IProductAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.priority = _data["priority"];
            this.quantity = _data["quantity"];
            this.itemId = _data["itemId"];
            this.associatedObjectId = _data["associatedObjectId"];
            this.associatedObjectType = _data["associatedObjectType"];
            this.outerId = _data["outerId"];
            (<any>this).associatedObjectName = _data["associatedObjectName"];
            (<any>this).associatedObjectImg = _data["associatedObjectImg"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductAssociation {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAssociation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["priority"] = this.priority;
        data["quantity"] = this.quantity;
        data["itemId"] = this.itemId;
        data["associatedObjectId"] = this.associatedObjectId;
        data["associatedObjectType"] = this.associatedObjectType;
        data["outerId"] = this.outerId;
        data["associatedObjectName"] = this.associatedObjectName;
        data["associatedObjectImg"] = this.associatedObjectImg;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IProductAssociation {
    type?: string | undefined;
    priority?: number;
    quantity?: number | undefined;
    itemId?: string | undefined;
    associatedObjectId?: string | undefined;
    associatedObjectType?: string | undefined;
    outerId?: string | undefined;
    associatedObjectName?: string | undefined;
    associatedObjectImg?: string | undefined;
    tags?: string[] | undefined;
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    id?: string | undefined;
}

export class ProductAssociationSearchCriteria implements IProductAssociationSearchCriteria {
    group?: string | undefined;
    tags?: string[] | undefined;
    associatedObjectIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IProductAssociationSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["associatedObjectIds"])) {
                this.associatedObjectIds = [] as any;
                for (let item of _data["associatedObjectIds"])
                    this.associatedObjectIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ProductAssociationSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAssociationSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.associatedObjectIds)) {
            data["associatedObjectIds"] = [];
            for (let item of this.associatedObjectIds)
                data["associatedObjectIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IProductAssociationSearchCriteria {
    group?: string | undefined;
    tags?: string[] | undefined;
    associatedObjectIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ProductAssociationSearchResult implements IProductAssociationSearchResult {
    totalCount?: number;
    results?: ProductAssociation[] | undefined;

    constructor(data?: IProductAssociationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ProductAssociation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAssociationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAssociationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductAssociationSearchResult {
    totalCount?: number;
    results?: ProductAssociation[] | undefined;
}

export class ProductIndexedSearchCriteria implements IProductIndexedSearchCriteria {
    objectType?: string | undefined;
    productType?: string | undefined;
    currency?: string | undefined;
    pricelists?: string[] | undefined;
    priceRange?: NumericRange | undefined;
    classTypes?: string[] | undefined;
    withHidden?: boolean;
    searchInVariations?: boolean;
    startDate?: Date;
    startDateFrom?: Date | undefined;
    endDate?: Date | undefined;
    includeAggregations?: string[] | undefined;
    excludeAggregations?: string[] | undefined;
    geoDistanceFilter?: GeoDistanceFilter | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    outline?: string | undefined;
    outlines?: string[] | undefined;
    terms?: string[] | undefined;
    userGroups?: string[] | undefined;
    isFuzzySearch?: boolean;
    rawQuery?: string | undefined;
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IProductIndexedSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.productType = _data["productType"];
            this.currency = _data["currency"];
            if (Array.isArray(_data["pricelists"])) {
                this.pricelists = [] as any;
                for (let item of _data["pricelists"])
                    this.pricelists!.push(item);
            }
            this.priceRange = _data["priceRange"] ? NumericRange.fromJS(_data["priceRange"]) : <any>undefined;
            if (Array.isArray(_data["classTypes"])) {
                this.classTypes = [] as any;
                for (let item of _data["classTypes"])
                    this.classTypes!.push(item);
            }
            this.withHidden = _data["withHidden"];
            this.searchInVariations = _data["searchInVariations"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.startDateFrom = _data["startDateFrom"] ? new Date(_data["startDateFrom"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["includeAggregations"])) {
                this.includeAggregations = [] as any;
                for (let item of _data["includeAggregations"])
                    this.includeAggregations!.push(item);
            }
            if (Array.isArray(_data["excludeAggregations"])) {
                this.excludeAggregations = [] as any;
                for (let item of _data["excludeAggregations"])
                    this.excludeAggregations!.push(item);
            }
            this.geoDistanceFilter = _data["geoDistanceFilter"] ? GeoDistanceFilter.fromJS(_data["geoDistanceFilter"]) : <any>undefined;
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.storeId = _data["storeId"];
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.outline = _data["outline"];
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(item);
            }
            if (Array.isArray(_data["terms"])) {
                this.terms = [] as any;
                for (let item of _data["terms"])
                    this.terms!.push(item);
            }
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.isFuzzySearch = _data["isFuzzySearch"];
            this.rawQuery = _data["rawQuery"];
            if (Array.isArray(_data["includeFields"])) {
                this.includeFields = [] as any;
                for (let item of _data["includeFields"])
                    this.includeFields!.push(item);
            }
            this.searchPhrase = _data["searchPhrase"];
            this.keyword = _data["keyword"];
            this.responseGroup = _data["responseGroup"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ProductIndexedSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ProductIndexedSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["productType"] = this.productType;
        data["currency"] = this.currency;
        if (Array.isArray(this.pricelists)) {
            data["pricelists"] = [];
            for (let item of this.pricelists)
                data["pricelists"].push(item);
        }
        data["priceRange"] = this.priceRange ? this.priceRange.toJSON() : <any>undefined;
        if (Array.isArray(this.classTypes)) {
            data["classTypes"] = [];
            for (let item of this.classTypes)
                data["classTypes"].push(item);
        }
        data["withHidden"] = this.withHidden;
        data["searchInVariations"] = this.searchInVariations;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startDateFrom"] = this.startDateFrom ? this.startDateFrom.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.includeAggregations)) {
            data["includeAggregations"] = [];
            for (let item of this.includeAggregations)
                data["includeAggregations"].push(item);
        }
        if (Array.isArray(this.excludeAggregations)) {
            data["excludeAggregations"] = [];
            for (let item of this.excludeAggregations)
                data["excludeAggregations"].push(item);
        }
        data["geoDistanceFilter"] = this.geoDistanceFilter ? this.geoDistanceFilter.toJSON() : <any>undefined;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["storeId"] = this.storeId;
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["outline"] = this.outline;
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item);
        }
        if (Array.isArray(this.terms)) {
            data["terms"] = [];
            for (let item of this.terms)
                data["terms"].push(item);
        }
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["isFuzzySearch"] = this.isFuzzySearch;
        data["rawQuery"] = this.rawQuery;
        if (Array.isArray(this.includeFields)) {
            data["includeFields"] = [];
            for (let item of this.includeFields)
                data["includeFields"].push(item);
        }
        data["searchPhrase"] = this.searchPhrase;
        data["keyword"] = this.keyword;
        data["responseGroup"] = this.responseGroup;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IProductIndexedSearchCriteria {
    objectType?: string | undefined;
    productType?: string | undefined;
    currency?: string | undefined;
    pricelists?: string[] | undefined;
    priceRange?: NumericRange | undefined;
    classTypes?: string[] | undefined;
    withHidden?: boolean;
    searchInVariations?: boolean;
    startDate?: Date;
    startDateFrom?: Date | undefined;
    endDate?: Date | undefined;
    includeAggregations?: string[] | undefined;
    excludeAggregations?: string[] | undefined;
    geoDistanceFilter?: GeoDistanceFilter | undefined;
    sortInfos?: SortInfo[] | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    outline?: string | undefined;
    outlines?: string[] | undefined;
    terms?: string[] | undefined;
    userGroups?: string[] | undefined;
    isFuzzySearch?: boolean;
    rawQuery?: string | undefined;
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    skip?: number;
    take?: number;
}

export class ProductIndexedSearchResult implements IProductIndexedSearchResult {
    totalCount?: number;
    items?: CatalogProduct[] | undefined;
    aggregations?: Aggregation[] | undefined;

    constructor(data?: IProductIndexedSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CatalogProduct.fromJS(item));
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(Aggregation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductIndexedSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductIndexedSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductIndexedSearchResult {
    totalCount?: number;
    items?: CatalogProduct[] | undefined;
    aggregations?: Aggregation[] | undefined;
}

export class Property implements IProperty {
    isReadOnly?: boolean;
    readonly isManageable?: boolean;
    isNew?: boolean;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    name?: string | undefined;
    required?: boolean;
    dictionary?: boolean;
    multivalue?: boolean;
    multilanguage?: boolean;
    hidden?: boolean;
    valueType?: PropertyValueType2;
    type?: PropertyType2;
    outerId?: string | undefined;
    ownerName?: string | undefined;
    displayOrder?: number | undefined;
    values?: PropertyValue[] | undefined;
    attributes?: PropertyAttribute[] | undefined;
    displayNames?: PropertyDisplayName[] | undefined;
    validationRules?: PropertyValidationRule[] | undefined;
    readonly validationRule?: PropertyValidationRule | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isReadOnly = _data["isReadOnly"];
            (<any>this).isManageable = _data["isManageable"];
            this.isNew = _data["isNew"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.required = _data["required"];
            this.dictionary = _data["dictionary"];
            this.multivalue = _data["multivalue"];
            this.multilanguage = _data["multilanguage"];
            this.hidden = _data["hidden"];
            this.valueType = _data["valueType"];
            this.type = _data["type"];
            this.outerId = _data["outerId"];
            this.ownerName = _data["ownerName"];
            this.displayOrder = _data["displayOrder"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(PropertyValue.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(PropertyAttribute.fromJS(item));
            }
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(PropertyDisplayName.fromJS(item));
            }
            if (Array.isArray(_data["validationRules"])) {
                this.validationRules = [] as any;
                for (let item of _data["validationRules"])
                    this.validationRules!.push(PropertyValidationRule.fromJS(item));
            }
            (<any>this).validationRule = _data["validationRule"] ? PropertyValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Property {
        data = typeof data === 'object' ? data : {};
        let result = new Property();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isReadOnly"] = this.isReadOnly;
        data["isManageable"] = this.isManageable;
        data["isNew"] = this.isNew;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["required"] = this.required;
        data["dictionary"] = this.dictionary;
        data["multivalue"] = this.multivalue;
        data["multilanguage"] = this.multilanguage;
        data["hidden"] = this.hidden;
        data["valueType"] = this.valueType;
        data["type"] = this.type;
        data["outerId"] = this.outerId;
        data["ownerName"] = this.ownerName;
        data["displayOrder"] = this.displayOrder;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        if (Array.isArray(this.validationRules)) {
            data["validationRules"] = [];
            for (let item of this.validationRules)
                data["validationRules"].push(item.toJSON());
        }
        data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IProperty {
    isReadOnly?: boolean;
    isManageable?: boolean;
    isNew?: boolean;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    name?: string | undefined;
    required?: boolean;
    dictionary?: boolean;
    multivalue?: boolean;
    multilanguage?: boolean;
    hidden?: boolean;
    valueType?: PropertyValueType2;
    type?: PropertyType2;
    outerId?: string | undefined;
    ownerName?: string | undefined;
    displayOrder?: number | undefined;
    values?: PropertyValue[] | undefined;
    attributes?: PropertyAttribute[] | undefined;
    displayNames?: PropertyDisplayName[] | undefined;
    validationRules?: PropertyValidationRule[] | undefined;
    validationRule?: PropertyValidationRule | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class PropertyAttribute implements IPropertyAttribute {
    propertyId?: string | undefined;
    value?: string | undefined;
    name?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.value = _data["value"];
            this.name = _data["name"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["value"] = this.value;
        data["name"] = this.name;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPropertyAttribute {
    propertyId?: string | undefined;
    value?: string | undefined;
    name?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class PropertyDictionaryItem implements IPropertyDictionaryItem {
    propertyId?: string | undefined;
    alias?: string | undefined;
    sortOrder?: number;
    localizedValues?: PropertyDictionaryItemLocalizedValue[] | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyDictionaryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.alias = _data["alias"];
            this.sortOrder = _data["sortOrder"];
            if (Array.isArray(_data["localizedValues"])) {
                this.localizedValues = [] as any;
                for (let item of _data["localizedValues"])
                    this.localizedValues!.push(PropertyDictionaryItemLocalizedValue.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyDictionaryItem {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["alias"] = this.alias;
        data["sortOrder"] = this.sortOrder;
        if (Array.isArray(this.localizedValues)) {
            data["localizedValues"] = [];
            for (let item of this.localizedValues)
                data["localizedValues"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IPropertyDictionaryItem {
    propertyId?: string | undefined;
    alias?: string | undefined;
    sortOrder?: number;
    localizedValues?: PropertyDictionaryItemLocalizedValue[] | undefined;
    id?: string | undefined;
}

export class PropertyDictionaryItemLocalizedValue implements IPropertyDictionaryItemLocalizedValue {
    languageCode?: string | undefined;
    value?: string | undefined;

    constructor(data?: IPropertyDictionaryItemLocalizedValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageCode = _data["languageCode"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PropertyDictionaryItemLocalizedValue {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItemLocalizedValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageCode"] = this.languageCode;
        data["value"] = this.value;
        return data;
    }
}

export interface IPropertyDictionaryItemLocalizedValue {
    languageCode?: string | undefined;
    value?: string | undefined;
}

export class PropertyDictionaryItemSearchCriteria implements IPropertyDictionaryItemSearchCriteria {
    propertyIds?: string[] | undefined;
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPropertyDictionaryItemSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["propertyIds"])) {
                this.propertyIds = [] as any;
                for (let item of _data["propertyIds"])
                    this.propertyIds!.push(item);
            }
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PropertyDictionaryItemSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItemSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.propertyIds)) {
            data["propertyIds"] = [];
            for (let item of this.propertyIds)
                data["propertyIds"].push(item);
        }
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IPropertyDictionaryItemSearchCriteria {
    propertyIds?: string[] | undefined;
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PropertyDictionaryItemSearchResult implements IPropertyDictionaryItemSearchResult {
    totalCount?: number;
    results?: PropertyDictionaryItem[] | undefined;

    constructor(data?: IPropertyDictionaryItemSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PropertyDictionaryItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertyDictionaryItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPropertyDictionaryItemSearchResult {
    totalCount?: number;
    results?: PropertyDictionaryItem[] | undefined;
}

export class PropertyDisplayName implements IPropertyDisplayName {
    name?: string | undefined;
    languageCode?: string | undefined;

    constructor(data?: IPropertyDisplayName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.languageCode = _data["languageCode"];
        }
    }

    static fromJS(data: any): PropertyDisplayName {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDisplayName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["languageCode"] = this.languageCode;
        return data;
    }
}

export interface IPropertyDisplayName {
    name?: string | undefined;
    languageCode?: string | undefined;
}

export enum PropertyType {
    Product = "Product",
    Variation = "Variation",
    Category = "Category",
    Catalog = "Catalog",
}

export class PropertyValidationRequest implements IPropertyValidationRequest {
    originalName?: string | undefined;
    name?: string | undefined;
    productId?: string | undefined;

    constructor(data?: IPropertyValidationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originalName = _data["originalName"];
            this.name = _data["name"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): PropertyValidationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValidationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalName"] = this.originalName;
        data["name"] = this.name;
        data["productId"] = this.productId;
        return data;
    }
}

export interface IPropertyValidationRequest {
    originalName?: string | undefined;
    name?: string | undefined;
    productId?: string | undefined;
}

export class PropertyValidationRule implements IPropertyValidationRule {
    isUnique?: boolean;
    charCountMin?: number | undefined;
    charCountMax?: number | undefined;
    regExp?: string | undefined;
    propertyId?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyValidationRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUnique = _data["isUnique"];
            this.charCountMin = _data["charCountMin"];
            this.charCountMax = _data["charCountMax"];
            this.regExp = _data["regExp"];
            this.propertyId = _data["propertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyValidationRule {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValidationRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUnique"] = this.isUnique;
        data["charCountMin"] = this.charCountMin;
        data["charCountMax"] = this.charCountMax;
        data["regExp"] = this.regExp;
        data["propertyId"] = this.propertyId;
        data["id"] = this.id;
        return data;
    }
}

export interface IPropertyValidationRule {
    isUnique?: boolean;
    charCountMin?: number | undefined;
    charCountMax?: number | undefined;
    regExp?: string | undefined;
    propertyId?: string | undefined;
    id?: string | undefined;
}

export class PropertyValue implements IPropertyValue {
    propertyName?: string | undefined;
    propertyId?: string | undefined;
    languageCode?: string | undefined;
    alias?: string | undefined;
    valueType?: PropertyValueValueType;
    valueId?: string | undefined;
    value?: any | undefined;
    readonly propertyMultivalue?: boolean;
    outerId?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.propertyId = _data["propertyId"];
            this.languageCode = _data["languageCode"];
            this.alias = _data["alias"];
            this.valueType = _data["valueType"];
            this.valueId = _data["valueId"];
            this.value = _data["value"];
            (<any>this).propertyMultivalue = _data["propertyMultivalue"];
            this.outerId = _data["outerId"];
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyValue {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["propertyId"] = this.propertyId;
        data["languageCode"] = this.languageCode;
        data["alias"] = this.alias;
        data["valueType"] = this.valueType;
        data["valueId"] = this.valueId;
        data["value"] = this.value;
        data["propertyMultivalue"] = this.propertyMultivalue;
        data["outerId"] = this.outerId;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPropertyValue {
    propertyName?: string | undefined;
    propertyId?: string | undefined;
    languageCode?: string | undefined;
    alias?: string | undefined;
    valueType?: PropertyValueValueType;
    valueId?: string | undefined;
    value?: any | undefined;
    propertyMultivalue?: boolean;
    outerId?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export enum PropertyValueType {
    ShortText = "ShortText",
    LongText = "LongText",
    Number = "Number",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Integer = "Integer",
    GeoPoint = "GeoPoint",
}

export class SeoInfo implements ISeoInfo {
    name?: string | undefined;
    semanticUrl?: string | undefined;
    pageTitle?: string | undefined;
    metaDescription?: string | undefined;
    imageAltDescription?: string | undefined;
    metaKeywords?: string | undefined;
    storeId?: string | undefined;
    objectId?: string | undefined;
    objectType?: string | undefined;
    isActive?: boolean;
    languageCode?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISeoInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.semanticUrl = _data["semanticUrl"];
            this.pageTitle = _data["pageTitle"];
            this.metaDescription = _data["metaDescription"];
            this.imageAltDescription = _data["imageAltDescription"];
            this.metaKeywords = _data["metaKeywords"];
            this.storeId = _data["storeId"];
            this.objectId = _data["objectId"];
            this.objectType = _data["objectType"];
            this.isActive = _data["isActive"];
            this.languageCode = _data["languageCode"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SeoInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SeoInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["semanticUrl"] = this.semanticUrl;
        data["pageTitle"] = this.pageTitle;
        data["metaDescription"] = this.metaDescription;
        data["imageAltDescription"] = this.imageAltDescription;
        data["metaKeywords"] = this.metaKeywords;
        data["storeId"] = this.storeId;
        data["objectId"] = this.objectId;
        data["objectType"] = this.objectType;
        data["isActive"] = this.isActive;
        data["languageCode"] = this.languageCode;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ISeoInfo {
    name?: string | undefined;
    semanticUrl?: string | undefined;
    pageTitle?: string | undefined;
    metaDescription?: string | undefined;
    imageAltDescription?: string | undefined;
    metaKeywords?: string | undefined;
    storeId?: string | undefined;
    objectId?: string | undefined;
    objectType?: string | undefined;
    isActive?: boolean;
    languageCode?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export enum Severity {
    Error = "Error",
    Warning = "Warning",
    Info = "Info",
}

export enum SortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class SortInfo implements ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortInfoSortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sortColumn = _data["sortColumn"];
            this.sortDirection = _data["sortDirection"];
        }
    }

    static fromJS(data: any): SortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortColumn"] = this.sortColumn;
        data["sortDirection"] = this.sortDirection;
        return data;
    }
}

export interface ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortInfoSortDirection;
}

export class SuggestionResponse implements ISuggestionResponse {
    suggestions?: string[] | undefined;

    constructor(data?: ISuggestionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["suggestions"])) {
                this.suggestions = [] as any;
                for (let item of _data["suggestions"])
                    this.suggestions!.push(item);
            }
        }
    }

    static fromJS(data: any): SuggestionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.suggestions)) {
            data["suggestions"] = [];
            for (let item of this.suggestions)
                data["suggestions"].push(item);
        }
        return data;
    }
}

export interface ISuggestionResponse {
    suggestions?: string[] | undefined;
}

export class ValidationFailure implements IValidationFailure {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    customState?: any | undefined;
    severity?: ValidationFailureSeverity;
    errorCode?: string | undefined;
    formattedMessagePlaceholderValues?: { [key: string]: any; } | undefined;

    constructor(data?: IValidationFailure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.errorMessage = _data["errorMessage"];
            this.attemptedValue = _data["attemptedValue"];
            this.customState = _data["customState"];
            this.severity = _data["severity"];
            this.errorCode = _data["errorCode"];
            if (_data["formattedMessagePlaceholderValues"]) {
                this.formattedMessagePlaceholderValues = {} as any;
                for (let key in _data["formattedMessagePlaceholderValues"]) {
                    if (_data["formattedMessagePlaceholderValues"].hasOwnProperty(key))
                        (<any>this.formattedMessagePlaceholderValues)![key] = _data["formattedMessagePlaceholderValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): ValidationFailure {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationFailure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["customState"] = this.customState;
        data["severity"] = this.severity;
        data["errorCode"] = this.errorCode;
        if (this.formattedMessagePlaceholderValues) {
            data["formattedMessagePlaceholderValues"] = {};
            for (let key in this.formattedMessagePlaceholderValues) {
                if (this.formattedMessagePlaceholderValues.hasOwnProperty(key))
                    (<any>data["formattedMessagePlaceholderValues"])[key] = (<any>this.formattedMessagePlaceholderValues)[key];
            }
        }
        return data;
    }
}

export interface IValidationFailure {
    propertyName?: string | undefined;
    errorMessage?: string | undefined;
    attemptedValue?: any | undefined;
    customState?: any | undefined;
    severity?: ValidationFailureSeverity;
    errorCode?: string | undefined;
    formattedMessagePlaceholderValues?: { [key: string]: any; } | undefined;
}

export class ValidationResult implements IValidationResult {
    readonly isValid?: boolean;
    readonly errors?: ValidationFailure[] | undefined;
    readonly ruleSetsExecuted?: string[] | undefined;

    constructor(data?: IValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).isValid = _data["isValid"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(ValidationFailure.fromJS(item));
            }
            if (Array.isArray(_data["ruleSetsExecuted"])) {
                (<any>this).ruleSetsExecuted = [] as any;
                for (let item of _data["ruleSetsExecuted"])
                    (<any>this).ruleSetsExecuted!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (Array.isArray(this.ruleSetsExecuted)) {
            data["ruleSetsExecuted"] = [];
            for (let item of this.ruleSetsExecuted)
                data["ruleSetsExecuted"].push(item);
        }
        return data;
    }
}

export interface IValidationResult {
    isValid?: boolean;
    errors?: ValidationFailure[] | undefined;
    ruleSetsExecuted?: string[] | undefined;
}

export class Variation implements IVariation {
    productType?: string | undefined;
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    readonly outline?: string | undefined;
    readonly path?: string | undefined;
    readonly titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isActive?: boolean | undefined;
    isBuyable?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    readonly isInherited?: boolean;
    readonly parentCategoryIsActive?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IVariation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productType = _data["productType"];
            this.code = _data["code"];
            this.manufacturerPartNumber = _data["manufacturerPartNumber"];
            this.gtin = _data["gtin"];
            this.name = _data["name"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            (<any>this).titularItemId = _data["titularItemId"];
            this.mainProductId = _data["mainProductId"];
            this.isActive = _data["isActive"];
            this.isBuyable = _data["isBuyable"];
            this.trackInventory = _data["trackInventory"];
            this.indexingDate = _data["indexingDate"] ? new Date(_data["indexingDate"].toString()) : <any>undefined;
            this.maxQuantity = _data["maxQuantity"];
            this.minQuantity = _data["minQuantity"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.packageType = _data["packageType"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.enableReview = _data["enableReview"];
            this.maxNumberOfDownload = _data["maxNumberOfDownload"];
            this.downloadExpiration = _data["downloadExpiration"] ? new Date(_data["downloadExpiration"].toString()) : <any>undefined;
            this.downloadType = _data["downloadType"];
            this.hasUserAgreement = _data["hasUserAgreement"];
            this.shippingType = _data["shippingType"];
            this.taxType = _data["taxType"];
            this.vendor = _data["vendor"];
            this.priority = _data["priority"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            if (Array.isArray(_data["excludedProperties"])) {
                this.excludedProperties = [] as any;
                for (let item of _data["excludedProperties"])
                    this.excludedProperties!.push(ExcludedProperty.fromJS(item));
            }
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValue.fromJS(item));
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets!.push(Asset.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(Variation.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(EditorialReview.fromJS(item));
            }
            if (Array.isArray(_data["associations"])) {
                this.associations = [] as any;
                for (let item of _data["associations"])
                    this.associations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["referencedAssociations"])) {
                this.referencedAssociations = [] as any;
                for (let item of _data["referencedAssociations"])
                    this.referencedAssociations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(Outline.fromJS(item));
            }
            (<any>this).isInherited = _data["isInherited"];
            (<any>this).parentCategoryIsActive = _data["parentCategoryIsActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Variation {
        data = typeof data === 'object' ? data : {};
        let result = new Variation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productType"] = this.productType;
        data["code"] = this.code;
        data["manufacturerPartNumber"] = this.manufacturerPartNumber;
        data["gtin"] = this.gtin;
        data["name"] = this.name;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["titularItemId"] = this.titularItemId;
        data["mainProductId"] = this.mainProductId;
        data["isActive"] = this.isActive;
        data["isBuyable"] = this.isBuyable;
        data["trackInventory"] = this.trackInventory;
        data["indexingDate"] = this.indexingDate ? this.indexingDate.toISOString() : <any>undefined;
        data["maxQuantity"] = this.maxQuantity;
        data["minQuantity"] = this.minQuantity;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["packageType"] = this.packageType;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["enableReview"] = this.enableReview;
        data["maxNumberOfDownload"] = this.maxNumberOfDownload;
        data["downloadExpiration"] = this.downloadExpiration ? this.downloadExpiration.toISOString() : <any>undefined;
        data["downloadType"] = this.downloadType;
        data["hasUserAgreement"] = this.hasUserAgreement;
        data["shippingType"] = this.shippingType;
        data["taxType"] = this.taxType;
        data["vendor"] = this.vendor;
        data["priority"] = this.priority;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.excludedProperties)) {
            data["excludedProperties"] = [];
            for (let item of this.excludedProperties)
                data["excludedProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        if (Array.isArray(this.associations)) {
            data["associations"] = [];
            for (let item of this.associations)
                data["associations"].push(item.toJSON());
        }
        if (Array.isArray(this.referencedAssociations)) {
            data["referencedAssociations"] = [];
            for (let item of this.referencedAssociations)
                data["referencedAssociations"].push(item.toJSON());
        }
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item.toJSON());
        }
        data["isInherited"] = this.isInherited;
        data["parentCategoryIsActive"] = this.parentCategoryIsActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IVariation {
    productType?: string | undefined;
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    outline?: string | undefined;
    path?: string | undefined;
    titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isActive?: boolean | undefined;
    isBuyable?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    isInherited?: boolean;
    parentCategoryIsActive?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Video implements IVideo {
    name?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    uploadDate?: Date | undefined;
    thumbnailUrl?: string | undefined;
    contentUrl?: string | undefined;
    embedUrl?: string | undefined;
    duration?: string | undefined;
    languageCode?: string | undefined;
    ownerId?: string | undefined;
    ownerType?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IVideo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.uploadDate = _data["uploadDate"] ? new Date(_data["uploadDate"].toString()) : <any>undefined;
            this.thumbnailUrl = _data["thumbnailUrl"];
            this.contentUrl = _data["contentUrl"];
            this.embedUrl = _data["embedUrl"];
            this.duration = _data["duration"];
            this.languageCode = _data["languageCode"];
            this.ownerId = _data["ownerId"];
            this.ownerType = _data["ownerType"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Video {
        data = typeof data === 'object' ? data : {};
        let result = new Video();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["uploadDate"] = this.uploadDate ? this.uploadDate.toISOString() : <any>undefined;
        data["thumbnailUrl"] = this.thumbnailUrl;
        data["contentUrl"] = this.contentUrl;
        data["embedUrl"] = this.embedUrl;
        data["duration"] = this.duration;
        data["languageCode"] = this.languageCode;
        data["ownerId"] = this.ownerId;
        data["ownerType"] = this.ownerType;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IVideo {
    name?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    uploadDate?: Date | undefined;
    thumbnailUrl?: string | undefined;
    contentUrl?: string | undefined;
    embedUrl?: string | undefined;
    duration?: string | undefined;
    languageCode?: string | undefined;
    ownerId?: string | undefined;
    ownerType?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class VideoCreateRequest implements IVideoCreateRequest {
    contentUrl?: string | undefined;
    sortOrder?: number | undefined;
    languageCode?: string | undefined;
    ownerId?: string | undefined;
    ownerType?: string | undefined;

    constructor(data?: IVideoCreateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentUrl = _data["contentUrl"];
            this.sortOrder = _data["sortOrder"];
            this.languageCode = _data["languageCode"];
            this.ownerId = _data["ownerId"];
            this.ownerType = _data["ownerType"];
        }
    }

    static fromJS(data: any): VideoCreateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VideoCreateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentUrl"] = this.contentUrl;
        data["sortOrder"] = this.sortOrder;
        data["languageCode"] = this.languageCode;
        data["ownerId"] = this.ownerId;
        data["ownerType"] = this.ownerType;
        return data;
    }
}

export interface IVideoCreateRequest {
    contentUrl?: string | undefined;
    sortOrder?: number | undefined;
    languageCode?: string | undefined;
    ownerId?: string | undefined;
    ownerType?: string | undefined;
}

export class VideoOptions implements IVideoOptions {
    googleApiKey?: string | undefined;

    constructor(data?: IVideoOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.googleApiKey = _data["googleApiKey"];
        }
    }

    static fromJS(data: any): VideoOptions {
        data = typeof data === 'object' ? data : {};
        let result = new VideoOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleApiKey"] = this.googleApiKey;
        return data;
    }
}

export interface IVideoOptions {
    googleApiKey?: string | undefined;
}

export class VideoSearchCriteria implements IVideoSearchCriteria {
    ownerIds?: string[] | undefined;
    ownerType?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IVideoSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ownerIds"])) {
                this.ownerIds = [] as any;
                for (let item of _data["ownerIds"])
                    this.ownerIds!.push(item);
            }
            this.ownerType = _data["ownerType"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): VideoSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new VideoSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ownerIds)) {
            data["ownerIds"] = [];
            for (let item of this.ownerIds)
                data["ownerIds"].push(item);
        }
        data["ownerType"] = this.ownerType;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IVideoSearchCriteria {
    ownerIds?: string[] | undefined;
    ownerType?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class VideoSearchResult implements IVideoSearchResult {
    totalCount?: number;
    results?: Video[] | undefined;

    constructor(data?: IVideoSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Video.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VideoSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new VideoSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVideoSearchResult {
    totalCount?: number;
    results?: Video[] | undefined;
}

export enum PropertyValueType2 {
    ShortText = "ShortText",
    LongText = "LongText",
    Number = "Number",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Integer = "Integer",
    GeoPoint = "GeoPoint",
}

export enum PropertyType2 {
    Product = "Product",
    Variation = "Variation",
    Category = "Category",
    Catalog = "Catalog",
}

export enum PropertyValueValueType {
    ShortText = "ShortText",
    LongText = "LongText",
    Number = "Number",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Integer = "Integer",
    GeoPoint = "GeoPoint",
}

export enum SortInfoSortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export enum ValidationFailureSeverity {
    Error = "Error",
    Warning = "Warning",
    Info = "Info",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* eslint-disable */