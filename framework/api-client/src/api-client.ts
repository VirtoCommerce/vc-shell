/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AuthorizationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    exchange(): Promise<void> {
        let url_ = this.baseUrl + "/connect/token";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExchange(_response);
        });
    }

    protected processExchange(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ExternalSignInClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param authenticationType (optional) 
     * @return Success
     */
    signIn(authenticationType: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/externalsignin?";
        if (authenticationType !== undefined && authenticationType !== null)
            url_ += "authenticationType=" + encodeURIComponent("" + authenticationType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param returnUrl (optional) 
     * @return Success
     */
    signInCallback(returnUrl: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/externalsignin/callback?";
        if (returnUrl !== undefined && returnUrl !== null)
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignInCallback(_response);
        });
    }

    protected processSignInCallback(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalLoginProviders(): Promise<void> {
        let url_ = this.baseUrl + "/externalsignin/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalLoginProviders(_response);
        });
    }

    protected processGetExternalLoginProviders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AssetEntryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * SearchAsync for AssetEntries by AssetEntrySearchCriteria
     * @param body (optional) 
     * @return Success
     */
    search(body: AssetEntrySearchCriteria | undefined): Promise<AssetEntrySearchResult> {
        let url_ = this.baseUrl + "/api/platform/assetentries/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<AssetEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssetEntrySearchResult>(<any>null);
    }

    /**
     * Get asset details by id
     * @param idQuery (optional) 
     * @return Success
     */
    get(idQuery: string | null | undefined, idPath: string): Promise<AssetEntry> {
        let url_ = this.baseUrl + "/api/platform/assetentries/{id}?";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        if (idQuery !== undefined && idQuery !== null)
            url_ += "id=" + encodeURIComponent("" + idQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<AssetEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssetEntry>(<any>null);
    }

    /**
     * Create / Update asset entry
     * @param body (optional) 
     * @return Success
     */
    update(body: AssetEntry | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/assetentries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete asset entries by ids
     * @param ids (optional) 
     * @return Success
     */
    delete(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/assetentries?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class AssetsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * This method used to upload files on local disk storage in special uploads folder
     * @return Success
     */
    uploadAssetToLocalFileSystem(): Promise<BlobInfo[]> {
        let url_ = this.baseUrl + "/api/platform/assets/localstorage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadAssetToLocalFileSystem(_response);
        });
    }

    protected processUploadAssetToLocalFileSystem(response: Response): Promise<BlobInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlobInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BlobInfo[]>(<any>null);
    }

    /**
     * Upload assets to the folder
     * @param folderUrl (optional) Parent folder url (relative or absolute).
     * @param url (optional) Url for uploaded remote resource (optional)
     * @param name (optional) File name
     * @param uploadedFile (optional) Upload File
     * @return Success
     */
    uploadAsset(folderUrl: string | null | undefined, url: string | null | undefined, name: string | null | undefined, uploadedFile: string | undefined): Promise<BlobInfo[]> {
        let url_ = this.baseUrl + "/api/platform/assets?";
        if (folderUrl !== undefined && folderUrl !== null)
            url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
        if (url !== undefined && url !== null)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (uploadedFile === null)
            throw new Error("The parameter 'uploadedFile' cannot be null.");
        else if (uploadedFile !== undefined)
            url_ += "uploadedFile=" + encodeURIComponent("" + uploadedFile) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadAsset(_response);
        });
    }

    protected processUploadAsset(response: Response): Promise<BlobInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BlobInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BlobInfo[]>(<any>null);
    }

    /**
     * Delete blobs by urls
     * @param urls (optional) 
     * @return Success
     */
    deleteBlobs(urls: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/assets?";
        if (urls !== undefined && urls !== null)
            urls && urls.forEach(item => { url_ += "urls=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteBlobs(_response);
        });
    }

    protected processDeleteBlobs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * SearchAsync asset folders and blobs
     * @param folderUrl (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    searchAssetItems(folderUrl: string | null | undefined, keyword: string | null | undefined): Promise<BlobEntrySearchResult> {
        let url_ = this.baseUrl + "/api/platform/assets?";
        if (folderUrl !== undefined && folderUrl !== null)
            url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchAssetItems(_response);
        });
    }

    protected processSearchAssetItems(response: Response): Promise<BlobEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BlobEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BlobEntrySearchResult>(<any>null);
    }

    /**
     * Create new blob folder
     * @param body (optional) 
     * @return Success
     */
    createBlobFolder(body: BlobFolder | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/assets/folder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateBlobFolder(_response);
        });
    }

    protected processCreateBlobFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ChangeLogClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Force set changes last modified date
     * @param scope (optional) 
     * @return Success
     */
    forceChanges(scope: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/changes/force?";
        if (scope !== undefined && scope !== null)
            url_ += "Scope=" + encodeURIComponent("" + scope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForceChanges(_response);
        });
    }

    protected processForceChanges(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    resetPlatformCache(): Promise<void> {
        let url_ = this.baseUrl + "/api/platform-cache/reset";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPlatformCache(_response);
        });
    }

    protected processResetPlatformCache(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get last modified date for given scope
    Used for signal of what something changed and for cache invalidation in external platform clients
     * @param scope (optional) 
     * @return Success
     */
    getLastModifiedDate(scope: string | null | undefined): Promise<LastModifiedResponse> {
        let url_ = this.baseUrl + "/api/changes/lastmodifieddate?";
        if (scope !== undefined && scope !== null)
            url_ += "scope=" + encodeURIComponent("" + scope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLastModifiedDate(_response);
        });
    }

    protected processGetLastModifiedDate(response: Response): Promise<LastModifiedResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LastModifiedResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LastModifiedResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getChangedEntities(body: ChangedEntitiesRequest | undefined): Promise<ChangedEntitiesResponse> {
        let url_ = this.baseUrl + "/api/changes/changed-entities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetChangedEntities(_response);
        });
    }

    protected processGetChangedEntities(response: Response): Promise<ChangedEntitiesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangedEntitiesResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChangedEntitiesResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetChangedEntities(body: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/changes/changed-entities/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetChangedEntities(_response);
        });
    }

    protected processResetChangedEntities(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchChanges(body: ChangeLogSearchCriteria | undefined): Promise<ChangeLogSearchResult> {
        let url_ = this.baseUrl + "/api/platform/changelog/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchChanges(_response);
        });
    }

    protected processSearchChanges(response: Response): Promise<ChangeLogSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangeLogSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChangeLogSearchResult>(<any>null);
    }

    /**
     * @param start (optional) 
     * @param end (optional) 
     * @return Success
     */
    searchTypeChangeHistory(type: string | null, start: Date | null | undefined, end: Date | null | undefined): Promise<OperationLog[]> {
        let url_ = this.baseUrl + "/api/platform/changelog/{type}/changes?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchTypeChangeHistory(_response);
        });
    }

    protected processSearchTypeChangeHistory(response: Response): Promise<OperationLog[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OperationLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationLog[]>(<any>null);
    }
}

export class DiagnosticsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getSystemInfo(): Promise<SystemInfo> {
        let url_ = this.baseUrl + "/api/platform/diagnostics/systeminfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSystemInfo(_response);
        });
    }

    protected processGetSystemInfo(response: Response): Promise<SystemInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SystemInfo>(<any>null);
    }

    /**
     * Get installed modules with errors
     * @return Success
     */
    getModulesErrors(): Promise<ModuleDescriptor[]> {
        let url_ = this.baseUrl + "/api/platform/diagnostics/errors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModulesErrors(_response);
        });
    }

    protected processGetModulesErrors(response: Response): Promise<ModuleDescriptor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModuleDescriptor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDescriptor[]>(<any>null);
    }
}

export class DynamicPropertiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get object types which support dynamic properties
     * @return Success
     */
    getObjectTypes(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/platform/dynamic/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetObjectTypes(_response);
        });
    }

    protected processGetObjectTypes(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * Get dynamic properties registered for object type
     * @param body (optional) 
     * @return Success
     */
    searchDynamicProperties(body: DynamicPropertySearchCriteria | undefined): Promise<DynamicPropertySearchResult> {
        let url_ = this.baseUrl + "/api/platform/dynamic/properties/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchDynamicProperties(_response);
        });
    }

    protected processSearchDynamicProperties(response: Response): Promise<DynamicPropertySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicPropertySearchResult>(<any>null);
    }

    /**
     * Add new dynamic property
     * @param body (optional) 
     * @return Success
     */
    createProperty(body: DynamicProperty | undefined): Promise<DynamicProperty> {
        let url_ = this.baseUrl + "/api/platform/dynamic/properties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProperty(_response);
        });
    }

    protected processCreateProperty(response: Response): Promise<DynamicProperty> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicProperty.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicProperty>(<any>null);
    }

    /**
     * Update existing dynamic property
     * @param body (optional) 
     * @return Success
     */
    updateProperty(body: DynamicProperty | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/dynamic/properties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProperty(_response);
        });
    }

    protected processUpdateProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete dynamic property
     * @param propertyIds (optional) 
     * @return Success
     */
    deleteProperty(propertyIds: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/dynamic/properties?";
        if (propertyIds !== undefined && propertyIds !== null)
            propertyIds && propertyIds.forEach(item => { url_ += "propertyIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Does nothing. Just a way to expose DynamicObjectProperty thru Swagger.
     * @return Success
     */
    exposeDynamicObjectProperty(): Promise<DynamicObjectProperty> {
        let url_ = this.baseUrl + "/api/platform/dynamic";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExposeDynamicObjectProperty(_response);
        });
    }

    protected processExposeDynamicObjectProperty(response: Response): Promise<DynamicObjectProperty> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicObjectProperty.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("Success", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicObjectProperty>(<any>null);
    }

    /**
     * Get dictionary items
     * @param body (optional) 
     * @return Success
     */
    searchDictionaryItems(body: DynamicPropertyDictionaryItemSearchCriteria | undefined): Promise<DynamicPropertyDictionaryItemSearchResult> {
        let url_ = this.baseUrl + "/api/platform/dynamic/dictionaryitems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchDictionaryItems(_response);
        });
    }

    protected processSearchDictionaryItems(response: Response): Promise<DynamicPropertyDictionaryItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyDictionaryItemSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicPropertyDictionaryItemSearchResult>(<any>null);
    }

    /**
     * Add or update dictionary items
     * @param body (optional) 
     * @return Success
     */
    saveDictionaryItems(body: DynamicPropertyDictionaryItem[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/dynamic/dictionaryitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveDictionaryItems(_response);
        });
    }

    protected processSaveDictionaryItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete dictionary items
     * @param ids (optional) IDs of dictionary items to delete.
     * @return Success
     */
    deleteDictionaryItem(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/dynamic/dictionaryitems?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDictionaryItem(_response);
        });
    }

    protected processDeleteDictionaryItem(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class JobsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get background job status
     * @param id Job ID.
     * @return Success
     */
    getStatus(id: string | null): Promise<Job> {
        let url_ = this.baseUrl + "/api/platform/jobs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<Job> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Job.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Job>(<any>null);
    }
}

export class ModulesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Reload  modules
     * @return Success
     */
    reloadModules(): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/modules/reload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReloadModules(_response);
        });
    }

    protected processReloadModules(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get installed modules
     * @return Success
     */
    getModules(): Promise<ModuleDescriptor[]> {
        let url_ = this.baseUrl + "/api/platform/modules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetModules(_response);
        });
    }

    protected processGetModules(response: Response): Promise<ModuleDescriptor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModuleDescriptor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDescriptor[]>(<any>null);
    }

    /**
     * Get all dependent modules for module
     * @param body (optional) modules descriptors
     * @return Success
     */
    getDependingModules(body: ModuleDescriptor[] | null | undefined): Promise<ModuleDescriptor[]> {
        let url_ = this.baseUrl + "/api/platform/modules/getdependents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDependingModules(_response);
        });
    }

    protected processGetDependingModules(response: Response): Promise<ModuleDescriptor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModuleDescriptor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDescriptor[]>(<any>null);
    }

    /**
     * Returns a flat expanded  list of modules that depend on passed modules
     * @param body (optional) modules descriptors
     * @return Success
     */
    getMissingDependencies(body: ModuleDescriptor[] | null | undefined): Promise<ModuleDescriptor[]> {
        let url_ = this.baseUrl + "/api/platform/modules/getmissingdependencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMissingDependencies(_response);
        });
    }

    protected processGetMissingDependencies(response: Response): Promise<ModuleDescriptor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ModuleDescriptor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDescriptor[]>(<any>null);
    }

    /**
     * Upload module package for installation or update
     * @return Success
     */
    uploadModuleArchive(): Promise<ModuleDescriptor> {
        let url_ = this.baseUrl + "/api/platform/modules/localstorage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadModuleArchive(_response);
        });
    }

    protected processUploadModuleArchive(response: Response): Promise<ModuleDescriptor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleDescriptor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleDescriptor>(<any>null);
    }

    /**
     * Install modules
     * @param body (optional) modules for install
     * @return Success
     */
    installModules(body: ModuleDescriptor[] | null | undefined): Promise<ModulePushNotification> {
        let url_ = this.baseUrl + "/api/platform/modules/install";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallModules(_response);
        });
    }

    protected processInstallModules(response: Response): Promise<ModulePushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModulePushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModulePushNotification>(<any>null);
    }

    /**
     * Uninstall module
     * @param body (optional) modules
     * @return Success
     */
    uninstallModule(body: ModuleDescriptor[] | null | undefined): Promise<ModulePushNotification> {
        let url_ = this.baseUrl + "/api/platform/modules/uninstall";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUninstallModule(_response);
        });
    }

    protected processUninstallModule(response: Response): Promise<ModulePushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModulePushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModulePushNotification>(<any>null);
    }

    /**
     * Restart web application
     * @return Success
     */
    restart(): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/modules/restart";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRestart(_response);
        });
    }

    protected processRestart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Auto-install modules with specified groups
     * @return Success
     */
    tryToAutoInstallModules(): Promise<ModuleAutoInstallPushNotification> {
        let url_ = this.baseUrl + "/api/platform/modules/autoinstall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTryToAutoInstallModules(_response);
        });
    }

    protected processTryToAutoInstallModules(response: Response): Promise<ModuleAutoInstallPushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ModuleAutoInstallPushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ModuleAutoInstallPushNotification>(<any>null);
    }
}

export class OAuthAppsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    new(): Promise<OpenIddictApplicationDescriptor> {
        let url_ = this.baseUrl + "/api/platform/oauthapps/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNew(_response);
        });
    }

    protected processNew(response: Response): Promise<OpenIddictApplicationDescriptor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OpenIddictApplicationDescriptor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenIddictApplicationDescriptor>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    save(body: OpenIddictApplicationDescriptor | undefined): Promise<OpenIddictApplicationDescriptor> {
        let url_ = this.baseUrl + "/api/platform/oauthapps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSave(_response);
        });
    }

    protected processSave(response: Response): Promise<OpenIddictApplicationDescriptor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OpenIddictApplicationDescriptor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenIddictApplicationDescriptor>(<any>null);
    }

    /**
     * @param clientIds (optional) 
     * @return Success
     */
    delete(clientIds: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/oauthapps?";
        if (clientIds !== undefined && clientIds !== null)
            clientIds && clientIds.forEach(item => { url_ += "clientIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    search(body: OAuthAppSearchCriteria | undefined): Promise<OAuthAppSearchResult> {
        let url_ = this.baseUrl + "/api/platform/oauthapps/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<OAuthAppSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OAuthAppSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OAuthAppSearchResult>(<any>null);
    }
}

export class PushNotificationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * SearchAsync push notifications
     * @param ids (optional) 
     * @param onlyNew (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param responseGroup (optional) 
     * @param objectType (optional) 
     * @param objectTypes (optional) 
     * @param objectIds (optional) 
     * @param keyword (optional) 
     * @param searchPhrase (optional) 
     * @param languageCode (optional) 
     * @param sort (optional) 
     * @param sortInfos (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    searchPushNotification(ids: string[] | null | undefined, onlyNew: boolean | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, responseGroup: string | null | undefined, objectType: string | null | undefined, objectTypes: string[] | null | undefined, objectIds: string[] | null | undefined, keyword: string | null | undefined, searchPhrase: string | null | undefined, languageCode: string | null | undefined, sort: string | null | undefined, sortInfos: SortInfo[] | null | undefined, skip: number | undefined, take: number | undefined): Promise<PushNotificationSearchResult> {
        let url_ = this.baseUrl + "/api/platform/pushnotifications?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "Ids=" + encodeURIComponent("" + item) + "&"; });
        if (onlyNew === null)
            throw new Error("The parameter 'onlyNew' cannot be null.");
        else if (onlyNew !== undefined)
            url_ += "OnlyNew=" + encodeURIComponent("" + onlyNew) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (objectTypes !== undefined && objectTypes !== null)
            objectTypes && objectTypes.forEach(item => { url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&"; });
        if (objectIds !== undefined && objectIds !== null)
            objectIds && objectIds.forEach(item => { url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&"; });
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (sortInfos !== undefined && sortInfos !== null)
            sortInfos && sortInfos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "SortInfos[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchPushNotification(_response);
        });
    }

    protected processSearchPushNotification(response: Response): Promise<PushNotificationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PushNotificationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PushNotificationSearchResult>(<any>null);
    }

    /**
     * Mark all notifications as read
     * @return Success
     */
    markAllAsRead(): Promise<PushNotificationSearchResult> {
        let url_ = this.baseUrl + "/api/platform/pushnotifications/markAllAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMarkAllAsRead(_response);
        });
    }

    protected processMarkAllAsRead(response: Response): Promise<PushNotificationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PushNotificationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PushNotificationSearchResult>(<any>null);
    }
}

export class SecurityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Sign in with user name and password
     * @param body (optional) Login request.
     * @return Success
     */
    login(body: LoginRequest | undefined): Promise<SignInResult> {
        let url_ = this.baseUrl + "/api/platform/security/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<SignInResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SignInResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SignInResult>(<any>null);
    }

    /**
     * Sign out
     * @return Success
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get current user details
     * @return Success
     */
    getCurrentUser(): Promise<UserDetail> {
        let url_ = this.baseUrl + "/api/platform/security/currentuser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUser(_response);
        });
    }

    protected processGetCurrentUser(response: Response): Promise<UserDetail> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDetail.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDetail>(<any>null);
    }

    /**
     * @return Success
     */
    userinfo(): Promise<Claim[]> {
        let url_ = this.baseUrl + "/api/platform/security/userinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserinfo(_response);
        });
    }

    protected processUserinfo(response: Response): Promise<Claim[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Claim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Claim[]>(<any>null);
    }

    /**
     * Get all registered permissions
     * @return Success
     */
    getAllRegisteredPermissions(): Promise<Permission[]> {
        let url_ = this.baseUrl + "/api/platform/security/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRegisteredPermissions(_response);
        });
    }

    protected processGetAllRegisteredPermissions(response: Response): Promise<Permission[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Permission.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Permission[]>(<any>null);
    }

    /**
     * SearchAsync roles by keyword
     * @param body (optional) SearchAsync parameters.
     * @return Success
     */
    searchRoles(body: RoleSearchCriteria | undefined): Promise<RoleSearchResult> {
        let url_ = this.baseUrl + "/api/platform/security/roles/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchRoles(_response);
        });
    }

    protected processSearchRoles(response: Response): Promise<RoleSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleSearchResult>(<any>null);
    }

    /**
     * Get role by ID
     * @return Success
     */
    getRole(roleName: string | null): Promise<Role> {
        let url_ = this.baseUrl + "/api/platform/security/roles/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRole(_response);
        });
    }

    protected processGetRole(response: Response): Promise<Role> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role>(<any>null);
    }

    /**
     * Delete roles by ID
     * @param ids (optional) An array of role IDs.
     * @return Success
     */
    deleteRoles(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/roles?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRoles(_response);
        });
    }

    protected processDeleteRoles(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update an existing role or create new
     * @param body (optional) 
     * @return Success
     */
    updateRole(body: Role | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(<any>null);
    }

    /**
     * SearchAsync users by keyword
     * @param body (optional) Search criteria.
     * @return Success
     */
    searchUsers(body: UserSearchCriteria | undefined): Promise<UserSearchResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUsers(_response);
        });
    }

    protected processSearchUsers(response: Response): Promise<UserSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSearchResult>(<any>null);
    }

    /**
     * Get user details by user name
     * @return Success
     */
    getUserByName(userName: string | null): Promise<ApplicationUser> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserByName(_response);
        });
    }

    protected processGetUserByName(response: Response): Promise<ApplicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUser>(<any>null);
    }

    /**
     * Get user details by user ID
     * @return Success
     */
    getUserById(id: string | null): Promise<ApplicationUser> {
        let url_ = this.baseUrl + "/api/platform/security/users/id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: Response): Promise<ApplicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUser>(<any>null);
    }

    /**
     * Get user details by user email
     * @return Success
     */
    getUserByEmail(email: string | null): Promise<ApplicationUser> {
        let url_ = this.baseUrl + "/api/platform/security/users/email/{email}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserByEmail(_response);
        });
    }

    protected processGetUserByEmail(response: Response): Promise<ApplicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUser>(<any>null);
    }

    /**
     * Get user details by external login provider
     * @return Success
     */
    getUserByLogin(loginProvider: string | null, providerKey: string | null): Promise<ApplicationUser> {
        let url_ = this.baseUrl + "/api/platform/security/users/login/external/{loginProvider}/{providerKey}";
        if (loginProvider === undefined || loginProvider === null)
            throw new Error("The parameter 'loginProvider' must be defined.");
        url_ = url_.replace("{loginProvider}", encodeURIComponent("" + loginProvider));
        if (providerKey === undefined || providerKey === null)
            throw new Error("The parameter 'providerKey' must be defined.");
        url_ = url_.replace("{providerKey}", encodeURIComponent("" + providerKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserByLogin(_response);
        });
    }

    protected processGetUserByLogin(response: Response): Promise<ApplicationUser> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUser.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUser>(<any>null);
    }

    /**
     * Create new user
     * @param body (optional) 
     * @return Success
     */
    create(body: ApplicationUser | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(<any>null);
    }

    /**
     * Change password for current user.
     * @param body (optional) Old and new passwords.
     * @return Success
     */
    changeCurrentUserPassword(body: ChangePasswordRequest | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/currentuser/changepassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeCurrentUserPassword(_response);
        });
    }

    protected processChangeCurrentUserPassword(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(<any>null);
    }

    /**
     * Change password
     * @param userName user name
     * @param body (optional) Old and new passwords.
     * @return Success
     */
    changePassword(userName: string | null, body: ChangePasswordRequest | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userName}/changepassword";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(<any>null);
    }

    /**
     * Reset password confirmation
     * @param body (optional) Password reset information containing new password.
     * @return Success
     */
    resetPassword(userName: string | null, body: ResetPasswordConfirmRequest | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userName}/resetpassword";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(<any>null);
    }

    /**
     * Reset password confirmation
     * @param body (optional) New password.
     * @return Success
     */
    resetPasswordByToken(userId: string | null, body: ResetPasswordConfirmRequest | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userId}/resetpasswordconfirm";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPasswordByToken(_response);
        });
    }

    protected processResetPasswordByToken(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(<any>null);
    }

    /**
     * Validate password reset token
     * @param body (optional) 
     * @return Success
     */
    validatePasswordResetToken(userId: string | null, body: ValidatePasswordResetTokenRequest | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userId}/validatepasswordresettoken";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidatePasswordResetToken(_response);
        });
    }

    protected processValidatePasswordResetToken(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    /**
     * Send email with instructions on how to reset user password.
     * @return Success
     */
    requestPasswordReset(loginOrEmail: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/users/{loginOrEmail}/requestpasswordreset";
        if (loginOrEmail === undefined || loginOrEmail === null)
            throw new Error("The parameter 'loginOrEmail' must be defined.");
        url_ = url_.replace("{loginOrEmail}", encodeURIComponent("" + loginOrEmail));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestPasswordReset(_response);
        });
    }

    protected processRequestPasswordReset(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validatePassword(body: string | null | undefined): Promise<IdentityResult> {
        let url_ = this.baseUrl + "/api/platform/security/validatepassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidatePassword(_response);
        });
    }

    protected processValidatePassword(response: Response): Promise<IdentityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validateUserPassword(body: ChangePasswordRequest | undefined): Promise<IdentityResult> {
        let url_ = this.baseUrl + "/api/platform/security/validateuserpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateUserPassword(_response);
        });
    }

    protected processValidateUserPassword(response: Response): Promise<IdentityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IdentityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdentityResult>(<any>null);
    }

    /**
     * Update user details by user ID
     * @param body (optional) User details.
     * @return Success
     */
    update(body: ApplicationUser | undefined): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(<any>null);
    }

    /**
     * Delete users by name
     * @param names (optional) An array of user names.
     * @return Success
     */
    delete(names: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/users?";
        if (names !== undefined && names !== null)
            names && names.forEach(item => { url_ += "names=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Checks if user locked
     * @param id User id
     * @return Success
     */
    isUserLocked(id: string | null): Promise<UserLockedResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{id}/locked";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsUserLocked(_response);
        });
    }

    protected processIsUserLocked(response: Response): Promise<UserLockedResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserLockedResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserLockedResult>(<any>null);
    }

    /**
     * Lock user
     * @param id >User id
     * @return Success
     */
    lockUser(id: string | null): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{id}/lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLockUser(_response);
        });
    }

    protected processLockUser(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(<any>null);
    }

    /**
     * Unlock user
     * @param id >User id
     * @return Success
     */
    unlockUser(id: string | null): Promise<SecurityResult> {
        let url_ = this.baseUrl + "/api/platform/security/users/{id}/unlock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnlockUser(_response);
        });
    }

    protected processUnlockUser(response: Response): Promise<SecurityResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityResult>(<any>null);
    }

    /**
     * @return Success
     */
    getUserApiKeys(id: string | null): Promise<UserApiKey[]> {
        let url_ = this.baseUrl + "/api/platform/security/users/{id}/apikeys";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserApiKeys(_response);
        });
    }

    protected processGetUserApiKeys(response: Response): Promise<UserApiKey[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserApiKey.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserApiKey[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveUserApiKey(body: UserApiKey | undefined): Promise<UserApiKey[]> {
        let url_ = this.baseUrl + "/api/platform/security/users/apikeys";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveUserApiKey(_response);
        });
    }

    protected processSaveUserApiKey(response: Response): Promise<UserApiKey[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserApiKey.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserApiKey[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserApiKey(body: UserApiKey | undefined): Promise<UserApiKey[]> {
        let url_ = this.baseUrl + "/api/platform/security/users/apikeys";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUserApiKey(_response);
        });
    }

    protected processUpdateUserApiKey(response: Response): Promise<UserApiKey[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserApiKey.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserApiKey[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteUserApiKeys(ids: string[] | null | undefined): Promise<UserApiKey[]> {
        let url_ = this.baseUrl + "/api/platform/security/users/apikeys?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUserApiKeys(_response);
        });
    }

    protected processDeleteUserApiKeys(response: Response): Promise<UserApiKey[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserApiKey.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserApiKey[]>(<any>null);
    }

    /**
     * Verify user email
     * @return Success
     */
    sendVerificationEmail(userId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/security/users/{userId}/sendVerificationEmail";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendVerificationEmail(_response);
        });
    }

    protected processSendVerificationEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SettingClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get all settings
     * @return Success
     */
    getAllGlobalSettings(): Promise<ObjectSettingEntry> {
        let url_ = this.baseUrl + "/api/platform/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllGlobalSettings(_response);
        });
    }

    protected processGetAllGlobalSettings(response: Response): Promise<ObjectSettingEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectSettingEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectSettingEntry>(<any>null);
    }

    /**
     * Update settings values
     * @param body (optional) 
     * @return Success
     */
    update(body: ObjectSettingEntry[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/platform/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get settings registered by specific module
     * @param id Module ID.
     * @return Success
     */
    getGlobalModuleSettings(id: string | null): Promise<ObjectSettingEntry[]> {
        let url_ = this.baseUrl + "/api/platform/settings/modules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGlobalModuleSettings(_response);
        });
    }

    protected processGetGlobalModuleSettings(response: Response): Promise<ObjectSettingEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ObjectSettingEntry.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectSettingEntry[]>(<any>null);
    }

    /**
     * Get setting details by name
     * @param name Setting system name.
     * @return Success
     */
    getGlobalSetting(name: string | null): Promise<ObjectSettingEntry> {
        let url_ = this.baseUrl + "/api/platform/settings/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGlobalSetting(_response);
        });
    }

    protected processGetGlobalSetting(response: Response): Promise<ObjectSettingEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectSettingEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectSettingEntry>(<any>null);
    }

    /**
     * Get UI customization setting
     * @return Success
     */
    getUICustomizationSetting(): Promise<ObjectSettingEntry> {
        let url_ = this.baseUrl + "/api/platform/settings/ui/customization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUICustomizationSetting(_response);
        });
    }

    protected processGetUICustomizationSetting(response: Response): Promise<ObjectSettingEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ObjectSettingEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ObjectSettingEntry>(<any>null);
    }
}

export class BulkActionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Attempts to cancel running task.
     * @param jobId (optional) The job id.
     * @return Success
     */
    cancel(jobId: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/bulk/actions?";
        if (jobId !== undefined && jobId !== null)
            url_ += "jobId=" + encodeURIComponent("" + jobId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets the list of all registered actions.
     * @return Success
     */
    getRegisteredActions(): Promise<IBulkActionProvider[]> {
        let url_ = this.baseUrl + "/api/bulk/actions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegisteredActions(_response);
        });
    }

    protected processGetRegisteredActions(response: Response): Promise<IBulkActionProvider[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IBulkActionProvider.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IBulkActionProvider[]>(<any>null);
    }

    /**
     * Starts bulk action background job.
     * @param body (optional) Execution context.
     * @return Success
     */
    run(body: BulkActionContext | undefined): Promise<BulkActionPushNotification> {
        let url_ = this.baseUrl + "/api/bulk/actions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRun(_response);
        });
    }

    protected processRun(response: Response): Promise<BulkActionPushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BulkActionPushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BulkActionPushNotification>(<any>null);
    }

    /**
     * Gets action initialization data (could be used to initialize UI).
     * @param body (optional) Context for which we want initialization data.
     * @return Success
     */
    getActionData(body: BulkActionContext | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/bulk/actions/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetActionData(_response);
        });
    }

    protected processGetActionData(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CartModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCart(storeId: string | null, customerId: string | null, cartName: string | null, currency: string | null, cultureName: string | null): Promise<ShoppingCart> {
        let url_ = this.baseUrl + "/api/carts/{storeId}/{customerId}/{cartName}/{currency}/{cultureName}/current";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId));
        if (cartName === undefined || cartName === null)
            throw new Error("The parameter 'cartName' must be defined.");
        url_ = url_.replace("{cartName}", encodeURIComponent("" + cartName));
        if (currency === undefined || currency === null)
            throw new Error("The parameter 'currency' must be defined.");
        url_ = url_.replace("{currency}", encodeURIComponent("" + currency));
        if (cultureName === undefined || cultureName === null)
            throw new Error("The parameter 'cultureName' must be defined.");
        url_ = url_.replace("{cultureName}", encodeURIComponent("" + cultureName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCart(_response);
        });
    }

    protected processGetCart(response: Response): Promise<ShoppingCart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCart>(<any>null);
    }

    /**
     * @return Success
     */
    getCartItemsCount(cartId: string | null): Promise<number> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/itemscount";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCartItemsCount(_response);
        });
    }

    protected processGetCartItemsCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addItemToCart(cartId: string | null, body: CartLineItem | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/items";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddItemToCart(_response);
        });
    }

    protected processAddItemToCart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param lineItemId (optional) 
     * @param quantity (optional) 
     * @return Success
     */
    changeCartItem(cartId: string | null, lineItemId: string | null | undefined, quantity: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/items?";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        if (lineItemId !== undefined && lineItemId !== null)
            url_ += "lineItemId=" + encodeURIComponent("" + lineItemId) + "&";
        if (quantity === null)
            throw new Error("The parameter 'quantity' cannot be null.");
        else if (quantity !== undefined)
            url_ += "quantity=" + encodeURIComponent("" + quantity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeCartItem(_response);
        });
    }

    protected processChangeCartItem(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCart(cartId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/items";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClearCart(_response);
        });
    }

    protected processClearCart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    removeCartItem(cartId: string | null, lineItemId: string | null): Promise<number> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/items/{lineItemId}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        if (lineItemId === undefined || lineItemId === null)
            throw new Error("The parameter 'lineItemId' must be defined.");
        url_ = url_.replace("{lineItemId}", encodeURIComponent("" + lineItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveCartItem(_response);
        });
    }

    protected processRemoveCartItem(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    mergeWithCart(cartId: string | null, body: ShoppingCart | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMergeWithCart(_response);
        });
    }

    protected processMergeWithCart(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get shopping cart by id
     * @param cartId Shopping cart id
     * @return Success
     */
    getCartById(cartId: string | null): Promise<ShoppingCart> {
        let url_ = this.baseUrl + "/api/carts/{cartId}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCartById(_response);
        });
    }

    protected processGetCartById(response: Response): Promise<ShoppingCart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCart>(<any>null);
    }

    /**
     * @return Success
     */
    getAvailableShippingRates(cartId: string | null): Promise<ShippingRate[]> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/availshippingrates";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAvailableShippingRates(_response);
        });
    }

    protected processGetAvailableShippingRates(response: Response): Promise<ShippingRate[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShippingRate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingRate[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAvailableShippingRatesByContext(body: ShippingEvaluationContext | undefined): Promise<ShippingRate[]> {
        let url_ = this.baseUrl + "/api/carts/availshippingrates";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAvailableShippingRatesByContext(_response);
        });
    }

    protected processGetAvailableShippingRatesByContext(response: Response): Promise<ShippingRate[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShippingRate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingRate[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAvailablePaymentMethods(cartId: string | null): Promise<PaymentMethod[]> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/availpaymentmethods";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAvailablePaymentMethods(_response);
        });
    }

    protected processGetAvailablePaymentMethods(response: Response): Promise<PaymentMethod[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentMethod.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethod[]>(<any>null);
    }

    /**
     * @return Success
     */
    addCartCoupon(cartId: string | null, couponCode: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/coupons/{couponCode}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        if (couponCode === undefined || couponCode === null)
            throw new Error("The parameter 'couponCode' must be defined.");
        url_ = url_.replace("{couponCode}", encodeURIComponent("" + couponCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddCartCoupon(_response);
        });
    }

    protected processAddCartCoupon(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    removeCartCoupon(cartId: string | null, couponCode: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/coupons/{couponCode}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        if (couponCode === undefined || couponCode === null)
            throw new Error("The parameter 'couponCode' must be defined.");
        url_ = url_.replace("{couponCode}", encodeURIComponent("" + couponCode));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveCartCoupon(_response);
        });
    }

    protected processRemoveCartCoupon(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateCartShipment(cartId: string | null, body: CartShipment | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/shipments";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddOrUpdateCartShipment(_response);
        });
    }

    protected processAddOrUpdateCartShipment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addOrUpdateCartPayment(cartId: string | null, body: Payment | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts/{cartId}/payments";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddOrUpdateCartPayment(_response);
        });
    }

    protected processAddOrUpdateCartPayment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Search shopping carts by given criteria
     * @param body (optional) Shopping cart search criteria
     * @return Success
     */
    searchShoppingCart(body: ShoppingCartSearchCriteria | undefined): Promise<ShoppingCartSearchResult> {
        let url_ = this.baseUrl + "/api/carts/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchShoppingCart(_response);
        });
    }

    protected processSearchShoppingCart(response: Response): Promise<ShoppingCartSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCartSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCartSearchResult>(<any>null);
    }

    /**
     * Create shopping cart
     * @param body (optional) Shopping cart model
     * @return Success
     */
    create(body: ShoppingCart | undefined): Promise<ShoppingCart> {
        let url_ = this.baseUrl + "/api/carts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ShoppingCart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCart>(<any>null);
    }

    /**
     * Update shopping cart
     * @param body (optional) Shopping cart model
     * @return Success
     */
    updateShoppingCart(body: ShoppingCart | undefined): Promise<ShoppingCart> {
        let url_ = this.baseUrl + "/api/carts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateShoppingCart(_response);
        });
    }

    protected processUpdateShoppingCart(response: Response): Promise<ShoppingCart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCart>(<any>null);
    }

    /**
     * Delete shopping carts by ids
     * @param ids (optional) Array of shopping cart ids
     * @return Success
     */
    deleteCarts(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/carts?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCarts(_response);
        });
    }

    protected processDeleteCarts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Calculates totals for cart.
     * @param body (optional) Shopping cart model
     * @return Success
     */
    recalculateTotals(body: ShoppingCart | undefined): Promise<ShoppingCart> {
        let url_ = this.baseUrl + "/api/carts/recalculate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecalculateTotals(_response);
        });
    }

    protected processRecalculateTotals(response: Response): Promise<ShoppingCart> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShoppingCart>(<any>null);
    }
}

export class CatalogModuleAssociationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Returns list of associations for specified product
     * @param productId Owner product id
     * @return Success
     */
    getAllAssociations(productId: string | null): Promise<ProductAssociation[]> {
        let url_ = this.baseUrl + "/api/catalog/products/associations/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllAssociations(_response);
        });
    }

    protected processGetAllAssociations(response: Response): Promise<ProductAssociation[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductAssociation.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductAssociation[]>(<any>null);
    }

    /**
     * Updates the specified association
     * @param body (optional) The association
     * @return Success
     */
    updateAssociations(body: ProductAssociation[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products/associations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAssociations(_response);
        });
    }

    protected processUpdateAssociations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Deletes specified associations
     * @param ids (optional) associations to delete ids
     * @return Success
     */
    delete(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products/associations?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Returns associations by search criteria
     * @param body (optional) 
     * @return Success
     */
    search(body: ProductAssociationSearchCriteria | undefined): Promise<ProductAssociationSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/products/associations/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<ProductAssociationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductAssociationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductAssociationSearchResult>(<any>null);
    }
}

export class CatalogModuleCatalogsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCatalogs(body: CatalogSearchCriteria | undefined): Promise<CatalogSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchCatalogs(_response);
        });
    }

    protected processSearchCatalogs(response: Response): Promise<CatalogSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogSearchResult>(<any>null);
    }

    /**
     * Gets Catalog by id.
     * @param id The Catalog id.
     * @return Success
     */
    getCatalog(id: string | null): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCatalog(_response);
        });
    }

    protected processGetCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(<any>null);
    }

    /**
     * Deletes catalog by id.
     * @param id Catalog id.
     * @return Success
     */
    deleteCatalog(id: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCatalog(_response);
        });
    }

    protected processDeleteCatalog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets the template for a new catalog.
     * @return Success
     */
    getNewCatalog(): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/getnew";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewCatalog(_response);
        });
    }

    protected processGetNewCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(<any>null);
    }

    /**
     * Gets the template for a new virtual catalog.
     * @return Success
     */
    getNewVirtualCatalog(): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs/getnewvirtual";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewVirtualCatalog(_response);
        });
    }

    protected processGetNewVirtualCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(<any>null);
    }

    /**
     * Creates the specified catalog.
     * @param body (optional) The catalog to create
     * @return Success
     */
    createCatalog(body: Catalog | undefined): Promise<Catalog> {
        let url_ = this.baseUrl + "/api/catalog/catalogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCatalog(_response);
        });
    }

    protected processCreateCatalog(response: Response): Promise<Catalog> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Catalog.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Catalog>(<any>null);
    }

    /**
     * Updates the specified catalog.
     * @param body (optional) The catalog.
     * @return Success
     */
    updateCatalog(body: Catalog | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/catalogs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCatalog(_response);
        });
    }

    protected processUpdateCatalog(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CatalogModuleCategoriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets category by id.
     * @param id Category id.
     * @return Success
     */
    getCategory(id: string | null): Promise<Category> {
        let url_ = this.baseUrl + "/api/catalog/categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategory(_response);
        });
    }

    protected processGetCategory(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(<any>null);
    }

    /**
     * Gets categories by ids
     * @param ids (optional) Categories ids
     * @param respGroup (optional) Response group.
     * @return Success
     */
    getCategoriesByIds(ids: string[] | null | undefined, respGroup: string | null | undefined): Promise<Category[]> {
        let url_ = this.baseUrl + "/api/catalog/categories?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategoriesByIds(_response);
        });
    }

    protected processGetCategoriesByIds(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(<any>null);
    }

    /**
     * Creates or updates the specified category.
     * @param body (optional) The category.
     * @return Success
     */
    createOrUpdateCategory(body: Category | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrUpdateCategory(_response);
        });
    }

    protected processCreateOrUpdateCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Deletes the specified categories by id.
     * @param ids (optional) The categories ids.
     * @return Success
     */
    deleteCategory(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/categories?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get categories by plenty ids
     * @param respGroup (optional) Response group
     * @param body (optional) Categories ids
     * @return Success
     */
    getCategoriesByPlentyIds(respGroup: string | null | undefined, body: string[] | null | undefined): Promise<Category[]> {
        let url_ = this.baseUrl + "/api/catalog/categories/plenty?";
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategoriesByPlentyIds(_response);
        });
    }

    protected processGetCategoriesByPlentyIds(response: Response): Promise<Category[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category[]>(<any>null);
    }

    /**
     * Gets the template for a new category.
     * @param catalogId The catalog id.
     * @param parentCategoryId (optional) The parent category id. (Optional)
     * @return Success
     */
    getNewCategory(catalogId: string | null, parentCategoryId: string | null | undefined): Promise<Category> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/categories/newcategory?";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        if (parentCategoryId !== undefined && parentCategoryId !== null)
            url_ += "parentCategoryId=" + encodeURIComponent("" + parentCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewCategory(_response);
        });
    }

    protected processGetNewCategory(response: Response): Promise<Category> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Category.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Category>(<any>null);
    }
}

export class CatalogModuleIndexedSearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchProducts(body: ProductIndexedSearchCriteria | undefined): Promise<ProductIndexedSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/search/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchProducts(_response);
        });
    }

    protected processSearchProducts(response: Response): Promise<ProductIndexedSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductIndexedSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductIndexedSearchResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCategories(body: CategoryIndexedSearchCriteria | undefined): Promise<CategoryIndexedSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/search/categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchCategories(_response);
        });
    }

    protected processSearchCategories(response: Response): Promise<CategoryIndexedSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryIndexedSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryIndexedSearchResult>(<any>null);
    }
}

export class CatalogModuleListEntryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Searches for the items by complex criteria.
     * @param body (optional) The search criteria.
     * @return Success
     */
    listItemsSearch(body: CatalogListEntrySearchCriteria | undefined): Promise<ListEntrySearchResult> {
        let url_ = this.baseUrl + "/api/catalog/listentries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListItemsSearch(_response);
        });
    }

    protected processListItemsSearch(response: Response): Promise<ListEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListEntrySearchResult>(<any>null);
    }

    /**
     * Creates links for categories or items to parent categories and catalogs.
     * @param body (optional) The links.
     * @return Success
     */
    createLinks(body: CategoryLink[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLinks(_response);
        });
    }

    protected processCreateLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Bulk create links to categories and items
     * @param body (optional) 
     * @return Success
     */
    bulkCreateLinks(body: BulkLinkCreationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks/bulkcreate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkCreateLinks(_response);
        });
    }

    protected processBulkCreateLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Unlinks the linked categories or items from parent categories and catalogs.
     * @param body (optional) The links.
     * @return Success
     */
    deleteLinks(body: CategoryLink[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentrylinks/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteLinks(_response);
        });
    }

    protected processDeleteLinks(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Move categories or products to another location.
     * @param body (optional) Move operation request
     * @return Success
     */
    move(body: ListEntriesMoveRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentries/move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMove(_response);
        });
    }

    protected processMove(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Bulk delete by the search criteria.
     * @param body (optional) 
     * @return Success
     */
    delete(body: CatalogListEntrySearchCriteria | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/listentries/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CatalogModuleProductsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets product by id.
     * @param id Item id.
     * @param respGroup (optional) Response group.
     * @return Success
     */
    getProductById(id: string | null, respGroup: string | null | undefined): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductById(_response);
        });
    }

    protected processGetProductById(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(<any>null);
    }

    /**
     * Gets products by ids
     * @param ids (optional) Item ids
     * @param respGroup (optional) Response group.
     * @return Success
     */
    getProductByIds(ids: string[] | null | undefined, respGroup: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductByIds(_response);
        });
    }

    protected processGetProductByIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create/Update the specified product.
     * @param body (optional) The product.
     * @return Success
     */
    saveProduct(body: CatalogProduct | undefined): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveProduct(_response);
        });
    }

    protected processSaveProduct(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("Success", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(<any>null);
    }

    /**
     * Deletes the specified items by id.
     * @param ids (optional) The items ids.
     * @return Success
     */
    deleteProduct(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProduct(_response);
        });
    }

    protected processDeleteProduct(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets products by plenty ids
     * @param respGroup (optional) Response group.
     * @param body (optional) Item ids
     * @return Success
     */
    getProductByPlentyIds(respGroup: string | null | undefined, body: string[] | null | undefined): Promise<CatalogProduct[]> {
        let url_ = this.baseUrl + "/api/catalog/products/plenty?";
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductByPlentyIds(_response);
        });
    }

    protected processGetProductByPlentyIds(response: Response): Promise<CatalogProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CatalogProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct[]>(<any>null);
    }

    /**
     * Gets the template for a new product (outside of category).
     * @param catalogId The catalog id.
     * @return Success
     */
    getNewProductByCatalog(catalogId: string | null): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/products/getnew";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewProductByCatalog(_response);
        });
    }

    protected processGetNewProductByCatalog(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(<any>null);
    }

    /**
     * Gets the template for a new product (inside category).
     * @param catalogId The catalog id.
     * @param categoryId The category id.
     * @return Success
     */
    getNewProductByCatalogAndCategory(catalogId: string | null, categoryId: string | null): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/categories/{categoryId}/products/getnew";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewProductByCatalogAndCategory(_response);
        });
    }

    protected processGetNewProductByCatalogAndCategory(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(<any>null);
    }

    /**
     * Gets the template for a new variation.
     * @param productId The parent product id.
     * @return Success
     */
    getNewVariation(productId: string | null): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products/{productId}/getnewvariation";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewVariation(_response);
        });
    }

    protected processGetNewVariation(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(<any>null);
    }

    /**
     * @return Success
     */
    cloneProduct(productId: string | null): Promise<CatalogProduct> {
        let url_ = this.baseUrl + "/api/catalog/products/{productId}/clone";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCloneProduct(_response);
        });
    }

    protected processCloneProduct(response: Response): Promise<CatalogProduct> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogProduct.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogProduct>(<any>null);
    }

    /**
     * Create/Update the specified products.
     * @param body (optional) The products.
     * @return Success
     */
    saveProducts(body: CatalogProduct[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/products/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveProducts(_response);
        });
    }

    protected processSaveProducts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CatalogModulePropertiesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets property metainformation by id.
     * @param propertyId The property id.
     * @return Success
     */
    getProperty(propertyId: string | null): Promise<Property> {
        let url_ = this.baseUrl + "/api/catalog/properties/{propertyId}";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProperty(_response);
        });
    }

    protected processGetProperty(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(<any>null);
    }

    /**
     * Gets the template for a new catalog property.
     * @param catalogId The catalog id.
     * @return Success
     */
    getNewCatalogProperty(catalogId: string | null): Promise<Property> {
        let url_ = this.baseUrl + "/api/catalog/{catalogId}/properties/getnew";
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewCatalogProperty(_response);
        });
    }

    protected processGetNewCatalogProperty(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(<any>null);
    }

    /**
     * Gets the template for a new category property.
     * @param categoryId The category id.
     * @return Success
     */
    getNewCategoryProperty(categoryId: string | null): Promise<Property> {
        let url_ = this.baseUrl + "/api/catalog/categories/{categoryId}/properties/getnew";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewCategoryProperty(_response);
        });
    }

    protected processGetNewCategoryProperty(response: Response): Promise<Property> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Property.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Property>(<any>null);
    }

    /**
     * Creates or updates the specified property.
     * @param body (optional) The property.
     * @return Success
     */
    saveProperty(body: Property | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/properties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveProperty(_response);
        });
    }

    protected processSaveProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Deletes property by id.
     * @param id (optional) The property id.
     * @param doDeleteValues (optional) Flag indicating to remove property values from objects as well
     * @return Success
     */
    deleteProperty(id: string | null | undefined, doDeleteValues: boolean | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/properties?";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (doDeleteValues === null)
            throw new Error("The parameter 'doDeleteValues' cannot be null.");
        else if (doDeleteValues !== undefined)
            url_ += "doDeleteValues=" + encodeURIComponent("" + doDeleteValues) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProperty(_response);
        });
    }

    protected processDeleteProperty(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CatalogModulePropertyDictionaryItemsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search property dictionary items
     * @param body (optional) The search criteria
     * @return Success
     */
    searchPropertyDictionaryItems(body: PropertyDictionaryItemSearchCriteria | undefined): Promise<PropertyDictionaryItemSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/dictionaryitems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchPropertyDictionaryItems(_response);
        });
    }

    protected processSearchPropertyDictionaryItems(response: Response): Promise<PropertyDictionaryItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertyDictionaryItemSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PropertyDictionaryItemSearchResult>(<any>null);
    }

    /**
     * Creates or updates the specified property dictionary items
     * @param body (optional) 
     * @return Success
     */
    saveChanges(body: PropertyDictionaryItem[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/dictionaryitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveChanges(_response);
        });
    }

    protected processSaveChanges(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete property dictionary items by ids
     * @param ids (optional) The identifiers of objects that needed to be deleted
     * @return Success
     */
    deletePropertyDictionaryItems(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/catalog/dictionaryitems?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePropertyDictionaryItems(_response);
        });
    }

    protected processDeletePropertyDictionaryItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ExportImportClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Start catalog data export process.
     * @param body (optional) The export configuration.
     * @return Success
     */
    doExport(body: CsvExportInfo | undefined): Promise<ExportNotification> {
        let url_ = this.baseUrl + "/api/catalogcsvimport/export";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDoExport(_response);
        });
    }

    protected processDoExport(response: Response): Promise<ExportNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExportNotification>(<any>null);
    }

    /**
     * Gets the CSV mapping configuration.
     * @param fileUrl (optional) The file URL.
     * @param delimiter (optional) The CSV delimiter.
     * @return Success
     */
    getMappingConfiguration(fileUrl: string | null | undefined, delimiter: string | null | undefined): Promise<CsvProductMappingConfiguration> {
        let url_ = this.baseUrl + "/api/catalogcsvimport/import/mappingconfiguration?";
        if (fileUrl !== undefined && fileUrl !== null)
            url_ += "fileUrl=" + encodeURIComponent("" + fileUrl) + "&";
        if (delimiter !== undefined && delimiter !== null)
            url_ += "delimiter=" + encodeURIComponent("" + delimiter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMappingConfiguration(_response);
        });
    }

    protected processGetMappingConfiguration(response: Response): Promise<CsvProductMappingConfiguration> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CsvProductMappingConfiguration.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CsvProductMappingConfiguration>(<any>null);
    }

    /**
     * Start catalog data import process.
     * @param body (optional) The import data configuration.
     * @return Success
     */
    doImport(body: CsvImportInfo | undefined): Promise<CatalogCsvImportNotification> {
        let url_ = this.baseUrl + "/api/catalogcsvimport/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDoImport(_response);
        });
    }

    protected processDoImport(response: Response): Promise<CatalogCsvImportNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CatalogCsvImportNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CatalogCsvImportNotification>(<any>null);
    }
}

export class ContentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getStoreContentStats(storeId: string | null): Promise<ContentStatistic> {
        let url_ = this.baseUrl + "/api/content/{storeId}/stats";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStoreContentStats(_response);
        });
    }

    protected processGetStoreContentStats(response: Response): Promise<ContentStatistic> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContentStatistic.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentStatistic>(<any>null);
    }

    /**
     * @param urls (optional) 
     * @return Success
     */
    deleteContent(contentType: string | null, storeId: string | null, urls: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (urls !== undefined && urls !== null)
            urls && urls.forEach(item => { url_ += "urls=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContent(_response);
        });
    }

    protected processDeleteContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param relativeUrl (optional) 
     * @return Success
     */
    getContentItemDataStream(contentType: string | null, storeId: string | null, relativeUrl: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (relativeUrl !== undefined && relativeUrl !== null)
            url_ += "relativeUrl=" + encodeURIComponent("" + relativeUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContentItemDataStream(_response);
        });
    }

    protected processGetContentItemDataStream(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @param folderUrl (optional) 
     * @param url (optional) 
     * @return Success
     */
    uploadContent(contentType: string | null, storeId: string | null, folderUrl: string | null | undefined, url: string | null | undefined): Promise<ContentItem[]> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (folderUrl !== undefined && folderUrl !== null)
            url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
        if (url !== undefined && url !== null)
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadContent(_response);
        });
    }

    protected processUploadContent(response: Response): Promise<ContentItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentItem[]>(<any>null);
    }

    /**
     * @param folderUrl (optional) 
     * @param keyword (optional) 
     * @return Success
     */
    searchContent(contentType: string | null, storeId: string | null, folderUrl: string | null | undefined, keyword: string | null | undefined): Promise<ContentItem[]> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/search?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (folderUrl !== undefined && folderUrl !== null)
            url_ += "folderUrl=" + encodeURIComponent("" + folderUrl) + "&";
        if (keyword !== undefined && keyword !== null)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchContent(_response);
        });
    }

    protected processSearchContent(response: Response): Promise<ContentItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContentItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContentItem[]>(<any>null);
    }

    /**
     * @param oldUrl (optional) 
     * @param newUrl (optional) 
     * @return Success
     */
    moveContent(contentType: string | null, storeId: string | null, oldUrl: string | null | undefined, newUrl: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/move?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (oldUrl !== undefined && oldUrl !== null)
            url_ += "oldUrl=" + encodeURIComponent("" + oldUrl) + "&";
        if (newUrl !== undefined && newUrl !== null)
            url_ += "newUrl=" + encodeURIComponent("" + newUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveContent(_response);
        });
    }

    protected processMoveContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param srcPath (optional) 
     * @param destPath (optional) 
     * @return Success
     */
    copyContent(srcPath: string | null | undefined, destPath: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/copy?";
        if (srcPath !== undefined && srcPath !== null)
            url_ += "srcPath=" + encodeURIComponent("" + srcPath) + "&";
        if (destPath !== undefined && destPath !== null)
            url_ += "destPath=" + encodeURIComponent("" + destPath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCopyContent(_response);
        });
    }

    protected processCopyContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param archivePath (optional) 
     * @param destPath (optional) 
     * @return Success
     */
    unpack(contentType: string | null, storeId: string | null, archivePath: string | null | undefined, destPath: string | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/unpack?";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (archivePath !== undefined && archivePath !== null)
            url_ += "archivePath=" + encodeURIComponent("" + archivePath) + "&";
        if (destPath !== undefined && destPath !== null)
            url_ += "destPath=" + encodeURIComponent("" + destPath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnpack(_response);
        });
    }

    protected processUnpack(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContentFolder(contentType: string | null, storeId: string | null, body: ContentFolder | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/content/{contentType}/{storeId}/folder";
        if (contentType === undefined || contentType === null)
            throw new Error("The parameter 'contentType' must be defined.");
        url_ = url_.replace("{contentType}", encodeURIComponent("" + contentType));
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContentFolder(_response);
        });
    }

    protected processCreateContentFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class MenuClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLists(storeId: string | null): Promise<MenuLinkList[]> {
        let url_ = this.baseUrl + "/api/cms/{storeId}/menu";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLists(_response);
        });
    }

    protected processGetLists(response: Response): Promise<MenuLinkList[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MenuLinkList.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MenuLinkList[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMenuLinkList(storeId: string, body: MenuLinkList | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cms/{storeId}/menu";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMenuLinkList(_response);
        });
    }

    protected processUpdateMenuLinkList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param listIds (optional) 
     * @return Success
     */
    deleteMenuLinkLists(listIds: string[] | null | undefined, storeId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/cms/{storeId}/menu?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (listIds !== undefined && listIds !== null)
            listIds && listIds.forEach(item => { url_ += "listIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMenuLinkLists(_response);
        });
    }

    protected processDeleteMenuLinkLists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getList(storeId: string | null, listId: string | null): Promise<MenuLinkList> {
        let url_ = this.baseUrl + "/api/cms/{storeId}/menu/{listId}";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (listId === undefined || listId === null)
            throw new Error("The parameter 'listId' must be defined.");
        url_ = url_.replace("{listId}", encodeURIComponent("" + listId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetList(_response);
        });
    }

    protected processGetList(response: Response): Promise<MenuLinkList> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MenuLinkList.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MenuLinkList>(<any>null);
    }

    /**
     * @param name (optional) 
     * @param language (optional) 
     * @param id (optional) 
     * @return Success
     */
    checkName(storeId: string | null, name: string | null | undefined, language: string | null | undefined, id: string | null | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/cms/{storeId}/menu/checkname?";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (language !== undefined && language !== null)
            url_ += "language=" + encodeURIComponent("" + language) + "&";
        if (id !== undefined && id !== null)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckName(_response);
        });
    }

    protected processCheckName(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class CommerceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Batch create or update seo infos
     * @param body (optional) 
     * @return Success
     */
    batchUpdateSeoInfos(body: SeoInfo[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/seoinfos/batchupdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBatchUpdateSeoInfos(_response);
        });
    }

    protected processBatchUpdateSeoInfos(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param objectId (optional) 
     * @param objectType (optional) 
     * @return Success
     */
    getSeoDuplicates(objectId: string | null | undefined, objectType: string | null | undefined): Promise<SeoInfo[]> {
        let url_ = this.baseUrl + "/api/seoinfos/duplicates?";
        if (objectId !== undefined && objectId !== null)
            url_ += "objectId=" + encodeURIComponent("" + objectId) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "objectType=" + encodeURIComponent("" + objectType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSeoDuplicates(_response);
        });
    }

    protected processGetSeoDuplicates(response: Response): Promise<SeoInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SeoInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeoInfo[]>(<any>null);
    }

    /**
     * Find all SEO records for object by slug
     * @param slug slug
     * @return Success
     */
    getSeoInfoBySlug(slug: string | null): Promise<SeoInfo[]> {
        let url_ = this.baseUrl + "/api/seoinfos/{slug}";
        if (slug === undefined || slug === null)
            throw new Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSeoInfoBySlug(_response);
        });
    }

    protected processGetSeoInfoBySlug(response: Response): Promise<SeoInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SeoInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SeoInfo[]>(<any>null);
    }

    /**
     * Return all currencies registered in the system
     * @return Success
     */
    getAllCurrencies(): Promise<Currency[]> {
        let url_ = this.baseUrl + "/api/currencies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCurrencies(_response);
        });
    }

    protected processGetAllCurrencies(response: Response): Promise<Currency[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Currency.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Currency[]>(<any>null);
    }

    /**
     * Create a existing currency
     * @param body (optional) currency
     * @return Success
     */
    createCurrency(body: Currency | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/currencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCurrency(_response);
        });
    }

    protected processCreateCurrency(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Update a existing currency
     * @param body (optional) currency
     * @return Success
     */
    updateCurrency(body: Currency | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/currencies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCurrency(_response);
        });
    }

    protected processUpdateCurrency(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete currencies
     * @param codes (optional) currency codes
     * @return Success
     */
    deleteCurrencies(codes: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/currencies?";
        if (codes !== undefined && codes !== null)
            codes && codes.forEach(item => { url_ += "codes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCurrencies(_response);
        });
    }

    protected processDeleteCurrencies(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Return all package types registered in the system
     * @return Success
     */
    getAllPackageTypes(): Promise<PackageType[]> {
        let url_ = this.baseUrl + "/api/packageTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllPackageTypes(_response);
        });
    }

    protected processGetAllPackageTypes(response: Response): Promise<PackageType[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PackageType.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PackageType[]>(<any>null);
    }

    /**
     * Update a existing package type
     * @param body (optional) package type
     * @return Success
     */
    updatePackageType(body: PackageType | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/packageTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePackageType(_response);
        });
    }

    protected processUpdatePackageType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create new package type
     * @param body (optional) package type
     * @return Success
     */
    createPackageType(body: PackageType | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/packageTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePackageType(_response);
        });
    }

    protected processCreatePackageType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete package types
     * @param ids (optional) package type ids
     * @return Success
     */
    deletePackageTypes(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/packageTypes?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePackageTypes(_response);
        });
    }

    protected processDeletePackageTypes(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Validate address (reserved for future) and also required for expose Address in OpenAPI swagger docs
     * @param body (optional) 
     * @return Success
     */
    validateAddress(body: Address | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processValidateAddress(_response);
        });
    }

    protected processValidateAddress(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class CustomerModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get organizations
     * @return Success
     */
    listOrganizations(): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/members/organizations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListOrganizations(_response);
        });
    }

    protected processListOrganizations(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(<any>null);
    }

    /**
     * Get members
     * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
     * @return Success
     */
    searchMember(body: MembersSearchCriteria | undefined): Promise<MemberSearchResult> {
        let url_ = this.baseUrl + "/api/members/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchMember(_response);
        });
    }

    protected processSearchMember(response: Response): Promise<MemberSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MemberSearchResult>(<any>null);
    }

    /**
     * Get member
     * @param id member id
     * @param responseGroup (optional) response group
     * @param memberType (optional) member type
     * @return Success
     */
    getMemberById(id: string | null, responseGroup: string | null | undefined, memberType: string | null | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/api/members/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "responseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (memberType !== undefined && memberType !== null)
            url_ += "memberType=" + encodeURIComponent("" + memberType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMemberById(_response);
        });
    }

    protected processGetMemberById(response: Response): Promise<Member> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Member.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @param responseGroup (optional) 
     * @param memberTypes (optional) 
     * @return Success
     */
    getMembersByIds(ids: string[] | null | undefined, responseGroup: string | null | undefined, memberTypes: string[] | null | undefined): Promise<Member[]> {
        let url_ = this.baseUrl + "/api/members?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "responseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (memberTypes !== undefined && memberTypes !== null)
            memberTypes && memberTypes.forEach(item => { url_ += "memberTypes=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMembersByIds(_response);
        });
    }

    protected processGetMembersByIds(response: Response): Promise<Member[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Member.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member[]>(<any>null);
    }

    /**
     * Create new member (can be any object inherited from Member type)
     * @param body (optional) concrete instance of abstract member type will be created by using PolymorphicMemberJsonConverter
     * @return Success
     */
    createMember(body: Member | undefined): Promise<Member> {
        let url_ = this.baseUrl + "/api/members";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMember(_response);
        });
    }

    protected processCreateMember(response: Response): Promise<Member> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Member.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member>(<any>null);
    }

    /**
     * Update member
     * @param body (optional) concrete instance of abstract member type will be created by using PolymorphicMemberJsonConverter
     * @return Success
     */
    updateMember(body: Member | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateMember(_response);
        });
    }

    protected processUpdateMember(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete members
     * @param ids (optional) An array of members ids
     * @return Success
     */
    deleteMembers(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMembers(_response);
        });
    }

    protected processDeleteMembers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Bulk create new members (can be any objects inherited from Member type)
     * @param body (optional) Array of concrete instances of abstract member type will be created by using PolymorphicMemberJsonConverter
     * @return Success
     */
    bulkCreateMembers(body: Member[] | null | undefined): Promise<Member[]> {
        let url_ = this.baseUrl + "/api/members/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkCreateMembers(_response);
        });
    }

    protected processBulkCreateMembers(response: Response): Promise<Member[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Member.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Member[]>(<any>null);
    }

    /**
     * Bulk update members
     * @param body (optional) Array of concrete instances of abstract member type will be created by using PolymorphicMemberJsonConverter
     * @return Success
     */
    bulkUpdateMembers(body: Member[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkUpdateMembers(_response);
        });
    }

    protected processBulkUpdateMembers(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Bulk delete members
     * @param body (optional) concrete instance of SearchCriteria type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
     * @return Success
     */
    bulkDeleteMembersBySearchCriteria(body: MembersSearchCriteria | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/members/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkDeleteMembersBySearchCriteria(_response);
        });
    }

    protected processBulkDeleteMembersBySearchCriteria(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create contact
     * @param body (optional) 
     * @return Success
     */
    createContact(body: Contact | undefined): Promise<Contact> {
        let url_ = this.baseUrl + "/api/contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContact(_response);
        });
    }

    protected processCreateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * Update contact
     * @param body (optional) 
     * @return Success
     */
    updateContact(body: Contact | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContact(_response);
        });
    }

    protected processUpdateContact(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete contacts
     * @param ids (optional) An array of contacts ids
     * @return Success
     */
    deleteContacts(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/contacts?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContacts(_response);
        });
    }

    protected processDeleteContacts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get plenty contacts
     * @param ids (optional) contact IDs
     * @return Success
     */
    getContactsByIds(ids: string[] | null | undefined): Promise<Contact[]> {
        let url_ = this.baseUrl + "/api/contacts?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactsByIds(_response);
        });
    }

    protected processGetContactsByIds(response: Response): Promise<Contact[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Contact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact[]>(<any>null);
    }

    /**
     * Bulk create contacts
     * @param body (optional) 
     * @return Success
     */
    bulkCreateContacts(body: Contact[] | null | undefined): Promise<Contact[]> {
        let url_ = this.baseUrl + "/api/contacts/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkCreateContacts(_response);
        });
    }

    protected processBulkCreateContacts(response: Response): Promise<Contact[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Contact.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact[]>(<any>null);
    }

    /**
     * Bulk update contact
     * @param body (optional) 
     * @return Success
     */
    bulkUpdateContacts(body: Contact[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/contacts/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkUpdateContacts(_response);
        });
    }

    protected processBulkUpdateContacts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create organization
     * @param body (optional) 
     * @return Success
     */
    createOrganization(body: Organization | undefined): Promise<Organization> {
        let url_ = this.baseUrl + "/api/organizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrganization(_response);
        });
    }

    protected processCreateOrganization(response: Response): Promise<Organization> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization>(<any>null);
    }

    /**
     * Update organization
     * @param body (optional) 
     * @return Success
     */
    updateOrganization(body: Organization | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateOrganization(_response);
        });
    }

    protected processUpdateOrganization(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete organizations
     * @param ids (optional) An array of organizations ids
     * @return Success
     */
    deleteOrganizations(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOrganizations(_response);
        });
    }

    protected processDeleteOrganizations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get plenty organizations
     * @param ids (optional) Organization ids
     * @return Success
     */
    getOrganizationsByIds(ids: string[] | null | undefined): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/organizations?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrganizationsByIds(_response);
        });
    }

    protected processGetOrganizationsByIds(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(<any>null);
    }

    /**
     * Bulk create organizations
     * @param body (optional) 
     * @return Success
     */
    bulkCreateOrganizations(body: Organization[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkCreateOrganizations(_response);
        });
    }

    protected processBulkCreateOrganizations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Bulk update organization
     * @param body (optional) 
     * @return Success
     */
    bulkUpdateOrganizations(body: Organization[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/organizations/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkUpdateOrganizations(_response);
        });
    }

    protected processBulkUpdateOrganizations(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get organization
     * @param id Organization id
     * @return Success
     */
    getOrganizationById(id: string | null): Promise<Organization> {
        let url_ = this.baseUrl + "/api/organizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrganizationById(_response);
        });
    }

    protected processGetOrganizationById(response: Response): Promise<Organization> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Organization.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization>(<any>null);
    }

    /**
     * Search organizations
     * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
     * @return Success
     */
    searchOrganizations(body: MembersSearchCriteria | undefined): Promise<OrganizationSearchResult> {
        let url_ = this.baseUrl + "/api/organizations/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchOrganizations(_response);
        });
    }

    protected processSearchOrganizations(response: Response): Promise<OrganizationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrganizationSearchResult>(<any>null);
    }

    /**
     * Get contact
     * @param id Contact ID
     * @return Success
     */
    getContactById(id: string | null): Promise<Contact> {
        let url_ = this.baseUrl + "/api/contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactById(_response);
        });
    }

    protected processGetContactById(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * Search contacts
     * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
     * @return Success
     */
    searchContacts(body: MembersSearchCriteria | undefined): Promise<ContactSearchResult> {
        let url_ = this.baseUrl + "/api/contacts/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchContacts(_response);
        });
    }

    protected processSearchContacts(response: Response): Promise<ContactSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactSearchResult>(<any>null);
    }

    /**
     * Get vendor
     * @param id Vendor ID
     * @return Success
     */
    getVendorById(id: string | null): Promise<Vendor> {
        let url_ = this.baseUrl + "/api/vendors/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVendorById(_response);
        });
    }

    protected processGetVendorById(response: Response): Promise<Vendor> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Vendor.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vendor>(<any>null);
    }

    /**
     * Get plenty vendors
     * @param ids (optional) Vendors IDs
     * @return Success
     */
    getVendorsByIds(ids: string[] | null | undefined): Promise<Vendor[]> {
        let url_ = this.baseUrl + "/api/vendors?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVendorsByIds(_response);
        });
    }

    protected processGetVendorsByIds(response: Response): Promise<Vendor[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Vendor.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Vendor[]>(<any>null);
    }

    /**
     * Search vendors
     * @param body (optional) concrete instance of SearchCriteria type type will be created by using PolymorphicMemberSearchCriteriaJsonConverter
     * @return Success
     */
    searchVendors(body: MembersSearchCriteria | undefined): Promise<VendorSearchResult> {
        let url_ = this.baseUrl + "/api/vendors/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchVendors(_response);
        });
    }

    protected processSearchVendors(response: Response): Promise<VendorSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VendorSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VendorSearchResult>(<any>null);
    }

    /**
     * @param memberId (optional) 
     * @param body (optional) 
     * @return Success
     */
    updateAddesses(memberId: string | null | undefined, body: CustomerAddress[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/addresses?";
        if (memberId !== undefined && memberId !== null)
            url_ += "memberId=" + encodeURIComponent("" + memberId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAddesses(_response);
        });
    }

    protected processUpdateAddesses(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Create employee
     * @param body (optional) 
     * @return Success
     */
    createEmployee(body: Employee | undefined): Promise<Employee> {
        let url_ = this.baseUrl + "/api/employees";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEmployee(_response);
        });
    }

    protected processCreateEmployee(response: Response): Promise<Employee> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Employee.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Employee>(<any>null);
    }

    /**
     * Get plenty employees
     * @param ids (optional) contact IDs
     * @return Success
     */
    getEmployeesByIds(ids: string[] | null | undefined): Promise<Employee[]> {
        let url_ = this.baseUrl + "/api/employees?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEmployeesByIds(_response);
        });
    }

    protected processGetEmployeesByIds(response: Response): Promise<Employee[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Employee.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Employee[]>(<any>null);
    }

    /**
     * Create employee
     * @param body (optional) 
     * @return Success
     */
    bulkCreateEmployees(body: Employee[] | null | undefined): Promise<Employee[]> {
        let url_ = this.baseUrl + "/api/employees/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBulkCreateEmployees(_response);
        });
    }

    protected processBulkCreateEmployees(response: Response): Promise<Employee[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Employee.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Employee[]>(<any>null);
    }

    /**
     * Get all member organizations
     * @param idQuery (optional) member Id
     * @return Success
     */
    getMemberOrganizations(idQuery: string | null | undefined, idPath: string): Promise<Organization[]> {
        let url_ = this.baseUrl + "/api/members/{id}/organizations?";
        if (idPath === undefined || idPath === null)
            throw new Error("The parameter 'idPath' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + idPath));
        if (idQuery !== undefined && idQuery !== null)
            url_ += "id=" + encodeURIComponent("" + idQuery) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMemberOrganizations(_response);
        });
    }

    protected processGetMemberOrganizations(response: Response): Promise<Organization[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Organization.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Organization[]>(<any>null);
    }
}

export class ExportClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Gets the list of types ready to be exported
     * @return Success
     */
    getExportedKnownTypes(): Promise<ExportedTypeDefinition[]> {
        let url_ = this.baseUrl + "/api/export/knowntypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExportedKnownTypes(_response);
        });
    }

    protected processGetExportedKnownTypes(response: Response): Promise<ExportedTypeDefinition[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExportedTypeDefinition.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExportedTypeDefinition[]>(<any>null);
    }

    /**
     * Gets the list of available export providers
     * @return Success
     */
    getExportProviders(): Promise<IExportProvider[]> {
        let url_ = this.baseUrl + "/api/export/providers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExportProviders(_response);
        });
    }

    protected processGetExportProviders(response: Response): Promise<IExportProvider[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IExportProvider.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IExportProvider[]>(<any>null);
    }

    /**
     * Provides generic viewable entities collection based on the request
     * @param body (optional) Data request
     * @return Success
     */
    getData(body: ExportDataRequest | undefined): Promise<ExportableSearchResult> {
        let url_ = this.baseUrl + "/api/export/data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetData(_response);
        });
    }

    protected processGetData(response: Response): Promise<ExportableSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportableSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExportableSearchResult>(<any>null);
    }

    /**
     * Starts export task
     * @param body (optional) Export task description
     * @return Success
     */
    runExport(body: ExportDataRequest | undefined): Promise<PlatformExportPushNotification> {
        let url_ = this.baseUrl + "/api/export/run";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRunExport(_response);
        });
    }

    protected processRunExport(response: Response): Promise<PlatformExportPushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlatformExportPushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PlatformExportPushNotification>(<any>null);
    }

    /**
     * Attempts to cancel export task
     * @param body (optional) Cancellation request with task id
     * @return Success
     */
    cancelExport(body: ExportCancellationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/export/task/cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelExport(_response);
        });
    }

    protected processCancelExport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Downloads file by its name
     * @return Success
     */
    downloadExportFile(fileName: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/export/download/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadExportFile(_response);
        });
    }

    protected processDownloadExportFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ThumbnailsOptionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createThumbnailOption(body: ThumbnailOption | undefined): Promise<ThumbnailOption> {
        let url_ = this.baseUrl + "/api/image/thumbnails/options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateThumbnailOption(_response);
        });
    }

    protected processCreateThumbnailOption(response: Response): Promise<ThumbnailOption> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailOption.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailOption>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteThumbnailOption(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/image/thumbnails/options?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteThumbnailOption(_response);
        });
    }

    protected processDeleteThumbnailOption(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateThumbnailOption(body: ThumbnailOption | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/image/thumbnails/options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateThumbnailOption(_response);
        });
    }

    protected processUpdateThumbnailOption(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getThumbnailOption(id: string | null): Promise<ThumbnailOption> {
        let url_ = this.baseUrl + "/api/image/thumbnails/options/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetThumbnailOption(_response);
        });
    }

    protected processGetThumbnailOption(response: Response): Promise<ThumbnailOption> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailOption.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailOption>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchThumbnailOption(body: ThumbnailOptionSearchCriteria | undefined): Promise<ThumbnailOptionSearchResult> {
        let url_ = this.baseUrl + "/api/image/thumbnails/options/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchThumbnailOption(_response);
        });
    }

    protected processSearchThumbnailOption(response: Response): Promise<ThumbnailOptionSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailOptionSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailOptionSearchResult>(<any>null);
    }
}

export class ThumbnailsTasksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createThumbnailTask(body: ThumbnailTask | undefined): Promise<ThumbnailTask> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateThumbnailTask(_response);
        });
    }

    protected processCreateThumbnailTask(response: Response): Promise<ThumbnailTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailTask.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailTask>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteThumbnailTask(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteThumbnailTask(_response);
        });
    }

    protected processDeleteThumbnailTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateThumbnailTask(body: ThumbnailTask | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateThumbnailTask(_response);
        });
    }

    protected processUpdateThumbnailTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Success
     */
    getThumbnailTask(id: string | null): Promise<ThumbnailTask> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetThumbnailTask(_response);
        });
    }

    protected processGetThumbnailTask(response: Response): Promise<ThumbnailTask> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailTask.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailTask>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchThumbnailTask(body: ThumbnailTaskSearchCriteria | undefined): Promise<ThumbnailTaskSearchResult> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchThumbnailTask(_response);
        });
    }

    protected processSearchThumbnailTask(response: Response): Promise<ThumbnailTaskSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailTaskSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailTaskSearchResult>(<any>null);
    }

    /**
     * @return Success
     */
    cancel(jobId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks/{jobId}/cancel";
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    run(body: ThumbnailsTaskRunRequest | undefined): Promise<ThumbnailProcessNotification> {
        let url_ = this.baseUrl + "/api/image/thumbnails/tasks/run";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRun(_response);
        });
    }

    protected processRun(response: Response): Promise<ThumbnailProcessNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThumbnailProcessNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ThumbnailProcessNotification>(<any>null);
    }
}

export class InventoryModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search inventories by given criteria
     * @param body (optional) 
     * @return Success
     */
    searchInventories(body: InventorySearchCriteria | undefined): Promise<InventoryInfoSearchResult> {
        let url_ = this.baseUrl + "/api/inventories/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchInventories(_response);
        });
    }

    protected processSearchInventories(response: Response): Promise<InventoryInfoSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryInfoSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfoSearchResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchInventory(body: InventorySearchCriteria | undefined): Promise<InventoryInfoSearchResult> {
        let url_ = this.baseUrl + "/api/inventory/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchInventory(_response);
        });
    }

    protected processSearchInventory(response: Response): Promise<InventoryInfoSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryInfoSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfoSearchResult>(<any>null);
    }

    /**
     * Search inventories by given criteria
     * @param body (optional) 
     * @return Success
     */
    searchProductInventories(body: ProductInventorySearchCriteria | undefined): Promise<InventoryInfoSearchResult> {
        let url_ = this.baseUrl + "/api/inventory/product/inventories/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchProductInventories(_response);
        });
    }

    protected processSearchProductInventories(response: Response): Promise<InventoryInfoSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryInfoSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfoSearchResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchProductInventory(body: ProductInventorySearchCriteria | undefined): Promise<InventoryInfoSearchResult> {
        let url_ = this.baseUrl + "/api/inventory/product/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchProductInventory(_response);
        });
    }

    protected processSearchProductInventory(response: Response): Promise<InventoryInfoSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryInfoSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfoSearchResult>(<any>null);
    }

    /**
     * Search fulfillment centers registered in the system
     * @param body (optional) 
     * @return Success
     */
    searchFulfillmentCenters(body: FulfillmentCenterSearchCriteria | undefined): Promise<FulfillmentCenterSearchResult> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchFulfillmentCenters(_response);
        });
    }

    protected processSearchFulfillmentCenters(response: Response): Promise<FulfillmentCenterSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FulfillmentCenterSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FulfillmentCenterSearchResult>(<any>null);
    }

    /**
     * Get fulfillment center by id
     * @param id fulfillment center id
     * @return Success
     */
    getFulfillmentCenter(id: string | null): Promise<FulfillmentCenter> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFulfillmentCenter(_response);
        });
    }

    protected processGetFulfillmentCenter(response: Response): Promise<FulfillmentCenter> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FulfillmentCenter.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FulfillmentCenter>(<any>null);
    }

    /**
     * Get fulfillment centers by ids
     * @param body (optional) fulfillment center ids
     * @return Success
     */
    getFulfillmentCenters(body: string[] | null | undefined): Promise<FulfillmentCenter[]> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/plenty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFulfillmentCenters(_response);
        });
    }

    protected processGetFulfillmentCenters(response: Response): Promise<FulfillmentCenter[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FulfillmentCenter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FulfillmentCenter[]>(<any>null);
    }

    /**
     * Save fulfillment center
     * @param body (optional) fulfillment center
     * @return Success
     */
    saveFulfillmentCenter(body: FulfillmentCenter | undefined): Promise<FulfillmentCenter> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveFulfillmentCenter(_response);
        });
    }

    protected processSaveFulfillmentCenter(response: Response): Promise<FulfillmentCenter> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FulfillmentCenter.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FulfillmentCenter>(<any>null);
    }

    /**
     * Delete fulfillment centers registered in the system
     * @param ids (optional) 
     * @return Success
     */
    deleteInventoryFulfillmentCenters(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteInventoryFulfillmentCenters(_response);
        });
    }

    protected processDeleteInventoryFulfillmentCenters(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Save fulfillment centers
     * @param body (optional) fulfillment centers
     * @return Success
     */
    saveFulfillmentCenters(body: FulfillmentCenter[] | null | undefined): Promise<FulfillmentCenter[]> {
        let url_ = this.baseUrl + "/api/inventory/fulfillmentcenters/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSaveFulfillmentCenters(_response);
        });
    }

    protected processSaveFulfillmentCenters(response: Response): Promise<FulfillmentCenter[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FulfillmentCenter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FulfillmentCenter[]>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteFulfillmentCenters(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/fulfillment/centers?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFulfillmentCenters(_response);
        });
    }

    protected processDeleteFulfillmentCenters(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get inventories of products
     * @param ids (optional) Products ids
     * @param fulfillmentCenterIds (optional) The fulfillment centers that will be used to filter product inventories
     * @return Success
     */
    getProductsInventories(ids: string[] | null | undefined, fulfillmentCenterIds: string[] | null | undefined): Promise<InventoryInfo[]> {
        let url_ = this.baseUrl + "/api/inventory/products?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (fulfillmentCenterIds !== undefined && fulfillmentCenterIds !== null)
            fulfillmentCenterIds && fulfillmentCenterIds.forEach(item => { url_ += "fulfillmentCenterIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductsInventories(_response);
        });
    }

    protected processGetProductsInventories(response: Response): Promise<InventoryInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfo[]>(<any>null);
    }

    /**
     * Get inventories of products
     * @param fulfillmentCenterIds (optional) The fulfillment centers that will be used to filter product inventories
     * @param body (optional) Products ids
     * @return Success
     */
    getProductsInventoriesByPlentyIds(fulfillmentCenterIds: string[] | null | undefined, body: string[] | null | undefined): Promise<InventoryInfo[]> {
        let url_ = this.baseUrl + "/api/inventory/products/plenty?";
        if (fulfillmentCenterIds !== undefined && fulfillmentCenterIds !== null)
            fulfillmentCenterIds && fulfillmentCenterIds.forEach(item => { url_ += "fulfillmentCenterIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductsInventoriesByPlentyIds(_response);
        });
    }

    protected processGetProductsInventoriesByPlentyIds(response: Response): Promise<InventoryInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfo[]>(<any>null);
    }

    /**
     * Get inventories of product
     * @param productId Product id
     * @return Success
     */
    getProductInventories(productId: string | null): Promise<InventoryInfo[]> {
        let url_ = this.baseUrl + "/api/inventory/products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductInventories(_response);
        });
    }

    protected processGetProductInventories(response: Response): Promise<InventoryInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InventoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfo[]>(<any>null);
    }

    /**
     * Update inventory
     * @param body (optional) Inventory to update
     * @return Success
     */
    updateProductInventory(productId: string, body: InventoryInfo | undefined): Promise<InventoryInfo> {
        let url_ = this.baseUrl + "/api/inventory/products/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductInventory(_response);
        });
    }

    protected processUpdateProductInventory(response: Response): Promise<InventoryInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InventoryInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InventoryInfo>(<any>null);
    }

    /**
     * Upsert inventories
     * @param body (optional) Inventories to upsert
     * @return Success
     */
    upsertProductInventories(body: InventoryInfo[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/inventory/plenty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpsertProductInventories(_response);
        });
    }

    protected processUpsertProductInventories(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class MarketingModuleDynamicContentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search content places list entries by given criteria
     * @param body (optional) criteria
     * @return Success
     */
    dynamicContentPlaceListEntriesSearch(body: DynamicContentPlaceSearchCriteria | undefined): Promise<DynamicContentListEntrySearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces/listentries/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDynamicContentPlaceListEntriesSearch(_response);
        });
    }

    protected processDynamicContentPlaceListEntriesSearch(response: Response): Promise<DynamicContentListEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentListEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentListEntrySearchResult>(<any>null);
    }

    /**
     * Search dynamic content places by given criteria
     * @param body (optional) criteria
     * @return Success
     */
    dynamicContentPlacesSearch(body: DynamicContentPlaceSearchCriteria | undefined): Promise<DynamicContentPlaceSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDynamicContentPlacesSearch(_response);
        });
    }

    protected processDynamicContentPlacesSearch(response: Response): Promise<DynamicContentPlaceSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPlaceSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPlaceSearchResult>(<any>null);
    }

    /**
     * Search content places list entries by given criteria
     * @param body (optional) criteria
     * @return Success
     */
    dynamicContentItemsEntriesSearch(body: DynamicContentItemSearchCriteria | undefined): Promise<DynamicContentListEntrySearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/listentries/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDynamicContentItemsEntriesSearch(_response);
        });
    }

    protected processDynamicContentItemsEntriesSearch(response: Response): Promise<DynamicContentListEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentListEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentListEntrySearchResult>(<any>null);
    }

    /**
     * Search dynamic content items by given criteria
     * @param body (optional) criteria
     * @return Success
     */
    dynamicContentItemsSearch(body: DynamicContentItemSearchCriteria | undefined): Promise<DynamicContentItemSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDynamicContentItemsSearch(_response);
        });
    }

    protected processDynamicContentItemsSearch(response: Response): Promise<DynamicContentItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentItemSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItemSearchResult>(<any>null);
    }

    /**
     * Search dynamic content items by given criteria
     * @param body (optional) criteria
     * @return Success
     */
    dynamicContentPublicationsSearch(body: DynamicContentPublicationSearchCriteria | undefined): Promise<DynamicContentPublicationSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDynamicContentPublicationsSearch(_response);
        });
    }

    protected processDynamicContentPublicationsSearch(response: Response): Promise<DynamicContentPublicationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublicationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublicationSearchResult>(<any>null);
    }

    /**
     * Get dynamic content for given placeholders
     * @param body (optional) 
     * @return Success
     */
    evaluateDynamicContent(body: DynamicContentEvaluationContext | undefined): Promise<DynamicContentItem[]> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvaluateDynamicContent(_response);
        });
    }

    protected processEvaluateDynamicContent(response: Response): Promise<DynamicContentItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DynamicContentItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItem[]>(<any>null);
    }

    /**
     * Find dynamic content item object by id
     * @param id content item id
     * @return Success
     */
    getDynamicContentById(id: string | null): Promise<DynamicContentItem> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDynamicContentById(_response);
        });
    }

    protected processGetDynamicContentById(response: Response): Promise<DynamicContentItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItem>(<any>null);
    }

    /**
     * Add new dynamic content item object to marketing system
     * @param body (optional) dynamic content object that needs to be added to the dynamic content system
     * @return Success
     */
    createDynamicContent(body: DynamicContentItem | undefined): Promise<DynamicContentItem> {
        let url_ = this.baseUrl + "/api/marketing/contentitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDynamicContent(_response);
        });
    }

    protected processCreateDynamicContent(response: Response): Promise<DynamicContentItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItem>(<any>null);
    }

    /**
     * Update a existing dynamic content item object
     * @param body (optional) dynamic content object that needs to be updated in the dynamic content system
     * @return Success
     */
    updateDynamicContent(body: DynamicContentItem | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDynamicContent(_response);
        });
    }

    protected processUpdateDynamicContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a dynamic content item objects
     * @param ids (optional) content item object ids for delete in the dynamic content system
     * @return Success
     */
    deleteDynamicContents(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentitems?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDynamicContents(_response);
        });
    }

    protected processDeleteDynamicContents(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find dynamic content place object by id
     * @param id place id
     * @return Success
     */
    getDynamicContentPlaceById(id: string | null): Promise<DynamicContentPlace> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDynamicContentPlaceById(_response);
        });
    }

    protected processGetDynamicContentPlaceById(response: Response): Promise<DynamicContentPlace> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPlace.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPlace>(<any>null);
    }

    /**
     * Add new dynamic content place object to marketing system
     * @param body (optional) dynamic content place object that needs to be added to the dynamic content system
     * @return Success
     */
    createDynamicContentPlace(body: DynamicContentPlace | undefined): Promise<DynamicContentPlace> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDynamicContentPlace(_response);
        });
    }

    protected processCreateDynamicContentPlace(response: Response): Promise<DynamicContentPlace> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPlace.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPlace>(<any>null);
    }

    /**
     * Update a existing dynamic content place object
     * @param body (optional) dynamic content place object that needs to be updated in the dynamic content system
     * @return Success
     */
    updateDynamicContentPlace(body: DynamicContentPlace | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDynamicContentPlace(_response);
        });
    }

    protected processUpdateDynamicContentPlace(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a dynamic content place objects
     * @param ids (optional) content place object ids for delete from dynamic content system
     * @return Success
     */
    deleteDynamicContentPlaces(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDynamicContentPlaces(_response);
        });
    }

    protected processDeleteDynamicContentPlaces(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get new dynamic content publication object
     * @return Success
     */
    getNewDynamicPublication(): Promise<DynamicContentPublication> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewDynamicPublication(_response);
        });
    }

    protected processGetNewDynamicPublication(response: Response): Promise<DynamicContentPublication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublication.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublication>(<any>null);
    }

    /**
     * Find dynamic content publication object by id
     * @param id publication id
     * @return Success
     */
    getDynamicContentPublicationById(id: string | null): Promise<DynamicContentPublication> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDynamicContentPublicationById(_response);
        });
    }

    protected processGetDynamicContentPublicationById(response: Response): Promise<DynamicContentPublication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublication.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublication>(<any>null);
    }

    /**
     * Add new dynamic content publication object to marketing system
     * @param body (optional) dynamic content publication object that needs to be added to the dynamic content system
     * @return Success
     */
    createDynamicContentPublication(body: DynamicContentPublication | undefined): Promise<DynamicContentPublication> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDynamicContentPublication(_response);
        });
    }

    protected processCreateDynamicContentPublication(response: Response): Promise<DynamicContentPublication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublication.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublication>(<any>null);
    }

    /**
     * Update a existing dynamic content publication object
     * @param body (optional) dynamic content publication object that needs to be updated in the dynamic content system
     * @return Success
     */
    updateDynamicContentPublication(body: DynamicContentPublication | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDynamicContentPublication(_response);
        });
    }

    protected processUpdateDynamicContentPublication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a dynamic content publication objects
     * @param ids (optional) content publication object ids for delete from dynamic content system
     * @return Success
     */
    deleteDynamicContentPublications(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDynamicContentPublications(_response);
        });
    }

    protected processDeleteDynamicContentPublications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Find dynamic content folder by id
     * @param id folder id
     * @return Success
     */
    getDynamicContentFolderById(id: string | null): Promise<DynamicContentFolder> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDynamicContentFolderById(_response);
        });
    }

    protected processGetDynamicContentFolderById(response: Response): Promise<DynamicContentFolder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentFolder.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentFolder>(<any>null);
    }

    /**
     * Add new dynamic content folder
     * @param body (optional) dynamic content folder that needs to be added
     * @return Success
     */
    createDynamicContentFolder(body: DynamicContentFolder | undefined): Promise<DynamicContentFolder> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateDynamicContentFolder(_response);
        });
    }

    protected processCreateDynamicContentFolder(response: Response): Promise<DynamicContentFolder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentFolder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentFolder>(<any>null);
    }

    /**
     * Update a existing dynamic content folder
     * @param body (optional) dynamic content folder that needs to be updated
     * @return Success
     */
    updateDynamicContentFolder(body: DynamicContentFolder | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDynamicContentFolder(_response);
        });
    }

    protected processUpdateDynamicContentFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a dynamic content folders
     * @param ids (optional) folders ids for delete
     * @return Success
     */
    deleteDynamicContentFolders(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDynamicContentFolders(_response);
        });
    }

    protected processDeleteDynamicContentFolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class MarketingModulePromotionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search dynamic content places by given criteria
     * @param body (optional) criteria
     * @return Success
     */
    promotionsSearch(body: PromotionSearchCriteria | undefined): Promise<PromotionSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/promotions/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPromotionsSearch(_response);
        });
    }

    protected processPromotionsSearch(response: Response): Promise<PromotionSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PromotionSearchResult>(<any>null);
    }

    /**
     * Evaluate promotions
     * @param body (optional) Promotion evaluation context
     * @return Success
     */
    evaluatePromotions(body: PromotionEvaluationContext | undefined): Promise<PromotionReward[]> {
        let url_ = this.baseUrl + "/api/marketing/promotions/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvaluatePromotions(_response);
        });
    }

    protected processEvaluatePromotions(response: Response): Promise<PromotionReward[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PromotionReward.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PromotionReward[]>(<any>null);
    }

    /**
     * Find promotion object by id
     * @param id promotion id
     * @return Success
     */
    getPromotionById(id: string | null): Promise<Promotion> {
        let url_ = this.baseUrl + "/api/marketing/promotions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPromotionById(_response);
        });
    }

    protected processGetPromotionById(response: Response): Promise<Promotion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Promotion.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Promotion>(<any>null);
    }

    /**
     * Get new dynamic promotion object
     * @return Success
     */
    getNewDynamicPromotion(): Promise<Promotion> {
        let url_ = this.baseUrl + "/api/marketing/promotions/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewDynamicPromotion(_response);
        });
    }

    protected processGetNewDynamicPromotion(response: Response): Promise<Promotion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Promotion.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Promotion>(<any>null);
    }

    /**
     * Add new dynamic promotion object to marketing system
     * @param body (optional) dynamic promotion object that needs to be added to the marketing system
     * @return Success
     */
    createPromotion(body: Promotion | undefined): Promise<Promotion> {
        let url_ = this.baseUrl + "/api/marketing/promotions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePromotion(_response);
        });
    }

    protected processCreatePromotion(response: Response): Promise<Promotion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Promotion.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Promotion>(<any>null);
    }

    /**
     * Update a existing dynamic promotion object in marketing system
     * @param body (optional) >dynamic promotion object that needs to be updated in the marketing system
     * @return Success
     */
    updatePromotions(body: Promotion | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePromotions(_response);
        });
    }

    protected processUpdatePromotions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete promotions objects
     * @param ids (optional) promotions object ids for delete in the marketing system
     * @return Success
     */
    deletePromotions(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePromotions(_response);
        });
    }

    protected processDeletePromotions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCoupons(body: CouponSearchCriteria | undefined): Promise<CouponSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchCoupons(_response);
        });
    }

    protected processSearchCoupons(response: Response): Promise<CouponSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CouponSearchResult>(<any>null);
    }

    /**
     * @return Success
     */
    getCoupon(id: string | null): Promise<Coupon> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCoupon(_response);
        });
    }

    protected processGetCoupon(response: Response): Promise<Coupon> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Coupon.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Coupon>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCoupons(body: Coupon[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddCoupons(_response);
        });
    }

    protected processAddCoupons(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteCoupons(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/delete?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCoupons(_response);
        });
    }

    protected processDeleteCoupons(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importCoupons(body: ImportRequest | undefined): Promise<ImportNotification> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportCoupons(_response);
        });
    }

    protected processImportCoupons(response: Response): Promise<ImportNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportNotification>(<any>null);
    }
}

export class NotificationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get all registered notification types by criteria
     * @param body (optional) criteria for search(keyword, skip, take and etc.)
     * @return Success
     */
    getNotifications(body: NotificationSearchCriteria | undefined): Promise<NotificationSearchResult> {
        let url_ = this.baseUrl + "/api/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotifications(_response);
        });
    }

    protected processGetNotifications(response: Response): Promise<NotificationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationSearchResult>(<any>null);
    }

    /**
     * Get notification by type
     * @param type Notification type of template
     * @param tenantId (optional) Tenant id of template
     * @param tenantType (optional) Tenant type id of template
     * @return Success
     */
    getNotificationByTypeId(type: string | null, tenantId: string | null | undefined, tenantType: string | null | undefined): Promise<Notification> {
        let url_ = this.baseUrl + "/api/notifications/{type}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        if (tenantId !== undefined && tenantId !== null)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (tenantType !== undefined && tenantType !== null)
            url_ += "tenantType=" + encodeURIComponent("" + tenantType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotificationByTypeId(_response);
        });
    }

    protected processGetNotificationByTypeId(response: Response): Promise<Notification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Notification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Notification>(<any>null);
    }

    /**
     * Update notification with templates
     * @param body (optional) Notification
     * @return Success
     */
    updateNotification(type: string, body: Notification | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/notifications/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateNotification(_response);
        });
    }

    protected processUpdateNotification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Render content
     * @param body (optional) request of Notification Template with text and data
     * @return Success
     */
    renderingTemplate(language: string | null, type: string, body: NotificationTemplateRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/notifications/{type}/templates/{language}/rendercontent";
        if (language === undefined || language === null)
            throw new Error("The parameter 'language' must be defined.");
        url_ = url_.replace("{language}", encodeURIComponent("" + language));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRenderingTemplate(_response);
        });
    }

    protected processRenderingTemplate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Sending notification
     * @param body (optional) 
     * @return Success
     */
    sendNotification(body: Notification | undefined): Promise<NotificationSendResult> {
        let url_ = this.baseUrl + "/api/notifications/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendNotification(_response);
        });
    }

    protected processSendNotification(response: Response): Promise<NotificationSendResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSendResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationSendResult>(<any>null);
    }

    /**
     * Schedule sending notification
     * @param body (optional) 
     * @return Success
     */
    scheduleSendNotification(body: Notification | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/notifications/schedule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processScheduleSendNotification(_response);
        });
    }

    protected processScheduleSendNotification(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Schedule resending notification
     * @param body (optional) 
     * @return Success
     */
    resendNotifications(body: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/notifications/scheduleresend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResendNotifications(_response);
        });
    }

    protected processResendNotifications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Sending notification
     * @param body (optional) Notification request
     * @return Success
     */
    sendNotificationByRequest(body: NotificationRequest | undefined): Promise<NotificationSendResult> {
        let url_ = this.baseUrl + "/api/platform/notification/template/sendnotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendNotificationByRequest(_response);
        });
    }

    protected processSendNotificationByRequest(response: Response): Promise<NotificationSendResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationSendResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationSendResult>(<any>null);
    }

    /**
     * Get all notification journal
     * @param body (optional) 
     * @return Success
     */
    getNotificationJournal(body: NotificationMessageSearchCriteria | undefined): Promise<NotificationMessageSearchResult> {
        let url_ = this.baseUrl + "/api/notifications/journal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotificationJournal(_response);
        });
    }

    protected processGetNotificationJournal(response: Response): Promise<NotificationMessageSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationMessageSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationMessageSearchResult>(<any>null);
    }

    /**
     * @return Success
     */
    getObjectNotificationJournal(id: string | null): Promise<NotificationMessage> {
        let url_ = this.baseUrl + "/api/notifications/journal/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetObjectNotificationJournal(_response);
        });
    }

    protected processGetObjectNotificationJournal(response: Response): Promise<NotificationMessage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationMessage.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationMessage>(<any>null);
    }
}

export class OrderModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search customer orders by given criteria
     * @param body (optional) criteria
     * @return Success
     */
    searchCustomerOrder(body: CustomerOrderSearchCriteria | undefined): Promise<CustomerOrderSearchResult> {
        let url_ = this.baseUrl + "/api/order/customerOrders/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchCustomerOrder(_response);
        });
    }

    protected processSearchCustomerOrder(response: Response): Promise<CustomerOrderSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrderSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrderSearchResult>(<any>null);
    }

    /**
     * Find customer order by number
     * @param number customer order number
     * @param respGroup (optional) 
     * @return Success
     */
    getByNumber(number: string | null, respGroup: string | null | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/customerOrders/number/{number}?";
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number));
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetByNumber(_response);
        });
    }

    protected processGetByNumber(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(<any>null);
    }

    /**
     * Find customer order by id
     * @param id customer order id
     * @param respGroup (optional) 
     * @return Success
     */
    getById(id: string | null, respGroup: string | null | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(<any>null);
    }

    /**
     * Calculate order totals after changes
     * @param body (optional) Customer order
     * @return Success
     */
    calculateTotals(body: CustomerOrder | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/customerOrders/recalculate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCalculateTotals(_response);
        });
    }

    protected processCalculateTotals(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(<any>null);
    }

    /**
     * Register customer order payment in external payment system
     * @param orderId customer order id
     * @param paymentId payment id
     * @param body (optional) banking card information
     * @return Success
     */
    processOrderPayments(orderId: string | null, paymentId: string | null, body: BankCardInfo | undefined): Promise<ProcessPaymentRequestResult> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{orderId}/processPayment/{paymentId}";
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        if (paymentId === undefined || paymentId === null)
            throw new Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProcessOrderPayments(_response);
        });
    }

    protected processProcessOrderPayments(response: Response): Promise<ProcessPaymentRequestResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessPaymentRequestResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProcessPaymentRequestResult>(<any>null);
    }

    /**
     * Create new customer order based on shopping cart.
     * @param cartId shopping cart id
     * @return Success
     */
    createOrderFromCart(cartId: string | null): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{cartId}";
        if (cartId === undefined || cartId === null)
            throw new Error("The parameter 'cartId' must be defined.");
        url_ = url_.replace("{cartId}", encodeURIComponent("" + cartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrderFromCart(_response);
        });
    }

    protected processCreateOrderFromCart(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(<any>null);
    }

    /**
     * Add new customer order to system
     * @param body (optional) customer order
     * @return Success
     */
    createOrder(body: CustomerOrder | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/customerOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrder(_response);
        });
    }

    protected processCreateOrder(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(<any>null);
    }

    /**
     * Update a existing customer order
     * @param body (optional) customer order
     * @return Success
     */
    updateOrder(body: CustomerOrder | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/order/customerOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateOrder(_response);
        });
    }

    protected processUpdateOrder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete a whole customer orders
     * @param ids (optional) customer order ids for delete
     * @return Success
     */
    deleteOrdersByIds(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/order/customerOrders?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOrdersByIds(_response);
        });
    }

    protected processDeleteOrdersByIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get new shipment for specified customer order
     * @param id customer order id
     * @return Success
     */
    getNewShipment(id: string | null): Promise<OrderShipment> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{id}/shipments/new";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewShipment(_response);
        });
    }

    protected processGetNewShipment(response: Response): Promise<OrderShipment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderShipment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderShipment>(<any>null);
    }

    /**
     * Get new payment for specified customer order
     * @param id customer order id
     * @return Success
     */
    getNewPayment(id: string | null): Promise<PaymentIn> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{id}/payments/new";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewPayment(_response);
        });
    }

    protected processGetNewPayment(response: Response): Promise<PaymentIn> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentIn.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentIn>(<any>null);
    }

    /**
     * Get a some order statistic information for Commerce manager dashboard
     * @param start (optional) start interval date
     * @param end (optional) end interval date
     * @return Success
     */
    getDashboardStatistics(start: Date | null | undefined, end: Date | null | undefined): Promise<DashboardStatisticsResult> {
        let url_ = this.baseUrl + "/api/order/dashboardStatistics?";
        if (start !== undefined && start !== null)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toJSON() : "") + "&";
        if (end !== undefined && end !== null)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDashboardStatistics(_response);
        });
    }

    protected processGetDashboardStatistics(response: Response): Promise<DashboardStatisticsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardStatisticsResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardStatisticsResult>(<any>null);
    }

    /**
     * Payment callback operation used by external payment services to inform post process payment in our system
     * @param body (optional) payment callback parameters
     * @return Success
     */
    postProcessPayment(body: PaymentCallbackParameters | undefined): Promise<PostProcessPaymentRequestResult> {
        let url_ = this.baseUrl + "/api/paymentcallback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostProcessPayment(_response);
        });
    }

    protected processPostProcessPayment(response: Response): Promise<PostProcessPaymentRequestResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostProcessPaymentRequestResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostProcessPaymentRequestResult>(<any>null);
    }

    /**
     * @return OK
     */
    getInvoicePdf(orderNumber: string | null): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/order/customerOrders/invoice/{orderNumber}";
        if (orderNumber === undefined || orderNumber === null)
            throw new Error("The parameter 'orderNumber' must be defined.");
        url_ = url_.replace("{orderNumber}", encodeURIComponent("" + orderNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInvoicePdf(_response);
        });
    }

    protected processGetInvoicePdf(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getOrderChanges(id: string | null): Promise<OperationLog[]> {
        let url_ = this.baseUrl + "/api/order/customerOrders/{id}/changes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrderChanges(_response);
        });
    }

    protected processGetOrderChanges(response: Response): Promise<OperationLog[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OperationLog.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationLog[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchOrderChanges(body: CustomerOrderHistorySearchCriteria | undefined): Promise<ChangeLogSearchResult> {
        let url_ = this.baseUrl + "/api/order/customerOrders/searchChanges";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchOrderChanges(_response);
        });
    }

    protected processSearchOrderChanges(response: Response): Promise<ChangeLogSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ChangeLogSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ChangeLogSearchResult>(<any>null);
    }

    /**
     * @return Success
     */
    getOrderFullTextSearchEnabled(): Promise<void> {
        let url_ = this.baseUrl + "/api/order/customerOrders/indexed/searchEnabled";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOrderFullTextSearchEnabled(_response);
        });
    }

    protected processGetOrderFullTextSearchEnabled(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCustomerOrderIndexed(body: CustomerOrderIndexedSearchCriteria | undefined): Promise<CustomerOrderSearchResult> {
        let url_ = this.baseUrl + "/api/order/customerOrders/indexed/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchCustomerOrderIndexed(_response);
        });
    }

    protected processSearchCustomerOrderIndexed(response: Response): Promise<CustomerOrderSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrderSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrderSearchResult>(<any>null);
    }
}

export class OrderModulePaymentsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search  order payments by given criteria
     * @param body (optional) criteria
     * @return Success
     */
    searchOrderPayments(body: PaymentSearchCriteria | undefined): Promise<PaymentSearchResult> {
        let url_ = this.baseUrl + "/api/order/payments/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchOrderPayments(_response);
        });
    }

    protected processSearchOrderPayments(response: Response): Promise<PaymentSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentSearchResult>(<any>null);
    }

    /**
     * Find  order payment by id
     * @param id order payment id
     * @param respGroup (optional) 
     * @return Success
     */
    getById(id: string | null, respGroup: string | null | undefined): Promise<PaymentIn> {
        let url_ = this.baseUrl + "/api/order/payments/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<PaymentIn> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentIn.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentIn>(<any>null);
    }

    /**
     * Create or update order payment
     * @param body (optional) payment
     * @return Success
     */
    createPayment(body: PaymentIn | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/payments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePayment(_response);
        });
    }

    protected processCreatePayment(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePayment(body: PaymentIn | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/order/payments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePayment(_response);
        });
    }

    protected processUpdatePayment(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(<any>null);
    }

    /**
     * Delete an order payment
     * @param ids (optional) order payment ids
     * @return Success
     */
    deleteOrderPaymentsByIds(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/order/payments?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteOrderPaymentsByIds(_response);
        });
    }

    protected processDeleteOrderPaymentsByIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class PaymentModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRegisteredPaymentMethods(): Promise<PaymentMethod> {
        let url_ = this.baseUrl + "/api/payment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegisteredPaymentMethods(_response);
        });
    }

    protected processGetRegisteredPaymentMethods(response: Response): Promise<PaymentMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethod>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePaymentMethod(body: PaymentMethod | undefined): Promise<PaymentMethod> {
        let url_ = this.baseUrl + "/api/payment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePaymentMethod(_response);
        });
    }

    protected processUpdatePaymentMethod(response: Response): Promise<PaymentMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethod>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchPaymentMethods(body: PaymentMethodsSearchCriteria | undefined): Promise<PaymentMethodsSearchResult> {
        let url_ = this.baseUrl + "/api/payment/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchPaymentMethods(_response);
        });
    }

    protected processSearchPaymentMethods(response: Response): Promise<PaymentMethodsSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethodsSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethodsSearchResult>(<any>null);
    }

    /**
     * @return Success
     */
    getPaymentMethodById(id: string | null): Promise<PaymentMethod> {
        let url_ = this.baseUrl + "/api/payment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaymentMethodById(_response);
        });
    }

    protected processGetPaymentMethodById(response: Response): Promise<PaymentMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentMethod>(<any>null);
    }
}

export class PricingModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Evaluate prices by given context
     * @param body (optional) Pricing evaluation context
     * @return Success
     */
    evaluatePrices(body: PriceEvaluationContext | undefined): Promise<Price[]> {
        let url_ = this.baseUrl + "/api/pricing/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvaluatePrices(_response);
        });
    }

    protected processEvaluatePrices(response: Response): Promise<Price[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Price.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Price[]>(<any>null);
    }

    /**
     * Evaluate pricelists by given context
     * @param body (optional) Pricing evaluation context
     * @return Success
     */
    evaluatePriceLists(body: PriceEvaluationContext | undefined): Promise<Pricelist[]> {
        let url_ = this.baseUrl + "/api/pricing/pricelists/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvaluatePriceLists(_response);
        });
    }

    protected processEvaluatePriceLists(response: Response): Promise<Pricelist[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pricelist.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Pricelist[]>(<any>null);
    }

    /**
     * Get pricelist assignment
     * @param id Pricelist assignment id
     * @return Success
     */
    getPricelistAssignmentById(id: string | null): Promise<PricelistAssignment> {
        let url_ = this.baseUrl + "/api/pricing/assignments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPricelistAssignmentById(_response);
        });
    }

    protected processGetPricelistAssignmentById(response: Response): Promise<PricelistAssignment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PricelistAssignment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PricelistAssignment>(<any>null);
    }

    /**
     * Get a new pricelist assignment
     * @return Success
     */
    getNewPricelistAssignments(): Promise<PricelistAssignment> {
        let url_ = this.baseUrl + "/api/pricing/assignments/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNewPricelistAssignments(_response);
        });
    }

    protected processGetNewPricelistAssignments(response: Response): Promise<PricelistAssignment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PricelistAssignment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PricelistAssignment>(<any>null);
    }

    /**
     * Get pricelists
     * @param currencies (optional) 
     * @param responseGroup (optional) 
     * @param objectType (optional) 
     * @param objectTypes (optional) 
     * @param objectIds (optional) 
     * @param keyword (optional) 
     * @param searchPhrase (optional) 
     * @param languageCode (optional) 
     * @param sort (optional) 
     * @param sortInfos (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    searchPricelists(currencies: string[] | null | undefined, responseGroup: string | null | undefined, objectType: string | null | undefined, objectTypes: string[] | null | undefined, objectIds: string[] | null | undefined, keyword: string | null | undefined, searchPhrase: string | null | undefined, languageCode: string | null | undefined, sort: string | null | undefined, sortInfos: SortInfo[] | null | undefined, skip: number | undefined, take: number | undefined): Promise<PricelistSearchResult> {
        let url_ = this.baseUrl + "/api/pricing/pricelists?";
        if (currencies !== undefined && currencies !== null)
            currencies && currencies.forEach(item => { url_ += "Currencies=" + encodeURIComponent("" + item) + "&"; });
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (objectTypes !== undefined && objectTypes !== null)
            objectTypes && objectTypes.forEach(item => { url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&"; });
        if (objectIds !== undefined && objectIds !== null)
            objectIds && objectIds.forEach(item => { url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&"; });
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (sortInfos !== undefined && sortInfos !== null)
            sortInfos && sortInfos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "SortInfos[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchPricelists(_response);
        });
    }

    protected processSearchPricelists(response: Response): Promise<PricelistSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PricelistSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PricelistSearchResult>(<any>null);
    }

    /**
     * Create pricelist
     * @param body (optional) 
     * @return Success
     */
    createPriceList(body: Pricelist | undefined): Promise<Pricelist> {
        let url_ = this.baseUrl + "/api/pricing/pricelists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePriceList(_response);
        });
    }

    protected processCreatePriceList(response: Response): Promise<Pricelist> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Pricelist.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Pricelist>(<any>null);
    }

    /**
     * Update pricelist
     * @param body (optional) 
     * @return Success
     */
    updatePriceList(body: Pricelist | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/pricelists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePriceList(_response);
        });
    }

    protected processUpdatePriceList(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete pricelists
     * @param ids (optional) An array of pricelist ids
     * @return Success
     */
    deletePricelists(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/pricelists?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePricelists(_response);
        });
    }

    protected processDeletePricelists(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Search pricelist assignments
     * @param priceListId (optional) 
     * @param catalogIds (optional) 
     * @param priceListIds (optional) 
     * @param responseGroup (optional) 
     * @param objectType (optional) 
     * @param objectTypes (optional) 
     * @param objectIds (optional) 
     * @param keyword (optional) 
     * @param searchPhrase (optional) 
     * @param languageCode (optional) 
     * @param sort (optional) 
     * @param sortInfos (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    searchPricelistAssignments(priceListId: string | null | undefined, catalogIds: string[] | null | undefined, priceListIds: string[] | null | undefined, responseGroup: string | null | undefined, objectType: string | null | undefined, objectTypes: string[] | null | undefined, objectIds: string[] | null | undefined, keyword: string | null | undefined, searchPhrase: string | null | undefined, languageCode: string | null | undefined, sort: string | null | undefined, sortInfos: SortInfo[] | null | undefined, skip: number | undefined, take: number | undefined): Promise<PricelistAssignmentSearchResult> {
        let url_ = this.baseUrl + "/api/pricing/assignments?";
        if (priceListId !== undefined && priceListId !== null)
            url_ += "PriceListId=" + encodeURIComponent("" + priceListId) + "&";
        if (catalogIds !== undefined && catalogIds !== null)
            catalogIds && catalogIds.forEach(item => { url_ += "CatalogIds=" + encodeURIComponent("" + item) + "&"; });
        if (priceListIds !== undefined && priceListIds !== null)
            priceListIds && priceListIds.forEach(item => { url_ += "PriceListIds=" + encodeURIComponent("" + item) + "&"; });
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (objectTypes !== undefined && objectTypes !== null)
            objectTypes && objectTypes.forEach(item => { url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&"; });
        if (objectIds !== undefined && objectIds !== null)
            objectIds && objectIds.forEach(item => { url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&"; });
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (sortInfos !== undefined && sortInfos !== null)
            sortInfos && sortInfos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "SortInfos[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchPricelistAssignments(_response);
        });
    }

    protected processSearchPricelistAssignments(response: Response): Promise<PricelistAssignmentSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PricelistAssignmentSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PricelistAssignmentSearchResult>(<any>null);
    }

    /**
     * Create pricelist assignment
     * @param body (optional) PricelistAssignment
     * @return Success
     */
    createPricelistAssignment(body: PricelistAssignment | undefined): Promise<PricelistAssignment> {
        let url_ = this.baseUrl + "/api/pricing/assignments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePricelistAssignment(_response);
        });
    }

    protected processCreatePricelistAssignment(response: Response): Promise<PricelistAssignment> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PricelistAssignment.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PricelistAssignment>(<any>null);
    }

    /**
     * Update pricelist assignment
     * @param body (optional) PricelistAssignment
     * @return Success
     */
    updatePriceListAssignment(body: PricelistAssignment | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/assignments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePriceListAssignment(_response);
        });
    }

    protected processUpdatePriceListAssignment(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete pricelist assignments
     * @param ids (optional) An array of pricelist assignment ids
     * @return Success
     */
    deleteAssignments(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/assignments?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAssignments(_response);
        });
    }

    protected processDeleteAssignments(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Search product prices
     * @param groupByProducts (optional) 
     * @param priceListId (optional) 
     * @param priceListIds (optional) 
     * @param productId (optional) 
     * @param productIds (optional) 
     * @param modifiedSince (optional) 
     * @param responseGroup (optional) 
     * @param objectType (optional) 
     * @param objectTypes (optional) 
     * @param objectIds (optional) 
     * @param keyword (optional) 
     * @param searchPhrase (optional) 
     * @param languageCode (optional) 
     * @param sort (optional) 
     * @param sortInfos (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    searchProductPricesGet(groupByProducts: boolean | undefined, priceListId: string | null | undefined, priceListIds: string[] | null | undefined, productId: string | null | undefined, productIds: string[] | null | undefined, modifiedSince: Date | null | undefined, responseGroup: string | null | undefined, objectType: string | null | undefined, objectTypes: string[] | null | undefined, objectIds: string[] | null | undefined, keyword: string | null | undefined, searchPhrase: string | null | undefined, languageCode: string | null | undefined, sort: string | null | undefined, sortInfos: SortInfo[] | null | undefined, skip: number | undefined, take: number | undefined): Promise<ProductPriceSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/products/prices/search?";
        if (groupByProducts === null)
            throw new Error("The parameter 'groupByProducts' cannot be null.");
        else if (groupByProducts !== undefined)
            url_ += "GroupByProducts=" + encodeURIComponent("" + groupByProducts) + "&";
        if (priceListId !== undefined && priceListId !== null)
            url_ += "PriceListId=" + encodeURIComponent("" + priceListId) + "&";
        if (priceListIds !== undefined && priceListIds !== null)
            priceListIds && priceListIds.forEach(item => { url_ += "PriceListIds=" + encodeURIComponent("" + item) + "&"; });
        if (productId !== undefined && productId !== null)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&";
        if (productIds !== undefined && productIds !== null)
            productIds && productIds.forEach(item => { url_ += "ProductIds=" + encodeURIComponent("" + item) + "&"; });
        if (modifiedSince !== undefined && modifiedSince !== null)
            url_ += "ModifiedSince=" + encodeURIComponent(modifiedSince ? "" + modifiedSince.toJSON() : "") + "&";
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (objectTypes !== undefined && objectTypes !== null)
            objectTypes && objectTypes.forEach(item => { url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&"; });
        if (objectIds !== undefined && objectIds !== null)
            objectIds && objectIds.forEach(item => { url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&"; });
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (sortInfos !== undefined && sortInfos !== null)
            sortInfos && sortInfos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "SortInfos[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchProductPricesGet(_response);
        });
    }

    protected processSearchProductPricesGet(response: Response): Promise<ProductPriceSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPriceSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductPriceSearchResult>(<any>null);
    }

    /**
     * Search product prices
     * @param body (optional) 
     * @return Success
     */
    searchProductPricesPost(body: PricesSearchCriteria | undefined): Promise<ProductPriceSearchResult> {
        let url_ = this.baseUrl + "/api/catalog/products/prices/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchProductPricesPost(_response);
        });
    }

    protected processSearchProductPricesPost(response: Response): Promise<ProductPriceSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductPriceSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductPriceSearchResult>(<any>null);
    }

    /**
     * Evaluate  product prices
     * @param productId Product id
     * @return Success
     */
    evaluateProductPrices(productId: string | null): Promise<Price[]> {
        let url_ = this.baseUrl + "/api/products/{productId}/prices";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvaluateProductPrices(_response);
        });
    }

    protected processEvaluateProductPrices(response: Response): Promise<Price[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Price.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Price[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductPrices(productId: string, body: ProductPrice | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/products/{productId}/prices";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductPrices(_response);
        });
    }

    protected processUpdateProductPrices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Evaluate product prices for demand catalog
     * @param productId Product id
     * @param catalogId Catalog id
     * @return Success
     */
    evaluateProductPricesForCatalog(productId: string | null, catalogId: string | null): Promise<Price[]> {
        let url_ = this.baseUrl + "/api/products/{productId}/{catalogId}/pricesWidget";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (catalogId === undefined || catalogId === null)
            throw new Error("The parameter 'catalogId' must be defined.");
        url_ = url_.replace("{catalogId}", encodeURIComponent("" + catalogId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvaluateProductPricesForCatalog(_response);
        });
    }

    protected processEvaluateProductPricesForCatalog(response: Response): Promise<Price[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Price.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Price[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProductsPrices(body: ProductPrice[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/products/prices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductsPrices(_response);
        });
    }

    protected processUpdateProductsPrices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get all price lists for product
     * @param productId Product id
     * @return Success
     */
    getProductPriceLists(productId: string | null): Promise<Pricelist[]> {
        let url_ = this.baseUrl + "/api/catalog/products/{productId}/pricelists";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductPriceLists(_response);
        });
    }

    protected processGetProductPriceLists(response: Response): Promise<Pricelist[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Pricelist.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Pricelist[]>(<any>null);
    }

    /**
     * Get pricelist
     * @param id Pricelist id
     * @return Success
     */
    getPriceListById(id: string | null): Promise<Pricelist> {
        let url_ = this.baseUrl + "/api/pricing/pricelists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPriceListById(_response);
        });
    }

    protected processGetPriceListById(response: Response): Promise<Pricelist> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Pricelist.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Pricelist>(<any>null);
    }

    /**
     * Delete pricelist assignments
     * @param priceListId (optional) 
     * @param catalogIds (optional) 
     * @param priceListIds (optional) 
     * @param responseGroup (optional) 
     * @param objectType (optional) 
     * @param objectTypes (optional) 
     * @param objectIds (optional) 
     * @param keyword (optional) 
     * @param searchPhrase (optional) 
     * @param languageCode (optional) 
     * @param sort (optional) 
     * @param sortInfos (optional) 
     * @param skip (optional) 
     * @param take (optional) 
     * @return Success
     */
    deleteFilteredAssignments(priceListId: string | null | undefined, catalogIds: string[] | null | undefined, priceListIds: string[] | null | undefined, responseGroup: string | null | undefined, objectType: string | null | undefined, objectTypes: string[] | null | undefined, objectIds: string[] | null | undefined, keyword: string | null | undefined, searchPhrase: string | null | undefined, languageCode: string | null | undefined, sort: string | null | undefined, sortInfos: SortInfo[] | null | undefined, skip: number | undefined, take: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/filteredAssignments?";
        if (priceListId !== undefined && priceListId !== null)
            url_ += "PriceListId=" + encodeURIComponent("" + priceListId) + "&";
        if (catalogIds !== undefined && catalogIds !== null)
            catalogIds && catalogIds.forEach(item => { url_ += "CatalogIds=" + encodeURIComponent("" + item) + "&"; });
        if (priceListIds !== undefined && priceListIds !== null)
            priceListIds && priceListIds.forEach(item => { url_ += "PriceListIds=" + encodeURIComponent("" + item) + "&"; });
        if (responseGroup !== undefined && responseGroup !== null)
            url_ += "ResponseGroup=" + encodeURIComponent("" + responseGroup) + "&";
        if (objectType !== undefined && objectType !== null)
            url_ += "ObjectType=" + encodeURIComponent("" + objectType) + "&";
        if (objectTypes !== undefined && objectTypes !== null)
            objectTypes && objectTypes.forEach(item => { url_ += "ObjectTypes=" + encodeURIComponent("" + item) + "&"; });
        if (objectIds !== undefined && objectIds !== null)
            objectIds && objectIds.forEach(item => { url_ += "ObjectIds=" + encodeURIComponent("" + item) + "&"; });
        if (keyword !== undefined && keyword !== null)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (sort !== undefined && sort !== null)
            url_ += "Sort=" + encodeURIComponent("" + sort) + "&";
        if (sortInfos !== undefined && sortInfos !== null)
            sortInfos && sortInfos.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "SortInfos[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "Skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "Take=" + encodeURIComponent("" + take) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteFilteredAssignments(_response);
        });
    }

    protected processDeleteFilteredAssignments(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete all prices for specified product in specified price list
     * @param productIds (optional) 
     * @return Success
     */
    deleteProductPrices(pricelistId: string | null, productIds: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/pricelists/{pricelistId}/products/prices?";
        if (pricelistId === undefined || pricelistId === null)
            throw new Error("The parameter 'pricelistId' must be defined.");
        url_ = url_.replace("{pricelistId}", encodeURIComponent("" + pricelistId));
        if (productIds !== undefined && productIds !== null)
            productIds && productIds.forEach(item => { url_ += "productIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductPrices(_response);
        });
    }

    protected processDeleteProductPrices(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete price by ids
     * @param priceIds (optional) 
     * @return Success
     */
    deleteProductPrice(priceIds: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/pricing/products/prices?";
        if (priceIds !== undefined && priceIds !== null)
            priceIds && priceIds.forEach(item => { url_ += "priceIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductPrice(_response);
        });
    }

    protected processDeleteProductPrice(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SearchIndexationModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllIndexes(): Promise<IndexState[]> {
        let url_ = this.baseUrl + "/api/search/indexes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllIndexes(_response);
        });
    }

    protected processGetAllIndexes(response: Response): Promise<IndexState[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndexState.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexState[]>(<any>null);
    }

    /**
     * Get search index for specified document type and document id.
     * @return Success
     */
    getDocumentIndex(documentType: string | null, documentId: string | null): Promise<IndexDocument[]> {
        let url_ = this.baseUrl + "/api/search/indexes/index/{documentType}/{documentId}";
        if (documentType === undefined || documentType === null)
            throw new Error("The parameter 'documentType' must be defined.");
        url_ = url_.replace("{documentType}", encodeURIComponent("" + documentType));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDocumentIndex(_response);
        });
    }

    protected processGetDocumentIndex(response: Response): Promise<IndexDocument[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndexDocument.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexDocument[]>(<any>null);
    }

    /**
     * Run indexation process for specified options
     * @param body (optional) 
     * @return Success
     */
    indexDocuments(body: IndexingOptions[] | null | undefined): Promise<IndexProgressPushNotification> {
        let url_ = this.baseUrl + "/api/search/indexes/index";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIndexDocuments(_response);
        });
    }

    protected processIndexDocuments(response: Response): Promise<IndexProgressPushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IndexProgressPushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexProgressPushNotification>(<any>null);
    }

    /**
     * @return Success
     */
    cancelIndexationProcess(taskId: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/search/indexes/tasks/{taskId}/cancel";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelIndexationProcess(_response);
        });
    }

    protected processCancelIndexationProcess(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ShippingModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRegisteredShippingMethods(): Promise<ShippingMethod> {
        let url_ = this.baseUrl + "/api/shipping";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRegisteredShippingMethods(_response);
        });
    }

    protected processGetRegisteredShippingMethods(response: Response): Promise<ShippingMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShippingMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingMethod>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateShippingMethod(body: ShippingMethod | undefined): Promise<ShippingMethod> {
        let url_ = this.baseUrl + "/api/shipping";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateShippingMethod(_response);
        });
    }

    protected processUpdateShippingMethod(response: Response): Promise<ShippingMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShippingMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingMethod>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchShippingMethods(body: ShippingMethodsSearchCriteria | undefined): Promise<ShippingMethodsSearchResult> {
        let url_ = this.baseUrl + "/api/shipping/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchShippingMethods(_response);
        });
    }

    protected processSearchShippingMethods(response: Response): Promise<ShippingMethodsSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShippingMethodsSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingMethodsSearchResult>(<any>null);
    }

    /**
     * @return Success
     */
    getShippingMethodById(id: string | null): Promise<ShippingMethod> {
        let url_ = this.baseUrl + "/api/shipping/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetShippingMethodById(_response);
        });
    }

    protected processGetShippingMethodById(response: Response): Promise<ShippingMethod> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShippingMethod.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShippingMethod>(<any>null);
    }
}

export class SitemapsModuleApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchSitemaps(body: SitemapSearchCriteria | undefined): Promise<SitemapSearchResult> {
        let url_ = this.baseUrl + "/api/sitemaps/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchSitemaps(_response);
        });
    }

    protected processSearchSitemaps(response: Response): Promise<SitemapSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitemapSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SitemapSearchResult>(<any>null);
    }

    /**
     * @return Success
     */
    getSitemapById(id: string | null): Promise<Sitemap> {
        let url_ = this.baseUrl + "/api/sitemaps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSitemapById(_response);
        });
    }

    protected processGetSitemapById(response: Response): Promise<Sitemap> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sitemap.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Sitemap>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSitemap(body: Sitemap | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sitemaps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddSitemap(_response);
        });
    }

    protected processAddSitemap(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSitemap(body: Sitemap | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sitemaps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSitemap(_response);
        });
    }

    protected processUpdateSitemap(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteSitemap(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sitemaps?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSitemap(_response);
        });
    }

    protected processDeleteSitemap(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchSitemapItems(body: SitemapItemSearchCriteria | undefined): Promise<SitemapItemsSearchResult> {
        let url_ = this.baseUrl + "/api/sitemaps/items/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchSitemapItems(_response);
        });
    }

    protected processSearchSitemapItems(response: Response): Promise<SitemapItemsSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitemapItemsSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SitemapItemsSearchResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSitemapItems(sitemapId: string | null, body: SitemapItem[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sitemaps/{sitemapId}/items";
        if (sitemapId === undefined || sitemapId === null)
            throw new Error("The parameter 'sitemapId' must be defined.");
        url_ = url_.replace("{sitemapId}", encodeURIComponent("" + sitemapId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddSitemapItems(_response);
        });
    }

    protected processAddSitemapItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param itemIds (optional) 
     * @return Success
     */
    removeSitemapItems(itemIds: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/sitemaps/items?";
        if (itemIds !== undefined && itemIds !== null)
            itemIds && itemIds.forEach(item => { url_ += "itemIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveSitemapItems(_response);
        });
    }

    protected processRemoveSitemapItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param storeId (optional) 
     * @return Success
     */
    getSitemapsSchema(storeId: string | null | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/sitemaps/schema?";
        if (storeId !== undefined && storeId !== null)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSitemapsSchema(_response);
        });
    }

    protected processGetSitemapsSchema(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    /**
     * @param storeId (optional) 
     * @param baseUrl (optional) 
     * @param sitemapUrl (optional) 
     * @return OK
     */
    generateSitemap(storeId: string | null | undefined, baseUrl: string | null | undefined, sitemapUrl: string | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/sitemaps/generate?";
        if (storeId !== undefined && storeId !== null)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (baseUrl !== undefined && baseUrl !== null)
            url_ += "baseUrl=" + encodeURIComponent("" + baseUrl) + "&";
        if (sitemapUrl !== undefined && sitemapUrl !== null)
            url_ += "sitemapUrl=" + encodeURIComponent("" + sitemapUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateSitemap(_response);
        });
    }

    protected processGenerateSitemap(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * @param storeId (optional) 
     * @param baseUrl (optional) 
     * @return Success
     */
    downloadSitemap(storeId: string | null | undefined, baseUrl: string | null | undefined): Promise<SitemapDownloadNotification> {
        let url_ = this.baseUrl + "/api/sitemaps/download?";
        if (storeId !== undefined && storeId !== null)
            url_ += "storeId=" + encodeURIComponent("" + storeId) + "&";
        if (baseUrl !== undefined && baseUrl !== null)
            url_ += "baseUrl=" + encodeURIComponent("" + baseUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadSitemap(_response);
        });
    }

    protected processDownloadSitemap(response: Response): Promise<SitemapDownloadNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SitemapDownloadNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SitemapDownloadNotification>(<any>null);
    }
}

export class StoreModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search stores
     * @param body (optional) 
     * @return Success
     */
    searchStores(body: StoreSearchCriteria | undefined): Promise<StoreSearchResult> {
        let url_ = this.baseUrl + "/api/stores/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchStores(_response);
        });
    }

    protected processSearchStores(response: Response): Promise<StoreSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoreSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StoreSearchResult>(<any>null);
    }

    /**
     * Get all stores
     * @return Success
     */
    getStores(): Promise<Store[]> {
        let url_ = this.baseUrl + "/api/stores";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStores(_response);
        });
    }

    protected processGetStores(response: Response): Promise<Store[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Store.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Store[]>(<any>null);
    }

    /**
     * Create store
     * @param body (optional) Store
     * @return Success
     */
    createStore(body: Store | undefined): Promise<Store> {
        let url_ = this.baseUrl + "/api/stores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateStore(_response);
        });
    }

    protected processCreateStore(response: Response): Promise<Store> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Store.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Store>(<any>null);
    }

    /**
     * Update store
     * @param body (optional) Store
     * @return Success
     */
    updateStore(body: Store | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/stores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateStore(_response);
        });
    }

    protected processUpdateStore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Delete stores
     * @param ids (optional) Ids of store that needed to delete
     * @return Success
     */
    deleteStore(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/stores?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteStore(_response);
        });
    }

    protected processDeleteStore(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get store by id
     * @param id Store id
     * @return Success
     */
    getStoreById(id: string | null): Promise<Store> {
        let url_ = this.baseUrl + "/api/stores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStoreById(_response);
        });
    }

    protected processGetStoreById(response: Response): Promise<Store> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Store.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Store>(<any>null);
    }

    /**
     * Send dynamic notification (contains custom list of properties) to store or administrator email
     * @param body (optional) 
     * @return Success
     */
    sendDynamicNotificationAnStoreEmail(body: SendDynamicNotificationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/stores/send/dynamicnotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendDynamicNotificationAnStoreEmail(_response);
        });
    }

    protected processSendDynamicNotificationAnStoreEmail(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Check if given contact has login on behalf permission
     * @param storeId Store ID
     * @param id Contact ID
     * @return Success
     */
    getLoginOnBehalfInfo(storeId: string | null, id: string | null): Promise<LoginOnBehalfInfo> {
        let url_ = this.baseUrl + "/api/stores/{storeId}/accounts/{id}/loginonbehalf";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLoginOnBehalfInfo(_response);
        });
    }

    protected processGetLoginOnBehalfInfo(response: Response): Promise<LoginOnBehalfInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginOnBehalfInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginOnBehalfInfo>(<any>null);
    }

    /**
     * Returns list of stores which user can sign in
     * @return Success
     */
    getUserAllowedStores(userId: string | null): Promise<Store[]> {
        let url_ = this.baseUrl + "/api/stores/allowed/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserAllowedStores(_response);
        });
    }

    protected processGetUserAllowedStores(response: Response): Promise<Store[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Store.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Store[]>(<any>null);
    }
}

export class SubscriptionModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Search subscriptions by given criteria
     * @param body (optional) criteria
     * @return Success
     */
    searchSubscriptions(body: SubscriptionSearchCriteria | undefined): Promise<SubscriptionSearchResult> {
        let url_ = this.baseUrl + "/api/subscriptions/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchSubscriptions(_response);
        });
    }

    protected processSearchSubscriptions(response: Response): Promise<SubscriptionSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubscriptionSearchResult>(<any>null);
    }

    /**
     * @param respGroup (optional) 
     * @return Success
     */
    getSubscriptionById(id: string | null, respGroup: string | null | undefined): Promise<Subscription> {
        let url_ = this.baseUrl + "/api/subscriptions/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSubscriptionById(_response);
        });
    }

    protected processGetSubscriptionById(response: Response): Promise<Subscription> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Subscription.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subscription>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @param respGroup (optional) 
     * @return Success
     */
    getSubscriptionByIds(ids: string[] | null | undefined, respGroup: string | null | undefined): Promise<Subscription[]> {
        let url_ = this.baseUrl + "/api/subscriptions?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        if (respGroup !== undefined && respGroup !== null)
            url_ += "respGroup=" + encodeURIComponent("" + respGroup) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSubscriptionByIds(_response);
        });
    }

    protected processGetSubscriptionByIds(response: Response): Promise<Subscription[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Subscription.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subscription[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubscription(body: Subscription | undefined): Promise<Subscription> {
        let url_ = this.baseUrl + "/api/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSubscription(_response);
        });
    }

    protected processCreateSubscription(response: Response): Promise<Subscription> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Subscription.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subscription>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: Subscription | undefined): Promise<Subscription> {
        let url_ = this.baseUrl + "/api/subscriptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateSubscription(_response);
        });
    }

    protected processUpdateSubscription(response: Response): Promise<Subscription> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Subscription.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subscription>(<any>null);
    }

    /**
     * Delete subscriptions
     * @param ids (optional) subscriptions' ids for delete
     * @return Success
     */
    deleteSubscriptionsByIds(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/subscriptions?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteSubscriptionsByIds(_response);
        });
    }

    protected processDeleteSubscriptionsByIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createReccurentOrderForSubscription(body: Subscription | undefined): Promise<CustomerOrder> {
        let url_ = this.baseUrl + "/api/subscriptions/order";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateReccurentOrderForSubscription(_response);
        });
    }

    protected processCreateReccurentOrderForSubscription(response: Response): Promise<CustomerOrder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerOrder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerOrder>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelSubscription(body: SubscriptionCancelRequest | undefined): Promise<Subscription> {
        let url_ = this.baseUrl + "/api/subscriptions/cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelSubscription(_response);
        });
    }

    protected processCancelSubscription(response: Response): Promise<Subscription> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Subscription.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Subscription>(<any>null);
    }

    /**
     * @return Success
     */
    getPaymentPlanById(id: string | null): Promise<PaymentPlan> {
        let url_ = this.baseUrl + "/api/subscriptions/plans/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaymentPlanById(_response);
        });
    }

    protected processGetPaymentPlanById(response: Response): Promise<PaymentPlan> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentPlan.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentPlan>(<any>null);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    getPaymentPlanByIds(ids: string[] | null | undefined): Promise<PaymentPlan[]> {
        let url_ = this.baseUrl + "/api/subscriptions/plans?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaymentPlanByIds(_response);
        });
    }

    protected processGetPaymentPlanByIds(response: Response): Promise<PaymentPlan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentPlan.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentPlan[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPaymentPlan(body: PaymentPlan | undefined): Promise<PaymentPlan> {
        let url_ = this.baseUrl + "/api/subscriptions/plans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePaymentPlan(_response);
        });
    }

    protected processCreatePaymentPlan(response: Response): Promise<PaymentPlan> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentPlan.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentPlan>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePaymentPlan(body: PaymentPlan | undefined): Promise<PaymentPlan> {
        let url_ = this.baseUrl + "/api/subscriptions/plans";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePaymentPlan(_response);
        });
    }

    protected processUpdatePaymentPlan(response: Response): Promise<PaymentPlan> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentPlan.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentPlan>(<any>null);
    }

    /**
     * Delete payment plans
     * @param ids (optional) plans' ids for delete
     * @return Success
     */
    deletePlansByIds(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/subscriptions/plans?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePlansByIds(_response);
        });
    }

    protected processDeletePlansByIds(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Gets plans by plenty ids
     * @param body (optional) Item ids
     * @return Success
     */
    getPaymentPlansByPlentyIds(body: string[] | null | undefined): Promise<PaymentPlan[]> {
        let url_ = this.baseUrl + "/api/subscriptions/plans/plenty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaymentPlansByPlentyIds(_response);
        });
    }

    protected processGetPaymentPlansByPlentyIds(response: Response): Promise<PaymentPlan[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentPlan.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentPlan[]>(<any>null);
    }
}

export class TaxModuleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchTaxProviders(body: TaxProviderSearchCriteria | undefined): Promise<TaxProviderSearchResult> {
        let url_ = this.baseUrl + "/api/taxes/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchTaxProviders(_response);
        });
    }

    protected processSearchTaxProviders(response: Response): Promise<TaxProviderSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaxProviderSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaxProviderSearchResult>(<any>null);
    }

    /**
     * @return Success
     */
    getTaxProviderById(id: string | null): Promise<TaxProviderSearchResult> {
        let url_ = this.baseUrl + "/api/taxes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTaxProviderById(_response);
        });
    }

    protected processGetTaxProviderById(response: Response): Promise<TaxProviderSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaxProviderSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaxProviderSearchResult>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTaxProvider(body: TaxProvider | undefined): Promise<TaxProvider> {
        let url_ = this.baseUrl + "/api/taxes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateTaxProvider(_response);
        });
    }

    protected processUpdateTaxProvider(response: Response): Promise<TaxProvider> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaxProvider.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaxProvider>(<any>null);
    }

    /**
     * Evaluate and return all tax rates for specified store and evaluation context
     * @param body (optional) 
     * @return Success
     */
    evaluateTaxes(storeId: string | null, body: TaxEvaluationContext | undefined): Promise<TaxRate[]> {
        let url_ = this.baseUrl + "/api/taxes/{storeId}/evaluate";
        if (storeId === undefined || storeId === null)
            throw new Error("The parameter 'storeId' must be defined.");
        url_ = url_.replace("{storeId}", encodeURIComponent("" + storeId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEvaluateTaxes(_response);
        });
    }

    protected processEvaluateTaxes(response: Response): Promise<TaxRate[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaxRate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaxRate[]>(<any>null);
    }
}

export class TenantIdentity implements ITenantIdentity {
    id?: string | undefined;
    type?: string | undefined;
    readonly isEmpty?: boolean;
    readonly isValid?: boolean;

    constructor(data?: ITenantIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            (<any>this).isEmpty = _data["isEmpty"];
            (<any>this).isValid = _data["isValid"];
        }
    }

    static fromJS(data: any): TenantIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new TenantIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["isEmpty"] = this.isEmpty;
        data["isValid"] = this.isValid;
        return data; 
    }
}

export interface ITenantIdentity {
    id?: string | undefined;
    type?: string | undefined;
    isEmpty?: boolean;
    isValid?: boolean;
}

export enum SortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class SortInfo implements ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sortColumn = _data["sortColumn"];
            this.sortDirection = _data["sortDirection"];
        }
    }

    static fromJS(data: any): SortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortColumn"] = this.sortColumn;
        data["sortDirection"] = this.sortDirection;
        return data; 
    }
}

export interface ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortDirection;
}

export class AssetEntrySearchCriteria implements IAssetEntrySearchCriteria {
    tenants?: TenantIdentity[] | undefined;
    group?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IAssetEntrySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tenants"])) {
                this.tenants = [] as any;
                for (let item of _data["tenants"])
                    this.tenants!.push(TenantIdentity.fromJS(item));
            }
            this.group = _data["group"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): AssetEntrySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new AssetEntrySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tenants)) {
            data["tenants"] = [];
            for (let item of this.tenants)
                data["tenants"].push(item.toJSON());
        }
        data["group"] = this.group;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IAssetEntrySearchCriteria {
    tenants?: TenantIdentity[] | undefined;
    group?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class BlobInfo implements IBlobInfo {
    key?: string | undefined;
    size?: number;
    contentType?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IBlobInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.size = _data["size"];
            this.contentType = _data["contentType"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.relativeUrl = _data["relativeUrl"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BlobInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BlobInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["size"] = this.size;
        data["contentType"] = this.contentType;
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["relativeUrl"] = this.relativeUrl;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBlobInfo {
    key?: string | undefined;
    size?: number;
    contentType?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class AssetEntry implements IAssetEntry {
    languageCode?: string | undefined;
    tenant?: TenantIdentity;
    blobInfo?: BlobInfo;
    group?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IAssetEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageCode = _data["languageCode"];
            this.tenant = _data["tenant"] ? TenantIdentity.fromJS(_data["tenant"]) : <any>undefined;
            this.blobInfo = _data["blobInfo"] ? BlobInfo.fromJS(_data["blobInfo"]) : <any>undefined;
            this.group = _data["group"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AssetEntry {
        data = typeof data === 'object' ? data : {};
        let result = new AssetEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageCode"] = this.languageCode;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["blobInfo"] = this.blobInfo ? this.blobInfo.toJSON() : <any>undefined;
        data["group"] = this.group;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetEntry {
    languageCode?: string | undefined;
    tenant?: TenantIdentity;
    blobInfo?: BlobInfo;
    group?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class AssetEntrySearchResult implements IAssetEntrySearchResult {
    totalCount?: number;
    results?: AssetEntry[] | undefined;

    constructor(data?: IAssetEntrySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AssetEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AssetEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new AssetEntrySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAssetEntrySearchResult {
    totalCount?: number;
    results?: AssetEntry[] | undefined;
}

export class BlobEntry implements IBlobEntry {
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IBlobEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.relativeUrl = _data["relativeUrl"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BlobEntry {
        data = typeof data === 'object' ? data : {};
        let result = new BlobEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["relativeUrl"] = this.relativeUrl;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBlobEntry {
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class BlobEntrySearchResult implements IBlobEntrySearchResult {
    totalCount?: number;
    results?: BlobEntry[] | undefined;

    constructor(data?: IBlobEntrySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BlobEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BlobEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new BlobEntrySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBlobEntrySearchResult {
    totalCount?: number;
    results?: BlobEntry[] | undefined;
}

export class BlobFolder implements IBlobFolder {
    parentUrl?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IBlobFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentUrl = _data["parentUrl"];
            this.type = _data["type"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.relativeUrl = _data["relativeUrl"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BlobFolder {
        data = typeof data === 'object' ? data : {};
        let result = new BlobFolder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentUrl"] = this.parentUrl;
        data["type"] = this.type;
        data["name"] = this.name;
        data["url"] = this.url;
        data["relativeUrl"] = this.relativeUrl;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBlobFolder {
    parentUrl?: string | undefined;
    type?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class LastModifiedResponse implements ILastModifiedResponse {
    scope?: string | undefined;
    lastModifiedDate?: Date;

    constructor(data?: ILastModifiedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scope = _data["scope"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LastModifiedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LastModifiedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scope"] = this.scope;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ILastModifiedResponse {
    scope?: string | undefined;
    lastModifiedDate?: Date;
}

export class ChangedEntitiesRequest implements IChangedEntitiesRequest {
    entityNames?: string[] | undefined;
    modifiedSince?: Date;

    constructor(data?: IChangedEntitiesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entityNames"])) {
                this.entityNames = [] as any;
                for (let item of _data["entityNames"])
                    this.entityNames!.push(item);
            }
            this.modifiedSince = _data["modifiedSince"] ? new Date(_data["modifiedSince"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChangedEntitiesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangedEntitiesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entityNames)) {
            data["entityNames"] = [];
            for (let item of this.entityNames)
                data["entityNames"].push(item);
        }
        data["modifiedSince"] = this.modifiedSince ? this.modifiedSince.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IChangedEntitiesRequest {
    entityNames?: string[] | undefined;
    modifiedSince?: Date;
}

export class ChangedEntity implements IChangedEntity {
    name?: string | undefined;
    modifiedDate?: Date;

    constructor(data?: IChangedEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ChangedEntity {
        data = typeof data === 'object' ? data : {};
        let result = new ChangedEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IChangedEntity {
    name?: string | undefined;
    modifiedDate?: Date;
}

export class ChangedEntitiesResponse implements IChangedEntitiesResponse {
    entities?: ChangedEntity[] | undefined;

    constructor(data?: IChangedEntitiesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["entities"])) {
                this.entities = [] as any;
                for (let item of _data["entities"])
                    this.entities!.push(ChangedEntity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChangedEntitiesResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ChangedEntitiesResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.entities)) {
            data["entities"] = [];
            for (let item of this.entities)
                data["entities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChangedEntitiesResponse {
    entities?: ChangedEntity[] | undefined;
}

export enum EntryState {
    Detached = "Detached",
    Unchanged = "Unchanged",
    Added = "Added",
    Deleted = "Deleted",
    Modified = "Modified",
}

export class ChangeLogSearchCriteria implements IChangeLogSearchCriteria {
    operationTypes?: EntryState[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IChangeLogSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["operationTypes"])) {
                this.operationTypes = [] as any;
                for (let item of _data["operationTypes"])
                    this.operationTypes!.push(item);
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ChangeLogSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeLogSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.operationTypes)) {
            data["operationTypes"] = [];
            for (let item of this.operationTypes)
                data["operationTypes"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IChangeLogSearchCriteria {
    operationTypes?: EntryState[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class OperationLog implements IOperationLog {
    objectType?: string | undefined;
    objectId?: string | undefined;
    operationType?: EntryState;
    detail?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOperationLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.objectId = _data["objectId"];
            this.operationType = _data["operationType"];
            this.detail = _data["detail"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OperationLog {
        data = typeof data === 'object' ? data : {};
        let result = new OperationLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["objectId"] = this.objectId;
        data["operationType"] = this.operationType;
        data["detail"] = this.detail;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOperationLog {
    objectType?: string | undefined;
    objectId?: string | undefined;
    operationType?: EntryState;
    detail?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ChangeLogSearchResult implements IChangeLogSearchResult {
    totalCount?: number;
    results?: OperationLog[] | undefined;

    constructor(data?: IChangeLogSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(OperationLog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ChangeLogSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeLogSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IChangeLogSearchResult {
    totalCount?: number;
    results?: OperationLog[] | undefined;
}

export class License implements ILicense {
    type?: string | undefined;
    customerName?: string | undefined;
    customerEmail?: string | undefined;
    expirationDate?: Date;
    rawLicense?: string | undefined;

    constructor(data?: ILicense) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.customerName = _data["customerName"];
            this.customerEmail = _data["customerEmail"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.rawLicense = _data["rawLicense"];
        }
    }

    static fromJS(data: any): License {
        data = typeof data === 'object' ? data : {};
        let result = new License();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["customerName"] = this.customerName;
        data["customerEmail"] = this.customerEmail;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["rawLicense"] = this.rawLicense;
        return data; 
    }
}

export interface ILicense {
    type?: string | undefined;
    customerName?: string | undefined;
    customerEmail?: string | undefined;
    expirationDate?: Date;
    rawLicense?: string | undefined;
}

export class SemanticVersion implements ISemanticVersion {
    readonly major?: number;
    readonly minor?: number;
    readonly patch?: number;
    readonly prerelease?: string | undefined;

    constructor(data?: ISemanticVersion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).major = _data["major"];
            (<any>this).minor = _data["minor"];
            (<any>this).patch = _data["patch"];
            (<any>this).prerelease = _data["prerelease"];
        }
    }

    static fromJS(data: any): SemanticVersion {
        data = typeof data === 'object' ? data : {};
        let result = new SemanticVersion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["major"] = this.major;
        data["minor"] = this.minor;
        data["patch"] = this.patch;
        data["prerelease"] = this.prerelease;
        return data; 
    }
}

export interface ISemanticVersion {
    major?: number;
    minor?: number;
    patch?: number;
    prerelease?: string | undefined;
}

export class ModuleIdentity implements IModuleIdentity {
    id?: string | undefined;
    version?: SemanticVersion;

    constructor(data?: IModuleIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"] ? SemanticVersion.fromJS(_data["version"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModuleIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IModuleIdentity {
    id?: string | undefined;
    version?: SemanticVersion;
}

export class ModuleDescriptor implements IModuleDescriptor {
    version?: string | undefined;
    platformVersion?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    authors?: string[] | undefined;
    owners?: string[] | undefined;
    licenseUrl?: string | undefined;
    projectUrl?: string | undefined;
    iconUrl?: string | undefined;
    requireLicenseAcceptance?: boolean;
    releaseNotes?: string | undefined;
    copyright?: string | undefined;
    tags?: string | undefined;
    groups?: string[] | undefined;
    dependencies?: ModuleIdentity[] | undefined;
    validationErrors?: string[] | undefined;
    isRemovable?: boolean;
    isInstalled?: boolean;
    installedVersion?: ModuleIdentity;
    id?: string | undefined;

    constructor(data?: IModuleDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.platformVersion = _data["platformVersion"];
            this.title = _data["title"];
            this.description = _data["description"];
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(item);
            }
            if (Array.isArray(_data["owners"])) {
                this.owners = [] as any;
                for (let item of _data["owners"])
                    this.owners!.push(item);
            }
            this.licenseUrl = _data["licenseUrl"];
            this.projectUrl = _data["projectUrl"];
            this.iconUrl = _data["iconUrl"];
            this.requireLicenseAcceptance = _data["requireLicenseAcceptance"];
            this.releaseNotes = _data["releaseNotes"];
            this.copyright = _data["copyright"];
            this.tags = _data["tags"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["dependencies"])
                    this.dependencies!.push(ModuleIdentity.fromJS(item));
            }
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
            this.isRemovable = _data["isRemovable"];
            this.isInstalled = _data["isInstalled"];
            this.installedVersion = _data["installedVersion"] ? ModuleIdentity.fromJS(_data["installedVersion"]) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["platformVersion"] = this.platformVersion;
        data["title"] = this.title;
        data["description"] = this.description;
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item);
        }
        if (Array.isArray(this.owners)) {
            data["owners"] = [];
            for (let item of this.owners)
                data["owners"].push(item);
        }
        data["licenseUrl"] = this.licenseUrl;
        data["projectUrl"] = this.projectUrl;
        data["iconUrl"] = this.iconUrl;
        data["requireLicenseAcceptance"] = this.requireLicenseAcceptance;
        data["releaseNotes"] = this.releaseNotes;
        data["copyright"] = this.copyright;
        data["tags"] = this.tags;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.dependencies)) {
            data["dependencies"] = [];
            for (let item of this.dependencies)
                data["dependencies"].push(item.toJSON());
        }
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        data["isRemovable"] = this.isRemovable;
        data["isInstalled"] = this.isInstalled;
        data["installedVersion"] = this.installedVersion ? this.installedVersion.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IModuleDescriptor {
    version?: string | undefined;
    platformVersion?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    authors?: string[] | undefined;
    owners?: string[] | undefined;
    licenseUrl?: string | undefined;
    projectUrl?: string | undefined;
    iconUrl?: string | undefined;
    requireLicenseAcceptance?: boolean;
    releaseNotes?: string | undefined;
    copyright?: string | undefined;
    tags?: string | undefined;
    groups?: string[] | undefined;
    dependencies?: ModuleIdentity[] | undefined;
    validationErrors?: string[] | undefined;
    isRemovable?: boolean;
    isInstalled?: boolean;
    installedVersion?: ModuleIdentity;
    id?: string | undefined;
}

export class SystemInfo implements ISystemInfo {
    platformVersion?: string | undefined;
    license?: License;
    installedModules?: ModuleDescriptor[] | undefined;
    version?: string | undefined;
    is64BitOperatingSystem?: boolean;
    is64BitProcess?: boolean;

    constructor(data?: ISystemInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.platformVersion = _data["platformVersion"];
            this.license = _data["license"] ? License.fromJS(_data["license"]) : <any>undefined;
            if (Array.isArray(_data["installedModules"])) {
                this.installedModules = [] as any;
                for (let item of _data["installedModules"])
                    this.installedModules!.push(ModuleDescriptor.fromJS(item));
            }
            this.version = _data["version"];
            this.is64BitOperatingSystem = _data["is64BitOperatingSystem"];
            this.is64BitProcess = _data["is64BitProcess"];
        }
    }

    static fromJS(data: any): SystemInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SystemInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["platformVersion"] = this.platformVersion;
        data["license"] = this.license ? this.license.toJSON() : <any>undefined;
        if (Array.isArray(this.installedModules)) {
            data["installedModules"] = [];
            for (let item of this.installedModules)
                data["installedModules"].push(item.toJSON());
        }
        data["version"] = this.version;
        data["is64BitOperatingSystem"] = this.is64BitOperatingSystem;
        data["is64BitProcess"] = this.is64BitProcess;
        return data; 
    }
}

export interface ISystemInfo {
    platformVersion?: string | undefined;
    license?: License;
    installedModules?: ModuleDescriptor[] | undefined;
    version?: string | undefined;
    is64BitOperatingSystem?: boolean;
    is64BitProcess?: boolean;
}

export class DynamicPropertySearchCriteria implements IDynamicPropertySearchCriteria {
    readonly typeName?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicPropertySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeName = _data["typeName"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicPropertySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IDynamicPropertySearchCriteria {
    typeName?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export enum DynamicPropertyValueType {
    Undefined = "Undefined",
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Html = "Html",
    Image = "Image",
}

export class DynamicPropertyName implements IDynamicPropertyName {
    locale?: string | undefined;
    name?: string | undefined;

    constructor(data?: IDynamicPropertyName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locale = _data["locale"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DynamicPropertyName {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locale"] = this.locale;
        data["name"] = this.name;
        return data; 
    }
}

export interface IDynamicPropertyName {
    locale?: string | undefined;
    name?: string | undefined;
}

export class DynamicProperty implements IDynamicProperty {
    name?: string | undefined;
    description?: string | undefined;
    objectType?: string | undefined;
    isArray?: boolean;
    isDictionary?: boolean;
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    valueType?: DynamicPropertyValueType;
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.objectType = _data["objectType"];
            this.isArray = _data["isArray"];
            this.isDictionary = _data["isDictionary"];
            this.isMultilingual = _data["isMultilingual"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(DynamicPropertyName.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicProperty {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["objectType"] = this.objectType;
        data["isArray"] = this.isArray;
        data["isDictionary"] = this.isDictionary;
        data["isMultilingual"] = this.isMultilingual;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicProperty {
    name?: string | undefined;
    description?: string | undefined;
    objectType?: string | undefined;
    isArray?: boolean;
    isDictionary?: boolean;
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    valueType?: DynamicPropertyValueType;
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicPropertySearchResult implements IDynamicPropertySearchResult {
    totalCount?: number;
    results?: DynamicProperty[] | undefined;

    constructor(data?: IDynamicPropertySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicProperty.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicPropertySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDynamicPropertySearchResult {
    totalCount?: number;
    results?: DynamicProperty[] | undefined;
}

export class DynamicPropertyObjectValue implements IDynamicPropertyObjectValue {
    objectType?: string | undefined;
    objectId?: string | undefined;
    locale?: string | undefined;
    value?: any | undefined;
    valueId?: string | undefined;
    valueType?: DynamicPropertyValueType;
    propertyId?: string | undefined;
    propertyName?: string | undefined;

    constructor(data?: IDynamicPropertyObjectValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.objectId = _data["objectId"];
            this.locale = _data["locale"];
            this.value = _data["value"];
            this.valueId = _data["valueId"];
            this.valueType = _data["valueType"];
            this.propertyId = _data["propertyId"];
            this.propertyName = _data["propertyName"];
        }
    }

    static fromJS(data: any): DynamicPropertyObjectValue {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyObjectValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["objectId"] = this.objectId;
        data["locale"] = this.locale;
        data["value"] = this.value;
        data["valueId"] = this.valueId;
        data["valueType"] = this.valueType;
        data["propertyId"] = this.propertyId;
        data["propertyName"] = this.propertyName;
        return data; 
    }
}

export interface IDynamicPropertyObjectValue {
    objectType?: string | undefined;
    objectId?: string | undefined;
    locale?: string | undefined;
    value?: any | undefined;
    valueId?: string | undefined;
    valueType?: DynamicPropertyValueType;
    propertyId?: string | undefined;
    propertyName?: string | undefined;
}

export class DynamicObjectProperty implements IDynamicObjectProperty {
    objectId?: string | undefined;
    values?: DynamicPropertyObjectValue[] | undefined;
    name?: string | undefined;
    description?: string | undefined;
    objectType?: string | undefined;
    isArray?: boolean;
    isDictionary?: boolean;
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    valueType?: DynamicPropertyValueType;
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicObjectProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectId = _data["objectId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(DynamicPropertyObjectValue.fromJS(item));
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.objectType = _data["objectType"];
            this.isArray = _data["isArray"];
            this.isDictionary = _data["isDictionary"];
            this.isMultilingual = _data["isMultilingual"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(DynamicPropertyName.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicObjectProperty {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicObjectProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectId"] = this.objectId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["objectType"] = this.objectType;
        data["isArray"] = this.isArray;
        data["isDictionary"] = this.isDictionary;
        data["isMultilingual"] = this.isMultilingual;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicObjectProperty {
    objectId?: string | undefined;
    values?: DynamicPropertyObjectValue[] | undefined;
    name?: string | undefined;
    description?: string | undefined;
    objectType?: string | undefined;
    isArray?: boolean;
    isDictionary?: boolean;
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    valueType?: DynamicPropertyValueType;
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicPropertyDictionaryItemSearchCriteria implements IDynamicPropertyDictionaryItemSearchCriteria {
    propertyId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicPropertyDictionaryItemSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicPropertyDictionaryItemSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDictionaryItemSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IDynamicPropertyDictionaryItemSearchCriteria {
    propertyId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class DynamicPropertyDictionaryItemName implements IDynamicPropertyDictionaryItemName {
    locale?: string | undefined;
    name?: string | undefined;

    constructor(data?: IDynamicPropertyDictionaryItemName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locale = _data["locale"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DynamicPropertyDictionaryItemName {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDictionaryItemName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locale"] = this.locale;
        data["name"] = this.name;
        return data; 
    }
}

export interface IDynamicPropertyDictionaryItemName {
    locale?: string | undefined;
    name?: string | undefined;
}

export class DynamicPropertyDictionaryItem implements IDynamicPropertyDictionaryItem {
    propertyId?: string | undefined;
    name?: string | undefined;
    displayNames?: DynamicPropertyDictionaryItemName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicPropertyDictionaryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.name = _data["name"];
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(DynamicPropertyDictionaryItemName.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyDictionaryItem {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDictionaryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["name"] = this.name;
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicPropertyDictionaryItem {
    propertyId?: string | undefined;
    name?: string | undefined;
    displayNames?: DynamicPropertyDictionaryItemName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicPropertyDictionaryItemSearchResult implements IDynamicPropertyDictionaryItemSearchResult {
    totalCount?: number;
    results?: DynamicPropertyDictionaryItem[] | undefined;

    constructor(data?: IDynamicPropertyDictionaryItemSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicPropertyDictionaryItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicPropertyDictionaryItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDictionaryItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDynamicPropertyDictionaryItemSearchResult {
    totalCount?: number;
    results?: DynamicPropertyDictionaryItem[] | undefined;
}

export class Job implements IJob {
    state?: string | undefined;
    completed?: boolean;
    id?: string | undefined;

    constructor(data?: IJob) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.completed = _data["completed"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Job {
        data = typeof data === 'object' ? data : {};
        let result = new Job();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["completed"] = this.completed;
        data["id"] = this.id;
        return data; 
    }
}

export interface IJob {
    state?: string | undefined;
    completed?: boolean;
    id?: string | undefined;
}

export enum ProgressMessageLevel {
    Info = "Info",
    Warning = "Warning",
    Debug = "Debug",
    Error = "Error",
}

export class ProgressMessage implements IProgressMessage {
    message?: string | undefined;
    level?: ProgressMessageLevel;

    constructor(data?: IProgressMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): ProgressMessage {
        data = typeof data === 'object' ? data : {};
        let result = new ProgressMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["level"] = this.level;
        return data; 
    }
}

export interface IProgressMessage {
    message?: string | undefined;
    level?: ProgressMessageLevel;
}

export class ModulePushNotification implements IModulePushNotification {
    started?: Date | undefined;
    finished?: Date | undefined;
    progressLog?: ProgressMessage[] | undefined;
    readonly errorCount?: number;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IModulePushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            if (Array.isArray(_data["progressLog"])) {
                this.progressLog = [] as any;
                for (let item of _data["progressLog"])
                    this.progressLog!.push(ProgressMessage.fromJS(item));
            }
            (<any>this).errorCount = _data["errorCount"];
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModulePushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ModulePushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        if (Array.isArray(this.progressLog)) {
            data["progressLog"] = [];
            for (let item of this.progressLog)
                data["progressLog"].push(item.toJSON());
        }
        data["errorCount"] = this.errorCount;
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IModulePushNotification {
    started?: Date | undefined;
    finished?: Date | undefined;
    progressLog?: ProgressMessage[] | undefined;
    errorCount?: number;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ModuleAutoInstallPushNotification implements IModuleAutoInstallPushNotification {
    started?: Date | undefined;
    finished?: Date | undefined;
    progressLog?: ProgressMessage[] | undefined;
    readonly errorCount?: number;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IModuleAutoInstallPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.started = _data["started"] ? new Date(_data["started"].toString()) : <any>undefined;
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            if (Array.isArray(_data["progressLog"])) {
                this.progressLog = [] as any;
                for (let item of _data["progressLog"])
                    this.progressLog!.push(ProgressMessage.fromJS(item));
            }
            (<any>this).errorCount = _data["errorCount"];
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ModuleAutoInstallPushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleAutoInstallPushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["started"] = this.started ? this.started.toISOString() : <any>undefined;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        if (Array.isArray(this.progressLog)) {
            data["progressLog"] = [];
            for (let item of this.progressLog)
                data["progressLog"].push(item.toJSON());
        }
        data["errorCount"] = this.errorCount;
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IModuleAutoInstallPushNotification {
    started?: Date | undefined;
    finished?: Date | undefined;
    progressLog?: ProgressMessage[] | undefined;
    errorCount?: number;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export enum JsonValueKind {
    Undefined = "Undefined",
    Object = "Object",
    Array = "Array",
    String = "String",
    Number = "Number",
    True = "True",
    False = "False",
    Null = "Null",
}

export class JsonElement implements IJsonElement {
    valueKind?: JsonValueKind;

    constructor(data?: IJsonElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valueKind = _data["valueKind"];
        }
    }

    static fromJS(data: any): JsonElement {
        data = typeof data === 'object' ? data : {};
        let result = new JsonElement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueKind"] = this.valueKind;
        return data; 
    }
}

export interface IJsonElement {
    valueKind?: JsonValueKind;
}

export class OpenIddictApplicationDescriptor implements IOpenIddictApplicationDescriptor {
    clientId?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    displayName?: string | undefined;
    readonly displayNames?: { [key: string]: string; } | undefined;
    readonly permissions?: string[] | undefined;
    readonly postLogoutRedirectUris?: string[] | undefined;
    readonly properties?: { [key: string]: JsonElement; } | undefined;
    readonly redirectUris?: string[] | undefined;
    readonly requirements?: string[] | undefined;
    type?: string | undefined;

    constructor(data?: IOpenIddictApplicationDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.consentType = _data["consentType"];
            this.displayName = _data["displayName"];
            if (_data["displayNames"]) {
                (<any>this).displayNames = {} as any;
                for (let key in _data["displayNames"]) {
                    if (_data["displayNames"].hasOwnProperty(key))
                        (<any>(<any>this).displayNames)![key] = _data["displayNames"][key];
                }
            }
            if (Array.isArray(_data["permissions"])) {
                (<any>this).permissions = [] as any;
                for (let item of _data["permissions"])
                    (<any>this).permissions!.push(item);
            }
            if (Array.isArray(_data["postLogoutRedirectUris"])) {
                (<any>this).postLogoutRedirectUris = [] as any;
                for (let item of _data["postLogoutRedirectUris"])
                    (<any>this).postLogoutRedirectUris!.push(item);
            }
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key] ? JsonElement.fromJS(_data["properties"][key]) : new JsonElement();
                }
            }
            if (Array.isArray(_data["redirectUris"])) {
                (<any>this).redirectUris = [] as any;
                for (let item of _data["redirectUris"])
                    (<any>this).redirectUris!.push(item);
            }
            if (Array.isArray(_data["requirements"])) {
                (<any>this).requirements = [] as any;
                for (let item of _data["requirements"])
                    (<any>this).requirements!.push(item);
            }
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): OpenIddictApplicationDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new OpenIddictApplicationDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["consentType"] = this.consentType;
        data["displayName"] = this.displayName;
        if (this.displayNames) {
            data["displayNames"] = {};
            for (let key in this.displayNames) {
                if (this.displayNames.hasOwnProperty(key))
                    (<any>data["displayNames"])[key] = this.displayNames[key];
            }
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.postLogoutRedirectUris)) {
            data["postLogoutRedirectUris"] = [];
            for (let item of this.postLogoutRedirectUris)
                data["postLogoutRedirectUris"].push(item);
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.redirectUris)) {
            data["redirectUris"] = [];
            for (let item of this.redirectUris)
                data["redirectUris"].push(item);
        }
        if (Array.isArray(this.requirements)) {
            data["requirements"] = [];
            for (let item of this.requirements)
                data["requirements"].push(item);
        }
        data["type"] = this.type;
        return data; 
    }
}

export interface IOpenIddictApplicationDescriptor {
    clientId?: string | undefined;
    clientSecret?: string | undefined;
    consentType?: string | undefined;
    displayName?: string | undefined;
    displayNames?: { [key: string]: string; } | undefined;
    permissions?: string[] | undefined;
    postLogoutRedirectUris?: string[] | undefined;
    properties?: { [key: string]: JsonElement; } | undefined;
    redirectUris?: string[] | undefined;
    requirements?: string[] | undefined;
    type?: string | undefined;
}

export class OAuthAppSearchCriteria implements IOAuthAppSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IOAuthAppSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): OAuthAppSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthAppSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IOAuthAppSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class OAuthAppSearchResult implements IOAuthAppSearchResult {
    totalCount?: number;
    results?: OpenIddictApplicationDescriptor[] | undefined;

    constructor(data?: IOAuthAppSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(OpenIddictApplicationDescriptor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OAuthAppSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthAppSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOAuthAppSearchResult {
    totalCount?: number;
    results?: OpenIddictApplicationDescriptor[] | undefined;
}

export class PushNotification implements IPushNotification {
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new PushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPushNotification {
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class PushNotificationSearchResult implements IPushNotificationSearchResult {
    totalCount?: number;
    newCount?: number;
    notifyEvents?: PushNotification[] | undefined;

    constructor(data?: IPushNotificationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.newCount = _data["newCount"];
            if (Array.isArray(_data["notifyEvents"])) {
                this.notifyEvents = [] as any;
                for (let item of _data["notifyEvents"])
                    this.notifyEvents!.push(PushNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PushNotificationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PushNotificationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["newCount"] = this.newCount;
        if (Array.isArray(this.notifyEvents)) {
            data["notifyEvents"] = [];
            for (let item of this.notifyEvents)
                data["notifyEvents"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPushNotificationSearchResult {
    totalCount?: number;
    newCount?: number;
    notifyEvents?: PushNotification[] | undefined;
}

export class LoginRequest implements ILoginRequest {
    userName?: string | undefined;
    password?: string | undefined;
    rememberMe?: boolean;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["rememberMe"] = this.rememberMe;
        return data; 
    }
}

export interface ILoginRequest {
    userName?: string | undefined;
    password?: string | undefined;
    rememberMe?: boolean;
}

export class SignInResult implements ISignInResult {
    readonly succeeded?: boolean;
    readonly isLockedOut?: boolean;
    readonly isNotAllowed?: boolean;
    readonly requiresTwoFactor?: boolean;

    constructor(data?: ISignInResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).succeeded = _data["succeeded"];
            (<any>this).isLockedOut = _data["isLockedOut"];
            (<any>this).isNotAllowed = _data["isNotAllowed"];
            (<any>this).requiresTwoFactor = _data["requiresTwoFactor"];
        }
    }

    static fromJS(data: any): SignInResult {
        data = typeof data === 'object' ? data : {};
        let result = new SignInResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["isLockedOut"] = this.isLockedOut;
        data["isNotAllowed"] = this.isNotAllowed;
        data["requiresTwoFactor"] = this.requiresTwoFactor;
        return data; 
    }
}

export interface ISignInResult {
    succeeded?: boolean;
    isLockedOut?: boolean;
    isNotAllowed?: boolean;
    requiresTwoFactor?: boolean;
}

export class UserDetail implements IUserDetail {
    permissions?: string[] | undefined;
    userName?: string | undefined;
    isAdministrator?: boolean;
    passwordExpired?: boolean;
    daysTillPasswordExpiry?: number;
    id?: string | undefined;

    constructor(data?: IUserDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.userName = _data["userName"];
            this.isAdministrator = _data["isAdministrator"];
            this.passwordExpired = _data["passwordExpired"];
            this.daysTillPasswordExpiry = _data["daysTillPasswordExpiry"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDetail {
        data = typeof data === 'object' ? data : {};
        let result = new UserDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["userName"] = this.userName;
        data["isAdministrator"] = this.isAdministrator;
        data["passwordExpired"] = this.passwordExpired;
        data["daysTillPasswordExpiry"] = this.daysTillPasswordExpiry;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserDetail {
    permissions?: string[] | undefined;
    userName?: string | undefined;
    isAdministrator?: boolean;
    passwordExpired?: boolean;
    daysTillPasswordExpiry?: number;
    id?: string | undefined;
}

export class ClaimsIdentity implements IClaimsIdentity {
    authenticationType?: string | undefined;
    readonly isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | undefined;
    claims?: Claim[] | undefined;
    label?: string | undefined;
    readonly name?: string | undefined;
    readonly nameClaimType?: string | undefined;
    readonly roleClaimType?: string | undefined;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationType = _data["authenticationType"];
            (<any>this).isAuthenticated = _data["isAuthenticated"];
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : <any>undefined;
            this.bootstrapContext = _data["bootstrapContext"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.label = _data["label"];
            (<any>this).name = _data["name"];
            (<any>this).nameClaimType = _data["nameClaimType"];
            (<any>this).roleClaimType = _data["roleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["bootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["label"] = this.label;
        data["name"] = this.name;
        data["nameClaimType"] = this.nameClaimType;
        data["roleClaimType"] = this.roleClaimType;
        return data; 
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity;
    bootstrapContext?: any | undefined;
    claims?: Claim[] | undefined;
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string | undefined;
    roleClaimType?: string | undefined;
}

export class Claim implements IClaim {
    issuer?: string | undefined;
    originalIssuer?: string | undefined;
    readonly properties?: { [key: string]: string; } | undefined;
    subject?: ClaimsIdentity;
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.issuer = _data["issuer"];
            this.originalIssuer = _data["originalIssuer"];
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : <any>undefined;
            this.type = _data["type"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["issuer"] = this.issuer;
        data["originalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key];
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data; 
    }
}

export interface IClaim {
    issuer?: string | undefined;
    originalIssuer?: string | undefined;
    properties?: { [key: string]: string; } | undefined;
    subject?: ClaimsIdentity;
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
}

export class PermissionScope implements IPermissionScope {
    type?: string | undefined;
    label?: string | undefined;
    scope?: string | undefined;

    constructor(data?: IPermissionScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.label = _data["label"];
            this.scope = _data["scope"];
        }
    }

    static fromJS(data: any): PermissionScope {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["label"] = this.label;
        data["scope"] = this.scope;
        return data; 
    }
}

export interface IPermissionScope {
    type?: string | undefined;
    label?: string | undefined;
    scope?: string | undefined;
}

export class Permission implements IPermission {
    id?: string | undefined;
    name?: string | undefined;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    assignedScopes?: PermissionScope[] | undefined;
    readonly availableScopes?: PermissionScope[] | undefined;

    constructor(data?: IPermission) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.moduleId = _data["moduleId"];
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["assignedScopes"])) {
                this.assignedScopes = [] as any;
                for (let item of _data["assignedScopes"])
                    this.assignedScopes!.push(PermissionScope.fromJS(item));
            }
            if (Array.isArray(_data["availableScopes"])) {
                (<any>this).availableScopes = [] as any;
                for (let item of _data["availableScopes"])
                    (<any>this).availableScopes!.push(PermissionScope.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Permission {
        data = typeof data === 'object' ? data : {};
        let result = new Permission();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["moduleId"] = this.moduleId;
        data["groupName"] = this.groupName;
        if (Array.isArray(this.assignedScopes)) {
            data["assignedScopes"] = [];
            for (let item of this.assignedScopes)
                data["assignedScopes"].push(item.toJSON());
        }
        if (Array.isArray(this.availableScopes)) {
            data["availableScopes"] = [];
            for (let item of this.availableScopes)
                data["availableScopes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPermission {
    id?: string | undefined;
    name?: string | undefined;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    assignedScopes?: PermissionScope[] | undefined;
    availableScopes?: PermissionScope[] | undefined;
}

export class RoleSearchCriteria implements IRoleSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IRoleSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): RoleSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new RoleSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IRoleSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class Role implements IRole {
    description?: string | undefined;
    permissions?: Permission[] | undefined;
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(Permission.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.normalizedName = _data["normalizedName"];
            this.concurrencyStamp = _data["concurrencyStamp"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["normalizedName"] = this.normalizedName;
        data["concurrencyStamp"] = this.concurrencyStamp;
        return data; 
    }
}

export interface IRole {
    description?: string | undefined;
    permissions?: Permission[] | undefined;
    id?: string | undefined;
    name?: string | undefined;
    normalizedName?: string | undefined;
    concurrencyStamp?: string | undefined;
}

export class RoleSearchResult implements IRoleSearchResult {
    readonly roles?: Role[] | undefined;
    totalCount?: number;
    results?: Role[] | undefined;

    constructor(data?: IRoleSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                (<any>this).roles = [] as any;
                for (let item of _data["roles"])
                    (<any>this).roles!.push(Role.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Role.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new RoleSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRoleSearchResult {
    roles?: Role[] | undefined;
    totalCount?: number;
    results?: Role[] | undefined;
}

export class SecurityResult implements ISecurityResult {
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: ISecurityResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): SecurityResult {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface ISecurityResult {
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class UserSearchCriteria implements IUserSearchCriteria {
    memberId?: string | undefined;
    memberIds?: string[] | undefined;
    modifiedSinceDate?: Date | undefined;
    roles?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IUserSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            if (Array.isArray(_data["memberIds"])) {
                this.memberIds = [] as any;
                for (let item of _data["memberIds"])
                    this.memberIds!.push(item);
            }
            this.modifiedSinceDate = _data["modifiedSinceDate"] ? new Date(_data["modifiedSinceDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): UserSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        if (Array.isArray(this.memberIds)) {
            data["memberIds"] = [];
            for (let item of this.memberIds)
                data["memberIds"].push(item);
        }
        data["modifiedSinceDate"] = this.modifiedSinceDate ? this.modifiedSinceDate.toISOString() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IUserSearchCriteria {
    memberId?: string | undefined;
    memberIds?: string[] | undefined;
    modifiedSinceDate?: Date | undefined;
    roles?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export enum AccountState {
    PendingApproval = "PendingApproval",
    Approved = "Approved",
    Rejected = "Rejected",
}

export class ApplicationUserLogin implements IApplicationUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;

    constructor(data?: IApplicationUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): ApplicationUserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        return data; 
    }
}

export interface IApplicationUserLogin {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
}

export class ApplicationUser implements IApplicationUser {
    storeId?: string | undefined;
    memberId?: string | undefined;
    isAdministrator?: boolean;
    photoUrl?: string | undefined;
    userType?: string | undefined;
    status?: string | undefined;
    password?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    roles?: Role[] | undefined;
    lockoutEndDateUtc?: Date | undefined;
    userState?: AccountState;
    permissions?: string[] | undefined;
    logins?: ApplicationUserLogin[] | undefined;
    passwordExpired?: boolean;
    lastPasswordChangedDate?: Date | undefined;
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.memberId = _data["memberId"];
            this.isAdministrator = _data["isAdministrator"];
            this.photoUrl = _data["photoUrl"];
            this.userType = _data["userType"];
            this.status = _data["status"];
            this.password = _data["password"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? new Date(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.userState = _data["userState"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins!.push(ApplicationUserLogin.fromJS(item));
            }
            this.passwordExpired = _data["passwordExpired"];
            this.lastPasswordChangedDate = _data["lastPasswordChangedDate"] ? new Date(_data["lastPasswordChangedDate"].toString()) : <any>undefined;
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["memberId"] = this.memberId;
        data["isAdministrator"] = this.isAdministrator;
        data["photoUrl"] = this.photoUrl;
        data["userType"] = this.userType;
        data["status"] = this.status;
        data["password"] = this.password;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["userState"] = this.userState;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        data["passwordExpired"] = this.passwordExpired;
        data["lastPasswordChangedDate"] = this.lastPasswordChangedDate ? this.lastPasswordChangedDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data; 
    }
}

export interface IApplicationUser {
    storeId?: string | undefined;
    memberId?: string | undefined;
    isAdministrator?: boolean;
    photoUrl?: string | undefined;
    userType?: string | undefined;
    status?: string | undefined;
    password?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    roles?: Role[] | undefined;
    lockoutEndDateUtc?: Date | undefined;
    userState?: AccountState;
    permissions?: string[] | undefined;
    logins?: ApplicationUserLogin[] | undefined;
    passwordExpired?: boolean;
    lastPasswordChangedDate?: Date | undefined;
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class UserSearchResult implements IUserSearchResult {
    readonly users?: ApplicationUser[] | undefined;
    totalCount?: number;
    results?: ApplicationUser[] | undefined;

    constructor(data?: IUserSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["users"])) {
                (<any>this).users = [] as any;
                for (let item of _data["users"])
                    (<any>this).users!.push(ApplicationUser.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ApplicationUser.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserSearchResult {
    users?: ApplicationUser[] | undefined;
    totalCount?: number;
    results?: ApplicationUser[] | undefined;
}

export class ChangePasswordRequest implements IChangePasswordRequest {
    userName?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IChangePasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordRequest {
    userName?: string | undefined;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class ResetPasswordConfirmRequest implements IResetPasswordConfirmRequest {
    token?: string | undefined;
    newPassword?: string | undefined;
    forcePasswordChangeOnNextSignIn?: boolean;

    constructor(data?: IResetPasswordConfirmRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.newPassword = _data["newPassword"];
            this.forcePasswordChangeOnNextSignIn = _data["forcePasswordChangeOnNextSignIn"];
        }
    }

    static fromJS(data: any): ResetPasswordConfirmRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordConfirmRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["newPassword"] = this.newPassword;
        data["forcePasswordChangeOnNextSignIn"] = this.forcePasswordChangeOnNextSignIn;
        return data; 
    }
}

export interface IResetPasswordConfirmRequest {
    token?: string | undefined;
    newPassword?: string | undefined;
    forcePasswordChangeOnNextSignIn?: boolean;
}

export class ValidatePasswordResetTokenRequest implements IValidatePasswordResetTokenRequest {
    token?: string | undefined;

    constructor(data?: IValidatePasswordResetTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ValidatePasswordResetTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ValidatePasswordResetTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }
}

export interface IValidatePasswordResetTokenRequest {
    token?: string | undefined;
}

export class IdentityError implements IIdentityError {
    code?: string | undefined;
    description?: string | undefined;

    constructor(data?: IIdentityError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): IdentityError {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data; 
    }
}

export interface IIdentityError {
    code?: string | undefined;
    description?: string | undefined;
}

export class IdentityResult implements IIdentityResult {
    readonly succeeded?: boolean;
    readonly errors?: IdentityError[] | undefined;

    constructor(data?: IIdentityResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                (<any>this).errors = [] as any;
                for (let item of _data["errors"])
                    (<any>this).errors!.push(IdentityError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIdentityResult {
    succeeded?: boolean;
    errors?: IdentityError[] | undefined;
}

export class UserLockedResult implements IUserLockedResult {
    locked?: boolean;

    constructor(data?: IUserLockedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locked = _data["locked"];
        }
    }

    static fromJS(data: any): UserLockedResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locked"] = this.locked;
        return data; 
    }
}

export interface IUserLockedResult {
    locked?: boolean;
}

export class UserApiKey implements IUserApiKey {
    apiKey?: string | undefined;
    userName?: string | undefined;
    userId?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IUserApiKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.apiKey = _data["apiKey"];
            this.userName = _data["userName"];
            this.userId = _data["userId"];
            this.isActive = _data["isActive"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserApiKey {
        data = typeof data === 'object' ? data : {};
        let result = new UserApiKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        data["userName"] = this.userName;
        data["userId"] = this.userId;
        data["isActive"] = this.isActive;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserApiKey {
    apiKey?: string | undefined;
    userName?: string | undefined;
    userId?: string | undefined;
    isActive?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export enum SettingValueType {
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    SecureString = "SecureString",
    Json = "Json",
    PositiveInteger = "PositiveInteger",
}

export class ObjectSettingEntry implements IObjectSettingEntry {
    readonly itHasValues?: boolean;
    objectId?: string | undefined;
    objectType?: string | undefined;
    value?: any | undefined;
    restartRequired?: boolean;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    isHidden?: boolean;
    valueType?: SettingValueType;
    allowedValues?: any[] | undefined;
    defaultValue?: any | undefined;
    isDictionary?: boolean;

    constructor(data?: IObjectSettingEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).itHasValues = _data["itHasValues"];
            this.objectId = _data["objectId"];
            this.objectType = _data["objectType"];
            this.value = _data["value"];
            this.restartRequired = _data["restartRequired"];
            this.moduleId = _data["moduleId"];
            this.groupName = _data["groupName"];
            this.name = _data["name"];
            this.isHidden = _data["isHidden"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["allowedValues"])) {
                this.allowedValues = [] as any;
                for (let item of _data["allowedValues"])
                    this.allowedValues!.push(item);
            }
            this.defaultValue = _data["defaultValue"];
            this.isDictionary = _data["isDictionary"];
        }
    }

    static fromJS(data: any): ObjectSettingEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectSettingEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itHasValues"] = this.itHasValues;
        data["objectId"] = this.objectId;
        data["objectType"] = this.objectType;
        data["value"] = this.value;
        data["restartRequired"] = this.restartRequired;
        data["moduleId"] = this.moduleId;
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        data["isHidden"] = this.isHidden;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["defaultValue"] = this.defaultValue;
        data["isDictionary"] = this.isDictionary;
        return data; 
    }
}

export interface IObjectSettingEntry {
    itHasValues?: boolean;
    objectId?: string | undefined;
    objectType?: string | undefined;
    value?: any | undefined;
    restartRequired?: boolean;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    isHidden?: boolean;
    valueType?: SettingValueType;
    allowedValues?: any[] | undefined;
    defaultValue?: any | undefined;
    isDictionary?: boolean;
}

export class IBulkActionFactory implements IIBulkActionFactory {

    constructor(data?: IIBulkActionFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IBulkActionFactory {
        data = typeof data === 'object' ? data : {};
        let result = new IBulkActionFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIBulkActionFactory {
}

export class IDataSourceFactory implements IIDataSourceFactory {

    constructor(data?: IIDataSourceFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IDataSourceFactory {
        data = typeof data === 'object' ? data : {};
        let result = new IDataSourceFactory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIDataSourceFactory {
}

export class IBulkActionProvider implements IIBulkActionProvider {
    applicableTypes?: string[] | undefined;
    bulkActionFactory?: IBulkActionFactory;
    contextTypeName?: string | undefined;
    dataSourceFactory?: IDataSourceFactory;
    name?: string | undefined;
    permissions?: string[] | undefined;

    constructor(data?: IIBulkActionProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["applicableTypes"])) {
                this.applicableTypes = [] as any;
                for (let item of _data["applicableTypes"])
                    this.applicableTypes!.push(item);
            }
            this.bulkActionFactory = _data["bulkActionFactory"] ? IBulkActionFactory.fromJS(_data["bulkActionFactory"]) : <any>undefined;
            this.contextTypeName = _data["contextTypeName"];
            this.dataSourceFactory = _data["dataSourceFactory"] ? IDataSourceFactory.fromJS(_data["dataSourceFactory"]) : <any>undefined;
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): IBulkActionProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IBulkActionProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.applicableTypes)) {
            data["applicableTypes"] = [];
            for (let item of this.applicableTypes)
                data["applicableTypes"].push(item);
        }
        data["bulkActionFactory"] = this.bulkActionFactory ? this.bulkActionFactory.toJSON() : <any>undefined;
        data["contextTypeName"] = this.contextTypeName;
        data["dataSourceFactory"] = this.dataSourceFactory ? this.dataSourceFactory.toJSON() : <any>undefined;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }
}

export interface IIBulkActionProvider {
    applicableTypes?: string[] | undefined;
    bulkActionFactory?: IBulkActionFactory;
    contextTypeName?: string | undefined;
    dataSourceFactory?: IDataSourceFactory;
    name?: string | undefined;
    permissions?: string[] | undefined;
}

export class BulkActionContext implements IBulkActionContext {
    /** Gets or sets the action name. */
    actionName?: string | undefined;
    /** Gets the context type name. */
    readonly contextTypeName?: string | undefined;

    constructor(data?: IBulkActionContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionName = _data["actionName"];
            (<any>this).contextTypeName = _data["contextTypeName"];
        }
    }

    static fromJS(data: any): BulkActionContext {
        data = typeof data === 'object' ? data : {};
        let result = new BulkActionContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionName"] = this.actionName;
        data["contextTypeName"] = this.contextTypeName;
        return data; 
    }
}

export interface IBulkActionContext {
    /** Gets or sets the action name. */
    actionName?: string | undefined;
    /** Gets the context type name. */
    contextTypeName?: string | undefined;
}

export class BulkActionPushNotification implements IBulkActionPushNotification {
    /** Gets error count. */
    readonly errorCount?: number;
    /** Gets or sets the errors. */
    errors?: string[] | undefined;
    /** Gets or sets the finished. */
    finished?: Date | undefined;
    /** Gets or sets the job id. */
    jobId?: string | undefined;
    /** Gets or sets the processed count. */
    processedCount?: number | undefined;
    /** Gets or sets the total count. */
    totalCount?: number | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IBulkActionPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.jobId = _data["jobId"];
            this.processedCount = _data["processedCount"];
            this.totalCount = _data["totalCount"];
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BulkActionPushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new BulkActionPushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["jobId"] = this.jobId;
        data["processedCount"] = this.processedCount;
        data["totalCount"] = this.totalCount;
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBulkActionPushNotification {
    /** Gets error count. */
    errorCount?: number;
    /** Gets or sets the errors. */
    errors?: string[] | undefined;
    /** Gets or sets the finished. */
    finished?: Date | undefined;
    /** Gets or sets the job id. */
    jobId?: string | undefined;
    /** Gets or sets the processed count. */
    processedCount?: number | undefined;
    /** Gets or sets the total count. */
    totalCount?: number | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export enum AddressType {
    Billing = "Billing",
    Shipping = "Shipping",
    BillingAndShipping = "BillingAndShipping",
    Pickup = "Pickup",
}

export class CartAddress implements ICartAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: ICartAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CartAddress {
        data = typeof data === 'object' ? data : {};
        let result = new CartAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data; 
    }
}

export interface ICartAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class IConditionTree implements IIConditionTree {
    readonly id?: string | undefined;
    /** List of all available children for current tree node (is used in expression designer) */
    readonly availableChildren?: IConditionTree[] | undefined;
    readonly children?: IConditionTree[] | undefined;

    constructor(data?: IIConditionTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                (<any>this).availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    (<any>this).availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                (<any>this).children = [] as any;
                for (let item of _data["children"])
                    (<any>this).children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IConditionTree {
        data = typeof data === 'object' ? data : {};
        let result = new IConditionTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIConditionTree {
    id?: string | undefined;
    /** List of all available children for current tree node (is used in expression designer) */
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

export class PriceConditionTree implements IPriceConditionTree {
    all?: boolean;
    not?: boolean;
    readonly id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;

    constructor(data?: IPriceConditionTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.all = _data["all"];
            this.not = _data["not"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                this.availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    this.availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PriceConditionTree {
        data = typeof data === 'object' ? data : {};
        let result = new PriceConditionTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["all"] = this.all;
        data["not"] = this.not;
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPriceConditionTree {
    all?: boolean;
    not?: boolean;
    id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

/** Used to assign pricelist to specific catalog by using conditional expression */
export class PricelistAssignment implements IPricelistAssignment {
    catalogId?: string | undefined;
    pricelistId?: string | undefined;
    pricelist?: Pricelist;
    name?: string | undefined;
    description?: string | undefined;
    /** If two PricelistAssignments satisfies the conditions and rules, will use one with the greater priority */
    priority?: number;
    /** Start of period when Prices Assignment is valid. Null value means no limit */
    startDate?: Date | undefined;
    /** End of period when Prices Assignment is valid. Null value means no limit */
    endDate?: Date | undefined;
    dynamicExpression?: PriceConditionTree;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPricelistAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            this.pricelistId = _data["pricelistId"];
            this.pricelist = _data["pricelist"] ? Pricelist.fromJS(_data["pricelist"]) : <any>undefined;
            this.name = _data["name"];
            this.description = _data["description"];
            this.priority = _data["priority"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.dynamicExpression = _data["dynamicExpression"] ? PriceConditionTree.fromJS(_data["dynamicExpression"]) : <any>undefined;
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PricelistAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new PricelistAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        data["pricelistId"] = this.pricelistId;
        data["pricelist"] = this.pricelist ? this.pricelist.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["description"] = this.description;
        data["priority"] = this.priority;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["dynamicExpression"] = this.dynamicExpression ? this.dynamicExpression.toJSON() : <any>undefined;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

/** Used to assign pricelist to specific catalog by using conditional expression */
export interface IPricelistAssignment {
    catalogId?: string | undefined;
    pricelistId?: string | undefined;
    pricelist?: Pricelist;
    name?: string | undefined;
    description?: string | undefined;
    /** If two PricelistAssignments satisfies the conditions and rules, will use one with the greater priority */
    priority?: number;
    /** Start of period when Prices Assignment is valid. Null value means no limit */
    startDate?: Date | undefined;
    /** End of period when Prices Assignment is valid. Null value means no limit */
    endDate?: Date | undefined;
    dynamicExpression?: PriceConditionTree;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Pricelist implements IPricelist {
    name?: string | undefined;
    description?: string | undefined;
    currency?: string | undefined;
    outerId?: string | undefined;
    prices?: Price[] | undefined;
    assignments?: PricelistAssignment[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPricelist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.currency = _data["currency"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(Price.fromJS(item));
            }
            if (Array.isArray(_data["assignments"])) {
                this.assignments = [] as any;
                for (let item of _data["assignments"])
                    this.assignments!.push(PricelistAssignment.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Pricelist {
        data = typeof data === 'object' ? data : {};
        let result = new Pricelist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["currency"] = this.currency;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        if (Array.isArray(this.assignments)) {
            data["assignments"] = [];
            for (let item of this.assignments)
                data["assignments"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPricelist {
    name?: string | undefined;
    description?: string | undefined;
    currency?: string | undefined;
    outerId?: string | undefined;
    prices?: Price[] | undefined;
    assignments?: PricelistAssignment[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Price implements IPrice {
    pricelistId?: string | undefined;
    pricelist?: Pricelist;
    currency?: string | undefined;
    productId?: string | undefined;
    sale?: number | undefined;
    list?: number;
    minQuantity?: number;
    /** Optional start date for this price, so that we can prepare prices ahead of time.
If start date equals now, this price will be active. */
    startDate?: Date | undefined;
    /** Optional end date for this price, so that we can prepare prices ahead of time.
If end date equals now, this price will not be active. */
    endDate?: Date | undefined;
    readonly effectiveValue?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pricelistId = _data["pricelistId"];
            this.pricelist = _data["pricelist"] ? Pricelist.fromJS(_data["pricelist"]) : <any>undefined;
            this.currency = _data["currency"];
            this.productId = _data["productId"];
            this.sale = _data["sale"];
            this.list = _data["list"];
            this.minQuantity = _data["minQuantity"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            (<any>this).effectiveValue = _data["effectiveValue"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Price {
        data = typeof data === 'object' ? data : {};
        let result = new Price();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pricelistId"] = this.pricelistId;
        data["pricelist"] = this.pricelist ? this.pricelist.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        data["productId"] = this.productId;
        data["sale"] = this.sale;
        data["list"] = this.list;
        data["minQuantity"] = this.minQuantity;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["effectiveValue"] = this.effectiveValue;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPrice {
    pricelistId?: string | undefined;
    pricelist?: Pricelist;
    currency?: string | undefined;
    productId?: string | undefined;
    sale?: number | undefined;
    list?: number;
    minQuantity?: number;
    /** Optional start date for this price, so that we can prepare prices ahead of time.
If start date equals now, this price will be active. */
    startDate?: Date | undefined;
    /** Optional end date for this price, so that we can prepare prices ahead of time.
If end date equals now, this price will not be active. */
    endDate?: Date | undefined;
    effectiveValue?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Discount implements IDiscount {
    promotionId?: string | undefined;
    currency?: string | undefined;
    discountAmount?: number;
    discountAmountWithTax?: number;
    coupon?: string | undefined;
    description?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDiscount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.promotionId = _data["promotionId"];
            this.currency = _data["currency"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.coupon = _data["coupon"];
            this.description = _data["description"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Discount {
        data = typeof data === 'object' ? data : {};
        let result = new Discount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["promotionId"] = this.promotionId;
        data["currency"] = this.currency;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["coupon"] = this.coupon;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDiscount {
    promotionId?: string | undefined;
    currency?: string | undefined;
    discountAmount?: number;
    discountAmountWithTax?: number;
    coupon?: string | undefined;
    description?: string | undefined;
    id?: string | undefined;
}

export class TaxDetail implements ITaxDetail {
    rate?: number;
    amount?: number;
    name?: string | undefined;

    constructor(data?: ITaxDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rate = _data["rate"];
            this.amount = _data["amount"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TaxDetail {
        data = typeof data === 'object' ? data : {};
        let result = new TaxDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rate"] = this.rate;
        data["amount"] = this.amount;
        data["name"] = this.name;
        return data; 
    }
}

export interface ITaxDetail {
    rate?: number;
    amount?: number;
    name?: string | undefined;
}

export class CartLineItem implements ICartLineItem {
    productId?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    sku?: string | undefined;
    productType?: string | undefined;
    name?: string | undefined;
    quantity?: number;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    fulfillmentLocationCode?: string | undefined;
    shipmentMethodCode?: string | undefined;
    requiredShipping?: boolean;
    thumbnailImageUrl?: string | undefined;
    imageUrl?: string | undefined;
    isGift?: boolean;
    currency?: string | undefined;
    languageCode?: string | undefined;
    note?: string | undefined;
    isReccuring?: boolean;
    taxIncluded?: boolean;
    volumetricWeight?: number | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    validationType?: string | undefined;
    isReadOnly?: boolean;
    priceId?: string | undefined;
    price?: Price;
    listPrice?: number;
    listPriceWithTax?: number;
    salePrice?: number;
    salePriceWithTax?: number;
    placedPrice?: number;
    placedPriceWithTax?: number;
    extendedPrice?: number;
    extendedPriceWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    discounts?: Discount[] | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICartLineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.sku = _data["sku"];
            this.productType = _data["productType"];
            this.name = _data["name"];
            this.quantity = _data["quantity"];
            this.fulfillmentCenterId = _data["fulfillmentCenterId"];
            this.fulfillmentCenterName = _data["fulfillmentCenterName"];
            this.fulfillmentLocationCode = _data["fulfillmentLocationCode"];
            this.shipmentMethodCode = _data["shipmentMethodCode"];
            this.requiredShipping = _data["requiredShipping"];
            this.thumbnailImageUrl = _data["thumbnailImageUrl"];
            this.imageUrl = _data["imageUrl"];
            this.isGift = _data["isGift"];
            this.currency = _data["currency"];
            this.languageCode = _data["languageCode"];
            this.note = _data["note"];
            this.isReccuring = _data["isReccuring"];
            this.taxIncluded = _data["taxIncluded"];
            this.volumetricWeight = _data["volumetricWeight"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.validationType = _data["validationType"];
            this.isReadOnly = _data["isReadOnly"];
            this.priceId = _data["priceId"];
            this.price = _data["price"] ? Price.fromJS(_data["price"]) : <any>undefined;
            this.listPrice = _data["listPrice"];
            this.listPriceWithTax = _data["listPriceWithTax"];
            this.salePrice = _data["salePrice"];
            this.salePriceWithTax = _data["salePriceWithTax"];
            this.placedPrice = _data["placedPrice"];
            this.placedPriceWithTax = _data["placedPriceWithTax"];
            this.extendedPrice = _data["extendedPrice"];
            this.extendedPriceWithTax = _data["extendedPriceWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.discountTotal = _data["discountTotal"];
            this.discountTotalWithTax = _data["discountTotalWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CartLineItem {
        data = typeof data === 'object' ? data : {};
        let result = new CartLineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["sku"] = this.sku;
        data["productType"] = this.productType;
        data["name"] = this.name;
        data["quantity"] = this.quantity;
        data["fulfillmentCenterId"] = this.fulfillmentCenterId;
        data["fulfillmentCenterName"] = this.fulfillmentCenterName;
        data["fulfillmentLocationCode"] = this.fulfillmentLocationCode;
        data["shipmentMethodCode"] = this.shipmentMethodCode;
        data["requiredShipping"] = this.requiredShipping;
        data["thumbnailImageUrl"] = this.thumbnailImageUrl;
        data["imageUrl"] = this.imageUrl;
        data["isGift"] = this.isGift;
        data["currency"] = this.currency;
        data["languageCode"] = this.languageCode;
        data["note"] = this.note;
        data["isReccuring"] = this.isReccuring;
        data["taxIncluded"] = this.taxIncluded;
        data["volumetricWeight"] = this.volumetricWeight;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["validationType"] = this.validationType;
        data["isReadOnly"] = this.isReadOnly;
        data["priceId"] = this.priceId;
        data["price"] = this.price ? this.price.toJSON() : <any>undefined;
        data["listPrice"] = this.listPrice;
        data["listPriceWithTax"] = this.listPriceWithTax;
        data["salePrice"] = this.salePrice;
        data["salePriceWithTax"] = this.salePriceWithTax;
        data["placedPrice"] = this.placedPrice;
        data["placedPriceWithTax"] = this.placedPriceWithTax;
        data["extendedPrice"] = this.extendedPrice;
        data["extendedPriceWithTax"] = this.extendedPriceWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["discountTotal"] = this.discountTotal;
        data["discountTotalWithTax"] = this.discountTotalWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICartLineItem {
    productId?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    sku?: string | undefined;
    productType?: string | undefined;
    name?: string | undefined;
    quantity?: number;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    fulfillmentLocationCode?: string | undefined;
    shipmentMethodCode?: string | undefined;
    requiredShipping?: boolean;
    thumbnailImageUrl?: string | undefined;
    imageUrl?: string | undefined;
    isGift?: boolean;
    currency?: string | undefined;
    languageCode?: string | undefined;
    note?: string | undefined;
    isReccuring?: boolean;
    taxIncluded?: boolean;
    volumetricWeight?: number | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    validationType?: string | undefined;
    isReadOnly?: boolean;
    priceId?: string | undefined;
    price?: Price;
    listPrice?: number;
    listPriceWithTax?: number;
    salePrice?: number;
    salePriceWithTax?: number;
    placedPrice?: number;
    placedPriceWithTax?: number;
    extendedPrice?: number;
    extendedPriceWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    discounts?: Discount[] | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Payment implements IPayment {
    currency?: string | undefined;
    paymentGatewayCode?: string | undefined;
    amount?: number;
    billingAddress?: CartAddress;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"];
            this.paymentGatewayCode = _data["paymentGatewayCode"];
            this.amount = _data["amount"];
            this.billingAddress = _data["billingAddress"] ? CartAddress.fromJS(_data["billingAddress"]) : <any>undefined;
            this.price = _data["price"];
            this.priceWithTax = _data["priceWithTax"];
            this.total = _data["total"];
            this.totalWithTax = _data["totalWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Payment {
        data = typeof data === 'object' ? data : {};
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["paymentGatewayCode"] = this.paymentGatewayCode;
        data["amount"] = this.amount;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["total"] = this.total;
        data["totalWithTax"] = this.totalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPayment {
    currency?: string | undefined;
    paymentGatewayCode?: string | undefined;
    amount?: number;
    billingAddress?: CartAddress;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CartShipmentItem implements ICartShipmentItem {
    lineItemId?: string | undefined;
    lineItem?: CartLineItem;
    barCode?: string | undefined;
    quantity?: number;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICartShipmentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lineItemId = _data["lineItemId"];
            this.lineItem = _data["lineItem"] ? CartLineItem.fromJS(_data["lineItem"]) : <any>undefined;
            this.barCode = _data["barCode"];
            this.quantity = _data["quantity"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CartShipmentItem {
        data = typeof data === 'object' ? data : {};
        let result = new CartShipmentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineItemId"] = this.lineItemId;
        data["lineItem"] = this.lineItem ? this.lineItem.toJSON() : <any>undefined;
        data["barCode"] = this.barCode;
        data["quantity"] = this.quantity;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICartShipmentItem {
    lineItemId?: string | undefined;
    lineItem?: CartLineItem;
    barCode?: string | undefined;
    quantity?: number;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CartShipment implements ICartShipment {
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    warehouseLocation?: string | undefined;
    currency?: string | undefined;
    volumetricWeight?: number | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    deliveryAddress?: CartAddress;
    items?: CartShipmentItem[] | undefined;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICartShipment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shipmentMethodCode = _data["shipmentMethodCode"];
            this.shipmentMethodOption = _data["shipmentMethodOption"];
            this.fulfillmentCenterId = _data["fulfillmentCenterId"];
            this.fulfillmentCenterName = _data["fulfillmentCenterName"];
            this.warehouseLocation = _data["warehouseLocation"];
            this.currency = _data["currency"];
            this.volumetricWeight = _data["volumetricWeight"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.price = _data["price"];
            this.priceWithTax = _data["priceWithTax"];
            this.total = _data["total"];
            this.totalWithTax = _data["totalWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            this.deliveryAddress = _data["deliveryAddress"] ? CartAddress.fromJS(_data["deliveryAddress"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CartShipmentItem.fromJS(item));
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CartShipment {
        data = typeof data === 'object' ? data : {};
        let result = new CartShipment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shipmentMethodCode"] = this.shipmentMethodCode;
        data["shipmentMethodOption"] = this.shipmentMethodOption;
        data["fulfillmentCenterId"] = this.fulfillmentCenterId;
        data["fulfillmentCenterName"] = this.fulfillmentCenterName;
        data["warehouseLocation"] = this.warehouseLocation;
        data["currency"] = this.currency;
        data["volumetricWeight"] = this.volumetricWeight;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["total"] = this.total;
        data["totalWithTax"] = this.totalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        data["deliveryAddress"] = this.deliveryAddress ? this.deliveryAddress.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICartShipment {
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    warehouseLocation?: string | undefined;
    currency?: string | undefined;
    volumetricWeight?: number | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    deliveryAddress?: CartAddress;
    items?: CartShipmentItem[] | undefined;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ShoppingCart implements IShoppingCart {
    name?: string | undefined;
    storeId?: string | undefined;
    channelId?: string | undefined;
    isAnonymous?: boolean;
    customerId?: string | undefined;
    customerName?: string | undefined;
    organizationId?: string | undefined;
    currency?: string | undefined;
    languageCode?: string | undefined;
    taxIncluded?: boolean | undefined;
    isRecuring?: boolean | undefined;
    comment?: string | undefined;
    status?: string | undefined;
    purchaseOrderNumber?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    validationType?: string | undefined;
    type?: string | undefined;
    volumetricWeight?: number | undefined;
    total?: number;
    subTotal?: number;
    subTotalWithTax?: number;
    subTotalDiscount?: number;
    subTotalDiscountWithTax?: number;
    shippingTotal?: number;
    shippingTotalWithTax?: number;
    shippingSubTotal?: number;
    shippingSubTotalWithTax?: number;
    shippingDiscountTotal?: number;
    shippingDiscountTotalWithTax?: number;
    paymentTotal?: number;
    paymentTotalWithTax?: number;
    paymentSubTotal?: number;
    paymentSubTotalWithTax?: number;
    paymentDiscountTotal?: number;
    paymentDiscountTotalWithTax?: number;
    handlingTotal?: number;
    handlingTotalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    feeTotal?: number;
    feeTotalWithTax?: number;
    addresses?: CartAddress[] | undefined;
    items?: CartLineItem[] | undefined;
    payments?: Payment[] | undefined;
    shipments?: CartShipment[] | undefined;
    coupons?: string[] | undefined;
    coupon?: string | undefined;
    discounts?: Discount[] | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IShoppingCart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.storeId = _data["storeId"];
            this.channelId = _data["channelId"];
            this.isAnonymous = _data["isAnonymous"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.organizationId = _data["organizationId"];
            this.currency = _data["currency"];
            this.languageCode = _data["languageCode"];
            this.taxIncluded = _data["taxIncluded"];
            this.isRecuring = _data["isRecuring"];
            this.comment = _data["comment"];
            this.status = _data["status"];
            this.purchaseOrderNumber = _data["purchaseOrderNumber"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.validationType = _data["validationType"];
            this.type = _data["type"];
            this.volumetricWeight = _data["volumetricWeight"];
            this.total = _data["total"];
            this.subTotal = _data["subTotal"];
            this.subTotalWithTax = _data["subTotalWithTax"];
            this.subTotalDiscount = _data["subTotalDiscount"];
            this.subTotalDiscountWithTax = _data["subTotalDiscountWithTax"];
            this.shippingTotal = _data["shippingTotal"];
            this.shippingTotalWithTax = _data["shippingTotalWithTax"];
            this.shippingSubTotal = _data["shippingSubTotal"];
            this.shippingSubTotalWithTax = _data["shippingSubTotalWithTax"];
            this.shippingDiscountTotal = _data["shippingDiscountTotal"];
            this.shippingDiscountTotalWithTax = _data["shippingDiscountTotalWithTax"];
            this.paymentTotal = _data["paymentTotal"];
            this.paymentTotalWithTax = _data["paymentTotalWithTax"];
            this.paymentSubTotal = _data["paymentSubTotal"];
            this.paymentSubTotalWithTax = _data["paymentSubTotalWithTax"];
            this.paymentDiscountTotal = _data["paymentDiscountTotal"];
            this.paymentDiscountTotalWithTax = _data["paymentDiscountTotalWithTax"];
            this.handlingTotal = _data["handlingTotal"];
            this.handlingTotalWithTax = _data["handlingTotalWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.discountTotal = _data["discountTotal"];
            this.discountTotalWithTax = _data["discountTotalWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            this.feeTotal = _data["feeTotal"];
            this.feeTotalWithTax = _data["feeTotalWithTax"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CartAddress.fromJS(item));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CartLineItem.fromJS(item));
            }
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments!.push(Payment.fromJS(item));
            }
            if (Array.isArray(_data["shipments"])) {
                this.shipments = [] as any;
                for (let item of _data["shipments"])
                    this.shipments!.push(CartShipment.fromJS(item));
            }
            if (Array.isArray(_data["coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["coupons"])
                    this.coupons!.push(item);
            }
            this.coupon = _data["coupon"];
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShoppingCart {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["storeId"] = this.storeId;
        data["channelId"] = this.channelId;
        data["isAnonymous"] = this.isAnonymous;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["organizationId"] = this.organizationId;
        data["currency"] = this.currency;
        data["languageCode"] = this.languageCode;
        data["taxIncluded"] = this.taxIncluded;
        data["isRecuring"] = this.isRecuring;
        data["comment"] = this.comment;
        data["status"] = this.status;
        data["purchaseOrderNumber"] = this.purchaseOrderNumber;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["validationType"] = this.validationType;
        data["type"] = this.type;
        data["volumetricWeight"] = this.volumetricWeight;
        data["total"] = this.total;
        data["subTotal"] = this.subTotal;
        data["subTotalWithTax"] = this.subTotalWithTax;
        data["subTotalDiscount"] = this.subTotalDiscount;
        data["subTotalDiscountWithTax"] = this.subTotalDiscountWithTax;
        data["shippingTotal"] = this.shippingTotal;
        data["shippingTotalWithTax"] = this.shippingTotalWithTax;
        data["shippingSubTotal"] = this.shippingSubTotal;
        data["shippingSubTotalWithTax"] = this.shippingSubTotalWithTax;
        data["shippingDiscountTotal"] = this.shippingDiscountTotal;
        data["shippingDiscountTotalWithTax"] = this.shippingDiscountTotalWithTax;
        data["paymentTotal"] = this.paymentTotal;
        data["paymentTotalWithTax"] = this.paymentTotalWithTax;
        data["paymentSubTotal"] = this.paymentSubTotal;
        data["paymentSubTotalWithTax"] = this.paymentSubTotalWithTax;
        data["paymentDiscountTotal"] = this.paymentDiscountTotal;
        data["paymentDiscountTotalWithTax"] = this.paymentDiscountTotalWithTax;
        data["handlingTotal"] = this.handlingTotal;
        data["handlingTotalWithTax"] = this.handlingTotalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["discountTotal"] = this.discountTotal;
        data["discountTotalWithTax"] = this.discountTotalWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        data["feeTotal"] = this.feeTotal;
        data["feeTotalWithTax"] = this.feeTotalWithTax;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        if (Array.isArray(this.shipments)) {
            data["shipments"] = [];
            for (let item of this.shipments)
                data["shipments"].push(item.toJSON());
        }
        if (Array.isArray(this.coupons)) {
            data["coupons"] = [];
            for (let item of this.coupons)
                data["coupons"].push(item);
        }
        data["coupon"] = this.coupon;
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IShoppingCart {
    name?: string | undefined;
    storeId?: string | undefined;
    channelId?: string | undefined;
    isAnonymous?: boolean;
    customerId?: string | undefined;
    customerName?: string | undefined;
    organizationId?: string | undefined;
    currency?: string | undefined;
    languageCode?: string | undefined;
    taxIncluded?: boolean | undefined;
    isRecuring?: boolean | undefined;
    comment?: string | undefined;
    status?: string | undefined;
    purchaseOrderNumber?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    validationType?: string | undefined;
    type?: string | undefined;
    volumetricWeight?: number | undefined;
    total?: number;
    subTotal?: number;
    subTotalWithTax?: number;
    subTotalDiscount?: number;
    subTotalDiscountWithTax?: number;
    shippingTotal?: number;
    shippingTotalWithTax?: number;
    shippingSubTotal?: number;
    shippingSubTotalWithTax?: number;
    shippingDiscountTotal?: number;
    shippingDiscountTotalWithTax?: number;
    paymentTotal?: number;
    paymentTotalWithTax?: number;
    paymentSubTotal?: number;
    paymentSubTotalWithTax?: number;
    paymentDiscountTotal?: number;
    paymentDiscountTotalWithTax?: number;
    handlingTotal?: number;
    handlingTotalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    feeTotal?: number;
    feeTotalWithTax?: number;
    addresses?: CartAddress[] | undefined;
    items?: CartLineItem[] | undefined;
    payments?: Payment[] | undefined;
    shipments?: CartShipment[] | undefined;
    coupons?: string[] | undefined;
    coupon?: string | undefined;
    discounts?: Discount[] | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ShippingMethod implements IShippingMethod {
    code?: string | undefined;
    readonly name?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    taxType?: string | undefined;
    storeId?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    readonly typeName?: string | undefined;
    id?: string | undefined;

    constructor(data?: IShippingMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            (<any>this).name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.isActive = _data["isActive"];
            this.priority = _data["priority"];
            this.taxType = _data["taxType"];
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            (<any>this).typeName = _data["typeName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShippingMethod {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["isActive"] = this.isActive;
        data["priority"] = this.priority;
        data["taxType"] = this.taxType;
        data["storeId"] = this.storeId;
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["typeName"] = this.typeName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IShippingMethod {
    code?: string | undefined;
    name?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    taxType?: string | undefined;
    storeId?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    typeName?: string | undefined;
    id?: string | undefined;
}

export class ShippingRate implements IShippingRate {
    optionName?: string | undefined;
    optionDescription?: string | undefined;
    rate?: number;
    rateWithTax?: number;
    currency?: string | undefined;
    discountAmount?: number;
    discountAmountWithTax?: number;
    shippingMethod?: ShippingMethod;

    constructor(data?: IShippingRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.optionName = _data["optionName"];
            this.optionDescription = _data["optionDescription"];
            this.rate = _data["rate"];
            this.rateWithTax = _data["rateWithTax"];
            this.currency = _data["currency"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.shippingMethod = _data["shippingMethod"] ? ShippingMethod.fromJS(_data["shippingMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ShippingRate {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["optionName"] = this.optionName;
        data["optionDescription"] = this.optionDescription;
        data["rate"] = this.rate;
        data["rateWithTax"] = this.rateWithTax;
        data["currency"] = this.currency;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["shippingMethod"] = this.shippingMethod ? this.shippingMethod.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IShippingRate {
    optionName?: string | undefined;
    optionDescription?: string | undefined;
    rate?: number;
    rateWithTax?: number;
    currency?: string | undefined;
    discountAmount?: number;
    discountAmountWithTax?: number;
    shippingMethod?: ShippingMethod;
}

export class ShippingEvaluationContext implements IShippingEvaluationContext {
    shoppingCart?: ShoppingCart;
    currency?: string | undefined;

    constructor(data?: IShippingEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shoppingCart = _data["shoppingCart"] ? ShoppingCart.fromJS(_data["shoppingCart"]) : <any>undefined;
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): ShippingEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shoppingCart"] = this.shoppingCart ? this.shoppingCart.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        return data; 
    }
}

export interface IShippingEvaluationContext {
    shoppingCart?: ShoppingCart;
    currency?: string | undefined;
}

export enum PaymentMethodType {
    Unknown = "Unknown",
    Standard = "Standard",
    Redirection = "Redirection",
    PreparedForm = "PreparedForm",
}

export enum PaymentMethodGroupType {
    Paypal = "Paypal",
    BankCard = "BankCard",
    Alternative = "Alternative",
    Manual = "Manual",
}

export class PaymentMethod implements IPaymentMethod {
    code?: string | undefined;
    readonly name?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    isAvailableForPartial?: boolean;
    currency?: string | undefined;
    price?: number;
    readonly priceWithTax?: number;
    readonly total?: number;
    readonly totalWithTax?: number;
    discountAmount?: number;
    readonly discountAmountWithTax?: number;
    storeId?: string | undefined;
    readonly typeName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    taxType?: string | undefined;
    readonly taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    paymentMethodType?: PaymentMethodType;
    paymentMethodGroupType?: PaymentMethodGroupType;
    id?: string | undefined;

    constructor(data?: IPaymentMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            (<any>this).name = _data["name"];
            this.logoUrl = _data["logoUrl"];
            this.isActive = _data["isActive"];
            this.priority = _data["priority"];
            this.isAvailableForPartial = _data["isAvailableForPartial"];
            this.currency = _data["currency"];
            this.price = _data["price"];
            (<any>this).priceWithTax = _data["priceWithTax"];
            (<any>this).total = _data["total"];
            (<any>this).totalWithTax = _data["totalWithTax"];
            this.discountAmount = _data["discountAmount"];
            (<any>this).discountAmountWithTax = _data["discountAmountWithTax"];
            this.storeId = _data["storeId"];
            (<any>this).typeName = _data["typeName"];
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            this.taxType = _data["taxType"];
            (<any>this).taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            this.paymentMethodType = _data["paymentMethodType"];
            this.paymentMethodGroupType = _data["paymentMethodGroupType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentMethod {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["logoUrl"] = this.logoUrl;
        data["isActive"] = this.isActive;
        data["priority"] = this.priority;
        data["isAvailableForPartial"] = this.isAvailableForPartial;
        data["currency"] = this.currency;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["total"] = this.total;
        data["totalWithTax"] = this.totalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["storeId"] = this.storeId;
        data["typeName"] = this.typeName;
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["paymentMethodType"] = this.paymentMethodType;
        data["paymentMethodGroupType"] = this.paymentMethodGroupType;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaymentMethod {
    code?: string | undefined;
    name?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    isAvailableForPartial?: boolean;
    currency?: string | undefined;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    storeId?: string | undefined;
    typeName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    paymentMethodType?: PaymentMethodType;
    paymentMethodGroupType?: PaymentMethodGroupType;
    id?: string | undefined;
}

export class ShoppingCartSearchCriteria implements IShoppingCartSearchCriteria {
    name?: string | undefined;
    customerId?: string | undefined;
    storeId?: string | undefined;
    currency?: string | undefined;
    status?: string | undefined;
    type?: string | undefined;
    customerIds?: string[] | undefined;
    organizationId?: string | undefined;
    createdStartDate?: Date | undefined;
    createdEndDate?: Date | undefined;
    modifiedStartDate?: Date | undefined;
    modifiedEndDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IShoppingCartSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.customerId = _data["customerId"];
            this.storeId = _data["storeId"];
            this.currency = _data["currency"];
            this.status = _data["status"];
            this.type = _data["type"];
            if (Array.isArray(_data["customerIds"])) {
                this.customerIds = [] as any;
                for (let item of _data["customerIds"])
                    this.customerIds!.push(item);
            }
            this.organizationId = _data["organizationId"];
            this.createdStartDate = _data["createdStartDate"] ? new Date(_data["createdStartDate"].toString()) : <any>undefined;
            this.createdEndDate = _data["createdEndDate"] ? new Date(_data["createdEndDate"].toString()) : <any>undefined;
            this.modifiedStartDate = _data["modifiedStartDate"] ? new Date(_data["modifiedStartDate"].toString()) : <any>undefined;
            this.modifiedEndDate = _data["modifiedEndDate"] ? new Date(_data["modifiedEndDate"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ShoppingCartSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["customerId"] = this.customerId;
        data["storeId"] = this.storeId;
        data["currency"] = this.currency;
        data["status"] = this.status;
        data["type"] = this.type;
        if (Array.isArray(this.customerIds)) {
            data["customerIds"] = [];
            for (let item of this.customerIds)
                data["customerIds"].push(item);
        }
        data["organizationId"] = this.organizationId;
        data["createdStartDate"] = this.createdStartDate ? this.createdStartDate.toISOString() : <any>undefined;
        data["createdEndDate"] = this.createdEndDate ? this.createdEndDate.toISOString() : <any>undefined;
        data["modifiedStartDate"] = this.modifiedStartDate ? this.modifiedStartDate.toISOString() : <any>undefined;
        data["modifiedEndDate"] = this.modifiedEndDate ? this.modifiedEndDate.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IShoppingCartSearchCriteria {
    name?: string | undefined;
    customerId?: string | undefined;
    storeId?: string | undefined;
    currency?: string | undefined;
    status?: string | undefined;
    type?: string | undefined;
    customerIds?: string[] | undefined;
    organizationId?: string | undefined;
    createdStartDate?: Date | undefined;
    createdEndDate?: Date | undefined;
    modifiedStartDate?: Date | undefined;
    modifiedEndDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ShoppingCartSearchResult implements IShoppingCartSearchResult {
    totalCount?: number;
    results?: ShoppingCart[] | undefined;

    constructor(data?: IShoppingCartSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ShoppingCart.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShoppingCartSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IShoppingCartSearchResult {
    totalCount?: number;
    results?: ShoppingCart[] | undefined;
}

export class SeoInfo implements ISeoInfo {
    name?: string | undefined;
    /** Slug */
    semanticUrl?: string | undefined;
    /** head title tag content */
    pageTitle?: string | undefined;
    /** <meta name="description" /> */
    metaDescription?: string | undefined;
    imageAltDescription?: string | undefined;
    /** <meta name="keywords" /> */
    metaKeywords?: string | undefined;
    /** Tenant StoreId which SEO defined */
    storeId?: string | undefined;
    /** SEO related object id */
    objectId?: string | undefined;
    /** SEO related object type name */
    objectType?: string | undefined;
    /** Active/Inactive */
    isActive?: boolean;
    languageCode?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISeoInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.semanticUrl = _data["semanticUrl"];
            this.pageTitle = _data["pageTitle"];
            this.metaDescription = _data["metaDescription"];
            this.imageAltDescription = _data["imageAltDescription"];
            this.metaKeywords = _data["metaKeywords"];
            this.storeId = _data["storeId"];
            this.objectId = _data["objectId"];
            this.objectType = _data["objectType"];
            this.isActive = _data["isActive"];
            this.languageCode = _data["languageCode"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SeoInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SeoInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["semanticUrl"] = this.semanticUrl;
        data["pageTitle"] = this.pageTitle;
        data["metaDescription"] = this.metaDescription;
        data["imageAltDescription"] = this.imageAltDescription;
        data["metaKeywords"] = this.metaKeywords;
        data["storeId"] = this.storeId;
        data["objectId"] = this.objectId;
        data["objectType"] = this.objectType;
        data["isActive"] = this.isActive;
        data["languageCode"] = this.languageCode;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISeoInfo {
    name?: string | undefined;
    /** Slug */
    semanticUrl?: string | undefined;
    /** head title tag content */
    pageTitle?: string | undefined;
    /** <meta name="description" /> */
    metaDescription?: string | undefined;
    imageAltDescription?: string | undefined;
    /** <meta name="keywords" /> */
    metaKeywords?: string | undefined;
    /** Tenant StoreId which SEO defined */
    storeId?: string | undefined;
    /** SEO related object id */
    objectId?: string | undefined;
    /** SEO related object type name */
    objectType?: string | undefined;
    /** Active/Inactive */
    isActive?: boolean;
    languageCode?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Image implements IImage {
    binaryData?: string | undefined;
    altText?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    /** Gets or sets the asset type identifier. */
    typeId?: string | undefined;
    /** Gets or sets the asset group name. */
    group?: string | undefined;
    /** Gets or sets the asset name. */
    name?: string | undefined;
    outerId?: string | undefined;
    /** Gets or sets the asset language. */
    languageCode?: string | undefined;
    /** System flag used to mark that object was inherited from other */
    readonly isInherited?: boolean;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.binaryData = _data["binaryData"];
            this.altText = _data["altText"];
            this.relativeUrl = _data["relativeUrl"];
            this.url = _data["url"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.typeId = _data["typeId"];
            this.group = _data["group"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.languageCode = _data["languageCode"];
            (<any>this).isInherited = _data["isInherited"];
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Image {
        data = typeof data === 'object' ? data : {};
        let result = new Image();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["binaryData"] = this.binaryData;
        data["altText"] = this.altText;
        data["relativeUrl"] = this.relativeUrl;
        data["url"] = this.url;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["typeId"] = this.typeId;
        data["group"] = this.group;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IImage {
    binaryData?: string | undefined;
    altText?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    /** Gets or sets the asset type identifier. */
    typeId?: string | undefined;
    /** Gets or sets the asset group name. */
    group?: string | undefined;
    /** Gets or sets the asset name. */
    name?: string | undefined;
    outerId?: string | undefined;
    /** Gets or sets the asset language. */
    languageCode?: string | undefined;
    /** System flag used to mark that object was inherited from other */
    isInherited?: boolean;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ProductAssociation implements IProductAssociation {
    /** Association type (Accessories, Up-Sales, Cross-Sales, Related etc) */
    type?: string | undefined;
    priority?: number;
    quantity?: number | undefined;
    /** Is a primary key of associating object */
    itemId?: string | undefined;
    /** Each link element can have an associated object like Product, Category, etc.
Is a primary key of associated object */
    associatedObjectId?: string | undefined;
    /** Associated object type : 'product', 'category' etc */
    associatedObjectType?: string | undefined;
    outerId?: string | undefined;
    /** Display name for associated object */
    readonly associatedObjectName?: string | undefined;
    /** Associated object image URL */
    readonly associatedObjectImg?: string | undefined;
    tags?: string[] | undefined;
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    id?: string | undefined;

    constructor(data?: IProductAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.priority = _data["priority"];
            this.quantity = _data["quantity"];
            this.itemId = _data["itemId"];
            this.associatedObjectId = _data["associatedObjectId"];
            this.associatedObjectType = _data["associatedObjectType"];
            this.outerId = _data["outerId"];
            (<any>this).associatedObjectName = _data["associatedObjectName"];
            (<any>this).associatedObjectImg = _data["associatedObjectImg"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ProductAssociation {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAssociation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["priority"] = this.priority;
        data["quantity"] = this.quantity;
        data["itemId"] = this.itemId;
        data["associatedObjectId"] = this.associatedObjectId;
        data["associatedObjectType"] = this.associatedObjectType;
        data["outerId"] = this.outerId;
        data["associatedObjectName"] = this.associatedObjectName;
        data["associatedObjectImg"] = this.associatedObjectImg;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IProductAssociation {
    /** Association type (Accessories, Up-Sales, Cross-Sales, Related etc) */
    type?: string | undefined;
    priority?: number;
    quantity?: number | undefined;
    /** Is a primary key of associating object */
    itemId?: string | undefined;
    /** Each link element can have an associated object like Product, Category, etc.
Is a primary key of associated object */
    associatedObjectId?: string | undefined;
    /** Associated object type : 'product', 'category' etc */
    associatedObjectType?: string | undefined;
    outerId?: string | undefined;
    /** Display name for associated object */
    associatedObjectName?: string | undefined;
    /** Associated object image URL */
    associatedObjectImg?: string | undefined;
    tags?: string[] | undefined;
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    id?: string | undefined;
}

export class ProductAssociationSearchCriteria implements IProductAssociationSearchCriteria {
    group?: string | undefined;
    tags?: string[] | undefined;
    associatedObjectIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IProductAssociationSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.group = _data["group"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["associatedObjectIds"])) {
                this.associatedObjectIds = [] as any;
                for (let item of _data["associatedObjectIds"])
                    this.associatedObjectIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ProductAssociationSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAssociationSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.associatedObjectIds)) {
            data["associatedObjectIds"] = [];
            for (let item of this.associatedObjectIds)
                data["associatedObjectIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IProductAssociationSearchCriteria {
    group?: string | undefined;
    tags?: string[] | undefined;
    associatedObjectIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ProductAssociationSearchResult implements IProductAssociationSearchResult {
    totalCount?: number;
    results?: ProductAssociation[] | undefined;

    constructor(data?: IProductAssociationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ProductAssociation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAssociationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAssociationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductAssociationSearchResult {
    totalCount?: number;
    results?: ProductAssociation[] | undefined;
}

export class CatalogSearchCriteria implements ICatalogSearchCriteria {
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICatalogSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CatalogSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ICatalogSearchCriteria {
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CatalogLanguage implements ICatalogLanguage {
    catalogId?: string | undefined;
    isDefault?: boolean;
    languageCode?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalogLanguage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            this.isDefault = _data["isDefault"];
            this.languageCode = _data["languageCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogLanguage {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogLanguage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        data["isDefault"] = this.isDefault;
        data["languageCode"] = this.languageCode;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICatalogLanguage {
    catalogId?: string | undefined;
    isDefault?: boolean;
    languageCode?: string | undefined;
    id?: string | undefined;
}

export enum PropertyValueType {
    ShortText = "ShortText",
    LongText = "LongText",
    Number = "Number",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Integer = "Integer",
    GeoPoint = "GeoPoint",
}

export enum PropertyType {
    Product = "Product",
    Variation = "Variation",
    Category = "Category",
    Catalog = "Catalog",
}

export class PropertyValue implements IPropertyValue {
    propertyName?: string | undefined;
    propertyId?: string | undefined;
    languageCode?: string | undefined;
    alias?: string | undefined;
    valueType?: PropertyValueType;
    valueId?: string | undefined;
    value?: any | undefined;
    readonly propertyMultivalue?: boolean;
    outerId?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.propertyId = _data["propertyId"];
            this.languageCode = _data["languageCode"];
            this.alias = _data["alias"];
            this.valueType = _data["valueType"];
            this.valueId = _data["valueId"];
            this.value = _data["value"];
            (<any>this).propertyMultivalue = _data["propertyMultivalue"];
            this.outerId = _data["outerId"];
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyValue {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["propertyId"] = this.propertyId;
        data["languageCode"] = this.languageCode;
        data["alias"] = this.alias;
        data["valueType"] = this.valueType;
        data["valueId"] = this.valueId;
        data["value"] = this.value;
        data["propertyMultivalue"] = this.propertyMultivalue;
        data["outerId"] = this.outerId;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPropertyValue {
    propertyName?: string | undefined;
    propertyId?: string | undefined;
    languageCode?: string | undefined;
    alias?: string | undefined;
    valueType?: PropertyValueType;
    valueId?: string | undefined;
    value?: any | undefined;
    propertyMultivalue?: boolean;
    outerId?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class PropertyAttribute implements IPropertyAttribute {
    propertyId?: string | undefined;
    value?: string | undefined;
    name?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.value = _data["value"];
            this.name = _data["name"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["value"] = this.value;
        data["name"] = this.name;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPropertyAttribute {
    propertyId?: string | undefined;
    value?: string | undefined;
    name?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class PropertyDisplayName implements IPropertyDisplayName {
    name?: string | undefined;
    languageCode?: string | undefined;

    constructor(data?: IPropertyDisplayName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.languageCode = _data["languageCode"];
        }
    }

    static fromJS(data: any): PropertyDisplayName {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDisplayName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["languageCode"] = this.languageCode;
        return data; 
    }
}

export interface IPropertyDisplayName {
    name?: string | undefined;
    languageCode?: string | undefined;
}

/** Represents property validation rules definition */
export class PropertyValidationRule implements IPropertyValidationRule {
    /** Uniquie value flag constrain */
    isUnique?: boolean;
    /** Down chars count border or null if no defined */
    charCountMin?: number | undefined;
    /** Upper chars count border or null if no defined */
    charCountMax?: number | undefined;
    /** Custom regular expression */
    regExp?: string | undefined;
    propertyId?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyValidationRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isUnique = _data["isUnique"];
            this.charCountMin = _data["charCountMin"];
            this.charCountMax = _data["charCountMax"];
            this.regExp = _data["regExp"];
            this.propertyId = _data["propertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyValidationRule {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyValidationRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isUnique"] = this.isUnique;
        data["charCountMin"] = this.charCountMin;
        data["charCountMax"] = this.charCountMax;
        data["regExp"] = this.regExp;
        data["propertyId"] = this.propertyId;
        data["id"] = this.id;
        return data; 
    }
}

/** Represents property validation rules definition */
export interface IPropertyValidationRule {
    /** Uniquie value flag constrain */
    isUnique?: boolean;
    /** Down chars count border or null if no defined */
    charCountMin?: number | undefined;
    /** Upper chars count border or null if no defined */
    charCountMax?: number | undefined;
    /** Custom regular expression */
    regExp?: string | undefined;
    propertyId?: string | undefined;
    id?: string | undefined;
}

export class Property implements IProperty {
    /** Gets or sets a value indicating whether user can change property value. */
    isReadOnly?: boolean;
    /** Gets or sets a value indicating whether user can change property metadata or remove this property. */
    readonly isManageable?: boolean;
    /** Gets or sets a value indicating whether this instance is new. A new property should be created on server site instead of trying to update it. */
    isNew?: boolean;
    /** Gets or sets the catalog id that this product belongs to. */
    catalogId?: string | undefined;
    /** Gets or sets the category id that this product belongs to. */
    categoryId?: string | undefined;
    name?: string | undefined;
    required?: boolean;
    dictionary?: boolean;
    multivalue?: boolean;
    multilanguage?: boolean;
    /** Gets or sets a value indicating whether this VirtoCommerce.CatalogModule.Core.Model.Property is hidden. */
    hidden?: boolean;
    valueType?: PropertyValueType;
    type?: PropertyType;
    outerId?: string | undefined;
    ownerName?: string | undefined;
    values?: PropertyValue[] | undefined;
    attributes?: PropertyAttribute[] | undefined;
    displayNames?: PropertyDisplayName[] | undefined;
    validationRules?: PropertyValidationRule[] | undefined;
    validationRule?: PropertyValidationRule;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isReadOnly = _data["isReadOnly"];
            (<any>this).isManageable = _data["isManageable"];
            this.isNew = _data["isNew"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.required = _data["required"];
            this.dictionary = _data["dictionary"];
            this.multivalue = _data["multivalue"];
            this.multilanguage = _data["multilanguage"];
            this.hidden = _data["hidden"];
            this.valueType = _data["valueType"];
            this.type = _data["type"];
            this.outerId = _data["outerId"];
            this.ownerName = _data["ownerName"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(PropertyValue.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(PropertyAttribute.fromJS(item));
            }
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(PropertyDisplayName.fromJS(item));
            }
            if (Array.isArray(_data["validationRules"])) {
                this.validationRules = [] as any;
                for (let item of _data["validationRules"])
                    this.validationRules!.push(PropertyValidationRule.fromJS(item));
            }
            this.validationRule = _data["validationRule"] ? PropertyValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Property {
        data = typeof data === 'object' ? data : {};
        let result = new Property();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isReadOnly"] = this.isReadOnly;
        data["isManageable"] = this.isManageable;
        data["isNew"] = this.isNew;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["required"] = this.required;
        data["dictionary"] = this.dictionary;
        data["multivalue"] = this.multivalue;
        data["multilanguage"] = this.multilanguage;
        data["hidden"] = this.hidden;
        data["valueType"] = this.valueType;
        data["type"] = this.type;
        data["outerId"] = this.outerId;
        data["ownerName"] = this.ownerName;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        if (Array.isArray(this.validationRules)) {
            data["validationRules"] = [];
            for (let item of this.validationRules)
                data["validationRules"].push(item.toJSON());
        }
        data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IProperty {
    /** Gets or sets a value indicating whether user can change property value. */
    isReadOnly?: boolean;
    /** Gets or sets a value indicating whether user can change property metadata or remove this property. */
    isManageable?: boolean;
    /** Gets or sets a value indicating whether this instance is new. A new property should be created on server site instead of trying to update it. */
    isNew?: boolean;
    /** Gets or sets the catalog id that this product belongs to. */
    catalogId?: string | undefined;
    /** Gets or sets the category id that this product belongs to. */
    categoryId?: string | undefined;
    name?: string | undefined;
    required?: boolean;
    dictionary?: boolean;
    multivalue?: boolean;
    multilanguage?: boolean;
    /** Gets or sets a value indicating whether this VirtoCommerce.CatalogModule.Core.Model.Property is hidden. */
    hidden?: boolean;
    valueType?: PropertyValueType;
    type?: PropertyType;
    outerId?: string | undefined;
    ownerName?: string | undefined;
    values?: PropertyValue[] | undefined;
    attributes?: PropertyAttribute[] | undefined;
    displayNames?: PropertyDisplayName[] | undefined;
    validationRules?: PropertyValidationRule[] | undefined;
    validationRule?: PropertyValidationRule;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Catalog implements ICatalog {
    name?: string | undefined;
    isVirtual?: boolean;
    outerId?: string | undefined;
    defaultLanguage?: CatalogLanguage;
    languages?: CatalogLanguage[] | undefined;
    properties?: Property[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isVirtual = _data["isVirtual"];
            this.outerId = _data["outerId"];
            this.defaultLanguage = _data["defaultLanguage"] ? CatalogLanguage.fromJS(_data["defaultLanguage"]) : <any>undefined;
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(CatalogLanguage.fromJS(item));
            }
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Catalog {
        data = typeof data === 'object' ? data : {};
        let result = new Catalog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isVirtual"] = this.isVirtual;
        data["outerId"] = this.outerId;
        data["defaultLanguage"] = this.defaultLanguage ? this.defaultLanguage.toJSON() : <any>undefined;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICatalog {
    name?: string | undefined;
    isVirtual?: boolean;
    outerId?: string | undefined;
    defaultLanguage?: CatalogLanguage;
    languages?: CatalogLanguage[] | undefined;
    properties?: Property[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CatalogSearchResult implements ICatalogSearchResult {
    totalCount?: number;
    results?: Catalog[] | undefined;

    constructor(data?: ICatalogSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Catalog.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CatalogSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICatalogSearchResult {
    totalCount?: number;
    results?: Catalog[] | undefined;
}

export class ExcludedProperty implements IExcludedProperty {
    name?: string | undefined;
    isInherited?: boolean;

    constructor(data?: IExcludedProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isInherited = _data["isInherited"];
        }
    }

    static fromJS(data: any): ExcludedProperty {
        data = typeof data === 'object' ? data : {};
        let result = new ExcludedProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isInherited"] = this.isInherited;
        return data; 
    }
}

export interface IExcludedProperty {
    name?: string | undefined;
    isInherited?: boolean;
}

export class CategoryLink implements ICategoryLink {
    /** Entry identifier which this link belongs to */
    readonly entryId?: string | undefined;
    listEntryId?: string | undefined;
    /** Gets or sets the type of the list entry. E.g. "product", "category" */
    listEntryType?: string | undefined;
    /** Product order position in virtual catalog */
    priority?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    category?: Category;

    constructor(data?: ICategoryLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).entryId = _data["entryId"];
            this.listEntryId = _data["listEntryId"];
            this.listEntryType = _data["listEntryType"];
            this.priority = _data["priority"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryLink {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryId"] = this.entryId;
        data["listEntryId"] = this.listEntryId;
        data["listEntryType"] = this.listEntryType;
        data["priority"] = this.priority;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICategoryLink {
    /** Entry identifier which this link belongs to */
    entryId?: string | undefined;
    listEntryId?: string | undefined;
    /** Gets or sets the type of the list entry. E.g. "product", "category" */
    listEntryType?: string | undefined;
    /** Product order position in virtual catalog */
    priority?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    category?: Category;
}

/** Represents one outline element: catalog, category or product. */
export class OutlineItem implements IOutlineItem {
    /** Object id */
    id?: string | undefined;
    /** Object type */
    seoObjectType?: string | undefined;
    /** All SEO records for the object */
    seoInfos?: SeoInfo[] | undefined;
    /** The name of current item */
    name?: string | undefined;
    /** True when this object is linked to the virtual parent. */
    hasVirtualParent?: boolean;

    constructor(data?: IOutlineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.name = _data["name"];
            this.hasVirtualParent = _data["hasVirtualParent"];
        }
    }

    static fromJS(data: any): OutlineItem {
        data = typeof data === 'object' ? data : {};
        let result = new OutlineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["hasVirtualParent"] = this.hasVirtualParent;
        return data; 
    }
}

/** Represents one outline element: catalog, category or product. */
export interface IOutlineItem {
    /** Object id */
    id?: string | undefined;
    /** Object type */
    seoObjectType?: string | undefined;
    /** All SEO records for the object */
    seoInfos?: SeoInfo[] | undefined;
    /** The name of current item */
    name?: string | undefined;
    /** True when this object is linked to the virtual parent. */
    hasVirtualParent?: boolean;
}

/** Represents the path from the catalog to one of the child objects (product or category): catalog/parent-category1/.../parent-categoryN/object */
export class Outline implements IOutline {
    /** Outline parts */
    items?: OutlineItem[] | undefined;

    constructor(data?: IOutline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OutlineItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Outline {
        data = typeof data === 'object' ? data : {};
        let result = new Outline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

/** Represents the path from the catalog to one of the child objects (product or category): catalog/parent-category1/.../parent-categoryN/object */
export interface IOutline {
    /** Outline parts */
    items?: OutlineItem[] | undefined;
}

export class Category implements ICategory {
    catalogId?: string | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    /** Category outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
    readonly outline?: string | undefined;
    /** Category path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
    path?: string | undefined;
    isVirtual?: boolean;
    level?: number;
    packageType?: string | undefined;
    priority?: number;
    isActive?: boolean | undefined;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    links?: CategoryLink[] | undefined;
    taxType?: string | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    /** Gets the default image */
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    outlines?: Outline[] | undefined;
    /** System flag used to mark that object was inherited from other */
    readonly isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.name = _data["name"];
            (<any>this).outline = _data["outline"];
            this.path = _data["path"];
            this.isVirtual = _data["isVirtual"];
            this.level = _data["level"];
            this.packageType = _data["packageType"];
            this.priority = _data["priority"];
            this.isActive = _data["isActive"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            if (Array.isArray(_data["excludedProperties"])) {
                this.excludedProperties = [] as any;
                for (let item of _data["excludedProperties"])
                    this.excludedProperties!.push(ExcludedProperty.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            this.taxType = _data["taxType"];
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(Outline.fromJS(item));
            }
            (<any>this).isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["isVirtual"] = this.isVirtual;
        data["level"] = this.level;
        data["packageType"] = this.packageType;
        data["priority"] = this.priority;
        data["isActive"] = this.isActive;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.excludedProperties)) {
            data["excludedProperties"] = [];
            for (let item of this.excludedProperties)
                data["excludedProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["taxType"] = this.taxType;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item.toJSON());
        }
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICategory {
    catalogId?: string | undefined;
    parentId?: string | undefined;
    code?: string | undefined;
    name?: string | undefined;
    /** Category outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
    outline?: string | undefined;
    /** Category path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
    path?: string | undefined;
    isVirtual?: boolean;
    level?: number;
    packageType?: string | undefined;
    priority?: number;
    isActive?: boolean | undefined;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    links?: CategoryLink[] | undefined;
    taxType?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    /** Gets the default image */
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    outlines?: Outline[] | undefined;
    /** System flag used to mark that object was inherited from other */
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class NumericRange implements INumericRange {
    lower?: number | undefined;
    upper?: number | undefined;
    includeLower?: boolean;
    includeUpper?: boolean;

    constructor(data?: INumericRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lower = _data["lower"];
            this.upper = _data["upper"];
            this.includeLower = _data["includeLower"];
            this.includeUpper = _data["includeUpper"];
        }
    }

    static fromJS(data: any): NumericRange {
        data = typeof data === 'object' ? data : {};
        let result = new NumericRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lower"] = this.lower;
        data["upper"] = this.upper;
        data["includeLower"] = this.includeLower;
        data["includeUpper"] = this.includeUpper;
        return data; 
    }
}

export interface INumericRange {
    lower?: number | undefined;
    upper?: number | undefined;
    includeLower?: boolean;
    includeUpper?: boolean;
}

export class GeoPoint implements IGeoPoint {
    latitude?: number;
    longitude?: number;

    constructor(data?: IGeoPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): GeoPoint {
        data = typeof data === 'object' ? data : {};
        let result = new GeoPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data; 
    }
}

export interface IGeoPoint {
    latitude?: number;
    longitude?: number;
}

export class GeoDistanceFilter implements IGeoDistanceFilter {
    fieldName?: string | undefined;
    location?: GeoPoint;
    distance?: number;

    constructor(data?: IGeoDistanceFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.location = _data["location"] ? GeoPoint.fromJS(_data["location"]) : <any>undefined;
            this.distance = _data["distance"];
        }
    }

    static fromJS(data: any): GeoDistanceFilter {
        data = typeof data === 'object' ? data : {};
        let result = new GeoDistanceFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["distance"] = this.distance;
        return data; 
    }
}

export interface IGeoDistanceFilter {
    fieldName?: string | undefined;
    location?: GeoPoint;
    distance?: number;
}

export class ProductIndexedSearchCriteria implements IProductIndexedSearchCriteria {
    objectType?: string | undefined;
    /** Physical, Digital, etc. */
    productType?: string | undefined;
    currency?: string | undefined;
    pricelists?: string[] | undefined;
    priceRange?: NumericRange;
    /** Gets or sets the class types. */
    classTypes?: string[] | undefined;
    /** Specifies if we search for hidden products. */
    withHidden?: boolean;
    /** Include product variations in result */
    searchInVariations?: boolean;
    /** Gets or sets the start date. The date must be in UTC format as that is format indexes are stored in. */
    startDate?: Date;
    /** Gets or sets the start date from filter. Used for filtering new products. The date must be in UTC format as that is format indexes are stored in. */
    startDateFrom?: Date | undefined;
    /** Gets or sets the end date. The date must be in UTC format as that is format indexes are stored in. */
    endDate?: Date | undefined;
    /** Gets or sets a "white" list of aggregation keys that identify preconfigured aggregations, which SHOULD be calculated and returned with the search result. */
    includeAggregations?: string[] | undefined;
    /** Gets or sets a "black" list of aggregation keys that identify preconfigured aggregations, which SHOULD NOT be calculated and returned with the search result. */
    excludeAggregations?: string[] | undefined;
    geoDistanceFilter?: GeoDistanceFilter;
    /** Override base SortInfo property to support GeoSortInfo sorting types */
    readonly sortInfos?: SortInfo[] | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    /** CategoryId1/CategoryId2, no catalog should be included in the outline */
    outline?: string | undefined;
    /** CategoryId1/CategoryId2, no catalog should be included in the outline */
    outlines?: string[] | undefined;
    /** Term format: name:value1,value2 */
    terms?: string[] | undefined;
    /** Assigned groups for current user. Data format: user_groups:value1,value2 */
    userGroups?: string[] | undefined;
    /** Enable fuzzy search, i.e. allow to search color:white even if color:wihte actually passed to criteria */
    isFuzzySearch?: boolean;
    /** Gets or sets the search provider specific raw search query; all other search criteria will be ignored */
    rawQuery?: string | undefined;
    /** Allows to retrieve only a specific set of fields in the result hits */
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IProductIndexedSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.productType = _data["productType"];
            this.currency = _data["currency"];
            if (Array.isArray(_data["pricelists"])) {
                this.pricelists = [] as any;
                for (let item of _data["pricelists"])
                    this.pricelists!.push(item);
            }
            this.priceRange = _data["priceRange"] ? NumericRange.fromJS(_data["priceRange"]) : <any>undefined;
            if (Array.isArray(_data["classTypes"])) {
                this.classTypes = [] as any;
                for (let item of _data["classTypes"])
                    this.classTypes!.push(item);
            }
            this.withHidden = _data["withHidden"];
            this.searchInVariations = _data["searchInVariations"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.startDateFrom = _data["startDateFrom"] ? new Date(_data["startDateFrom"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["includeAggregations"])) {
                this.includeAggregations = [] as any;
                for (let item of _data["includeAggregations"])
                    this.includeAggregations!.push(item);
            }
            if (Array.isArray(_data["excludeAggregations"])) {
                this.excludeAggregations = [] as any;
                for (let item of _data["excludeAggregations"])
                    this.excludeAggregations!.push(item);
            }
            this.geoDistanceFilter = _data["geoDistanceFilter"] ? GeoDistanceFilter.fromJS(_data["geoDistanceFilter"]) : <any>undefined;
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.storeId = _data["storeId"];
            this.catalogId = _data["catalogId"];
            this.outline = _data["outline"];
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(item);
            }
            if (Array.isArray(_data["terms"])) {
                this.terms = [] as any;
                for (let item of _data["terms"])
                    this.terms!.push(item);
            }
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.isFuzzySearch = _data["isFuzzySearch"];
            this.rawQuery = _data["rawQuery"];
            if (Array.isArray(_data["includeFields"])) {
                this.includeFields = [] as any;
                for (let item of _data["includeFields"])
                    this.includeFields!.push(item);
            }
            this.searchPhrase = _data["searchPhrase"];
            this.keyword = _data["keyword"];
            this.responseGroup = _data["responseGroup"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ProductIndexedSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ProductIndexedSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["productType"] = this.productType;
        data["currency"] = this.currency;
        if (Array.isArray(this.pricelists)) {
            data["pricelists"] = [];
            for (let item of this.pricelists)
                data["pricelists"].push(item);
        }
        data["priceRange"] = this.priceRange ? this.priceRange.toJSON() : <any>undefined;
        if (Array.isArray(this.classTypes)) {
            data["classTypes"] = [];
            for (let item of this.classTypes)
                data["classTypes"].push(item);
        }
        data["withHidden"] = this.withHidden;
        data["searchInVariations"] = this.searchInVariations;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["startDateFrom"] = this.startDateFrom ? this.startDateFrom.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.includeAggregations)) {
            data["includeAggregations"] = [];
            for (let item of this.includeAggregations)
                data["includeAggregations"].push(item);
        }
        if (Array.isArray(this.excludeAggregations)) {
            data["excludeAggregations"] = [];
            for (let item of this.excludeAggregations)
                data["excludeAggregations"].push(item);
        }
        data["geoDistanceFilter"] = this.geoDistanceFilter ? this.geoDistanceFilter.toJSON() : <any>undefined;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["storeId"] = this.storeId;
        data["catalogId"] = this.catalogId;
        data["outline"] = this.outline;
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item);
        }
        if (Array.isArray(this.terms)) {
            data["terms"] = [];
            for (let item of this.terms)
                data["terms"].push(item);
        }
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["isFuzzySearch"] = this.isFuzzySearch;
        data["rawQuery"] = this.rawQuery;
        if (Array.isArray(this.includeFields)) {
            data["includeFields"] = [];
            for (let item of this.includeFields)
                data["includeFields"].push(item);
        }
        data["searchPhrase"] = this.searchPhrase;
        data["keyword"] = this.keyword;
        data["responseGroup"] = this.responseGroup;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IProductIndexedSearchCriteria {
    objectType?: string | undefined;
    /** Physical, Digital, etc. */
    productType?: string | undefined;
    currency?: string | undefined;
    pricelists?: string[] | undefined;
    priceRange?: NumericRange;
    /** Gets or sets the class types. */
    classTypes?: string[] | undefined;
    /** Specifies if we search for hidden products. */
    withHidden?: boolean;
    /** Include product variations in result */
    searchInVariations?: boolean;
    /** Gets or sets the start date. The date must be in UTC format as that is format indexes are stored in. */
    startDate?: Date;
    /** Gets or sets the start date from filter. Used for filtering new products. The date must be in UTC format as that is format indexes are stored in. */
    startDateFrom?: Date | undefined;
    /** Gets or sets the end date. The date must be in UTC format as that is format indexes are stored in. */
    endDate?: Date | undefined;
    /** Gets or sets a "white" list of aggregation keys that identify preconfigured aggregations, which SHOULD be calculated and returned with the search result. */
    includeAggregations?: string[] | undefined;
    /** Gets or sets a "black" list of aggregation keys that identify preconfigured aggregations, which SHOULD NOT be calculated and returned with the search result. */
    excludeAggregations?: string[] | undefined;
    geoDistanceFilter?: GeoDistanceFilter;
    /** Override base SortInfo property to support GeoSortInfo sorting types */
    sortInfos?: SortInfo[] | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    /** CategoryId1/CategoryId2, no catalog should be included in the outline */
    outline?: string | undefined;
    /** CategoryId1/CategoryId2, no catalog should be included in the outline */
    outlines?: string[] | undefined;
    /** Term format: name:value1,value2 */
    terms?: string[] | undefined;
    /** Assigned groups for current user. Data format: user_groups:value1,value2 */
    userGroups?: string[] | undefined;
    /** Enable fuzzy search, i.e. allow to search color:white even if color:wihte actually passed to criteria */
    isFuzzySearch?: boolean;
    /** Gets or sets the search provider specific raw search query; all other search criteria will be ignored */
    rawQuery?: string | undefined;
    /** Allows to retrieve only a specific set of fields in the result hits */
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    skip?: number;
    take?: number;
}

export class Asset implements IAsset {
    mimeType?: string | undefined;
    size?: number;
    readonly readableSize?: string | undefined;
    binaryData?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    /** Gets or sets the asset type identifier. */
    typeId?: string | undefined;
    /** Gets or sets the asset group name. */
    group?: string | undefined;
    /** Gets or sets the asset name. */
    name?: string | undefined;
    outerId?: string | undefined;
    /** Gets or sets the asset language. */
    languageCode?: string | undefined;
    /** System flag used to mark that object was inherited from other */
    readonly isInherited?: boolean;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IAsset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mimeType = _data["mimeType"];
            this.size = _data["size"];
            (<any>this).readableSize = _data["readableSize"];
            this.binaryData = _data["binaryData"];
            this.relativeUrl = _data["relativeUrl"];
            this.url = _data["url"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.typeId = _data["typeId"];
            this.group = _data["group"];
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.languageCode = _data["languageCode"];
            (<any>this).isInherited = _data["isInherited"];
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Asset {
        data = typeof data === 'object' ? data : {};
        let result = new Asset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mimeType"] = this.mimeType;
        data["size"] = this.size;
        data["readableSize"] = this.readableSize;
        data["binaryData"] = this.binaryData;
        data["relativeUrl"] = this.relativeUrl;
        data["url"] = this.url;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["typeId"] = this.typeId;
        data["group"] = this.group;
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAsset {
    mimeType?: string | undefined;
    size?: number;
    readableSize?: string | undefined;
    binaryData?: string | undefined;
    relativeUrl?: string | undefined;
    url?: string | undefined;
    description?: string | undefined;
    sortOrder?: number;
    /** Gets or sets the asset type identifier. */
    typeId?: string | undefined;
    /** Gets or sets the asset group name. */
    group?: string | undefined;
    /** Gets or sets the asset name. */
    name?: string | undefined;
    outerId?: string | undefined;
    /** Gets or sets the asset language. */
    languageCode?: string | undefined;
    /** System flag used to mark that object was inherited from other */
    isInherited?: boolean;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class EditorialReview implements IEditorialReview {
    content?: string | undefined;
    reviewType?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IEditorialReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.reviewType = _data["reviewType"];
            this.languageCode = _data["languageCode"];
            this.isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditorialReview {
        data = typeof data === 'object' ? data : {};
        let result = new EditorialReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["reviewType"] = this.reviewType;
        data["languageCode"] = this.languageCode;
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditorialReview {
    content?: string | undefined;
    reviewType?: string | undefined;
    languageCode?: string | undefined;
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Variation implements IVariation {
    /** SKU code */
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
    readonly outline?: string | undefined;
    /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
    readonly path?: string | undefined;
    readonly titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isBuyable?: boolean | undefined;
    isActive?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    /** Can be Physical, Digital or Subscription. */
    productType?: string | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    /** re-downloads limit */
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    /** DownloadType: {Standard Product, Software, Music} */
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    /** Product order position in catalog */
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    /** Gets the default image for the product. */
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    /** Each descendant type should override this property to use other object type for seo records */
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    /** System flag used to mark that object was inherited from other */
    readonly isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IVariation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.manufacturerPartNumber = _data["manufacturerPartNumber"];
            this.gtin = _data["gtin"];
            this.name = _data["name"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            (<any>this).titularItemId = _data["titularItemId"];
            this.mainProductId = _data["mainProductId"];
            this.isBuyable = _data["isBuyable"];
            this.isActive = _data["isActive"];
            this.trackInventory = _data["trackInventory"];
            this.indexingDate = _data["indexingDate"] ? new Date(_data["indexingDate"].toString()) : <any>undefined;
            this.maxQuantity = _data["maxQuantity"];
            this.minQuantity = _data["minQuantity"];
            this.productType = _data["productType"];
            this.packageType = _data["packageType"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.enableReview = _data["enableReview"];
            this.maxNumberOfDownload = _data["maxNumberOfDownload"];
            this.downloadExpiration = _data["downloadExpiration"] ? new Date(_data["downloadExpiration"].toString()) : <any>undefined;
            this.downloadType = _data["downloadType"];
            this.hasUserAgreement = _data["hasUserAgreement"];
            this.shippingType = _data["shippingType"];
            this.taxType = _data["taxType"];
            this.vendor = _data["vendor"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.priority = _data["priority"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            if (Array.isArray(_data["excludedProperties"])) {
                this.excludedProperties = [] as any;
                for (let item of _data["excludedProperties"])
                    this.excludedProperties!.push(ExcludedProperty.fromJS(item));
            }
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValue.fromJS(item));
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets!.push(Asset.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(Variation.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(EditorialReview.fromJS(item));
            }
            if (Array.isArray(_data["associations"])) {
                this.associations = [] as any;
                for (let item of _data["associations"])
                    this.associations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["referencedAssociations"])) {
                this.referencedAssociations = [] as any;
                for (let item of _data["referencedAssociations"])
                    this.referencedAssociations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(Outline.fromJS(item));
            }
            (<any>this).isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Variation {
        data = typeof data === 'object' ? data : {};
        let result = new Variation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["manufacturerPartNumber"] = this.manufacturerPartNumber;
        data["gtin"] = this.gtin;
        data["name"] = this.name;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["titularItemId"] = this.titularItemId;
        data["mainProductId"] = this.mainProductId;
        data["isBuyable"] = this.isBuyable;
        data["isActive"] = this.isActive;
        data["trackInventory"] = this.trackInventory;
        data["indexingDate"] = this.indexingDate ? this.indexingDate.toISOString() : <any>undefined;
        data["maxQuantity"] = this.maxQuantity;
        data["minQuantity"] = this.minQuantity;
        data["productType"] = this.productType;
        data["packageType"] = this.packageType;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["enableReview"] = this.enableReview;
        data["maxNumberOfDownload"] = this.maxNumberOfDownload;
        data["downloadExpiration"] = this.downloadExpiration ? this.downloadExpiration.toISOString() : <any>undefined;
        data["downloadType"] = this.downloadType;
        data["hasUserAgreement"] = this.hasUserAgreement;
        data["shippingType"] = this.shippingType;
        data["taxType"] = this.taxType;
        data["vendor"] = this.vendor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["priority"] = this.priority;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.excludedProperties)) {
            data["excludedProperties"] = [];
            for (let item of this.excludedProperties)
                data["excludedProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        if (Array.isArray(this.associations)) {
            data["associations"] = [];
            for (let item of this.associations)
                data["associations"].push(item.toJSON());
        }
        if (Array.isArray(this.referencedAssociations)) {
            data["referencedAssociations"] = [];
            for (let item of this.referencedAssociations)
                data["referencedAssociations"].push(item.toJSON());
        }
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item.toJSON());
        }
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVariation {
    /** SKU code */
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
    outline?: string | undefined;
    /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
    path?: string | undefined;
    titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isBuyable?: boolean | undefined;
    isActive?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    /** Can be Physical, Digital or Subscription. */
    productType?: string | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    /** re-downloads limit */
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    /** DownloadType: {Standard Product, Software, Music} */
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    /** Product order position in catalog */
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    /** Gets the default image for the product. */
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    /** Each descendant type should override this property to use other object type for seo records */
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    /** System flag used to mark that object was inherited from other */
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CatalogProduct implements ICatalogProduct {
    /** SKU code */
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
    readonly outline?: string | undefined;
    /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
    readonly path?: string | undefined;
    readonly titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isBuyable?: boolean | undefined;
    isActive?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    /** Can be Physical, Digital or Subscription. */
    productType?: string | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    /** re-downloads limit */
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    /** DownloadType: {Standard Product, Software, Music} */
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    /** Product order position in catalog */
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    /** Gets the default image for the product. */
    readonly imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    /** Each descendant type should override this property to use other object type for seo records */
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    /** System flag used to mark that object was inherited from other */
    readonly isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICatalogProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.manufacturerPartNumber = _data["manufacturerPartNumber"];
            this.gtin = _data["gtin"];
            this.name = _data["name"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            (<any>this).titularItemId = _data["titularItemId"];
            this.mainProductId = _data["mainProductId"];
            this.isBuyable = _data["isBuyable"];
            this.isActive = _data["isActive"];
            this.trackInventory = _data["trackInventory"];
            this.indexingDate = _data["indexingDate"] ? new Date(_data["indexingDate"].toString()) : <any>undefined;
            this.maxQuantity = _data["maxQuantity"];
            this.minQuantity = _data["minQuantity"];
            this.productType = _data["productType"];
            this.packageType = _data["packageType"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.enableReview = _data["enableReview"];
            this.maxNumberOfDownload = _data["maxNumberOfDownload"];
            this.downloadExpiration = _data["downloadExpiration"] ? new Date(_data["downloadExpiration"].toString()) : <any>undefined;
            this.downloadType = _data["downloadType"];
            this.hasUserAgreement = _data["hasUserAgreement"];
            this.shippingType = _data["shippingType"];
            this.taxType = _data["taxType"];
            this.vendor = _data["vendor"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.priority = _data["priority"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["properties"])) {
                this.properties = [] as any;
                for (let item of _data["properties"])
                    this.properties!.push(Property.fromJS(item));
            }
            if (Array.isArray(_data["excludedProperties"])) {
                this.excludedProperties = [] as any;
                for (let item of _data["excludedProperties"])
                    this.excludedProperties!.push(ExcludedProperty.fromJS(item));
            }
            if (Array.isArray(_data["propertyValues"])) {
                this.propertyValues = [] as any;
                for (let item of _data["propertyValues"])
                    this.propertyValues!.push(PropertyValue.fromJS(item));
            }
            (<any>this).imgSrc = _data["imgSrc"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
            if (Array.isArray(_data["assets"])) {
                this.assets = [] as any;
                for (let item of _data["assets"])
                    this.assets!.push(Asset.fromJS(item));
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(Variation.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(EditorialReview.fromJS(item));
            }
            if (Array.isArray(_data["associations"])) {
                this.associations = [] as any;
                for (let item of _data["associations"])
                    this.associations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["referencedAssociations"])) {
                this.referencedAssociations = [] as any;
                for (let item of _data["referencedAssociations"])
                    this.referencedAssociations!.push(ProductAssociation.fromJS(item));
            }
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(Outline.fromJS(item));
            }
            (<any>this).isInherited = _data["isInherited"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogProduct {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["manufacturerPartNumber"] = this.manufacturerPartNumber;
        data["gtin"] = this.gtin;
        data["name"] = this.name;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["titularItemId"] = this.titularItemId;
        data["mainProductId"] = this.mainProductId;
        data["isBuyable"] = this.isBuyable;
        data["isActive"] = this.isActive;
        data["trackInventory"] = this.trackInventory;
        data["indexingDate"] = this.indexingDate ? this.indexingDate.toISOString() : <any>undefined;
        data["maxQuantity"] = this.maxQuantity;
        data["minQuantity"] = this.minQuantity;
        data["productType"] = this.productType;
        data["packageType"] = this.packageType;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["enableReview"] = this.enableReview;
        data["maxNumberOfDownload"] = this.maxNumberOfDownload;
        data["downloadExpiration"] = this.downloadExpiration ? this.downloadExpiration.toISOString() : <any>undefined;
        data["downloadType"] = this.downloadType;
        data["hasUserAgreement"] = this.hasUserAgreement;
        data["shippingType"] = this.shippingType;
        data["taxType"] = this.taxType;
        data["vendor"] = this.vendor;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["priority"] = this.priority;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.properties)) {
            data["properties"] = [];
            for (let item of this.properties)
                data["properties"].push(item.toJSON());
        }
        if (Array.isArray(this.excludedProperties)) {
            data["excludedProperties"] = [];
            for (let item of this.excludedProperties)
                data["excludedProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyValues)) {
            data["propertyValues"] = [];
            for (let item of this.propertyValues)
                data["propertyValues"].push(item.toJSON());
        }
        data["imgSrc"] = this.imgSrc;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        if (Array.isArray(this.assets)) {
            data["assets"] = [];
            for (let item of this.assets)
                data["assets"].push(item.toJSON());
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item.toJSON());
        }
        if (Array.isArray(this.associations)) {
            data["associations"] = [];
            for (let item of this.associations)
                data["associations"].push(item.toJSON());
        }
        if (Array.isArray(this.referencedAssociations)) {
            data["referencedAssociations"] = [];
            for (let item of this.referencedAssociations)
                data["referencedAssociations"].push(item.toJSON());
        }
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item.toJSON());
        }
        data["isInherited"] = this.isInherited;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICatalogProduct {
    /** SKU code */
    code?: string | undefined;
    manufacturerPartNumber?: string | undefined;
    /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
    gtin?: string | undefined;
    name?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
    outline?: string | undefined;
    /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
    path?: string | undefined;
    titularItemId?: string | undefined;
    mainProductId?: string | undefined;
    isBuyable?: boolean | undefined;
    isActive?: boolean | undefined;
    trackInventory?: boolean | undefined;
    indexingDate?: Date | undefined;
    maxQuantity?: number | undefined;
    minQuantity?: number | undefined;
    /** Can be Physical, Digital or Subscription. */
    productType?: string | undefined;
    packageType?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    enableReview?: boolean | undefined;
    /** re-downloads limit */
    maxNumberOfDownload?: number | undefined;
    downloadExpiration?: Date | undefined;
    /** DownloadType: {Standard Product, Software, Music} */
    downloadType?: string | undefined;
    hasUserAgreement?: boolean | undefined;
    shippingType?: string | undefined;
    taxType?: string | undefined;
    vendor?: string | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
    /** Product order position in catalog */
    priority?: number;
    outerId?: string | undefined;
    properties?: Property[] | undefined;
    excludedProperties?: ExcludedProperty[] | undefined;
    propertyValues?: PropertyValue[] | undefined;
    /** Gets the default image for the product. */
    imgSrc?: string | undefined;
    images?: Image[] | undefined;
    assets?: Asset[] | undefined;
    links?: CategoryLink[] | undefined;
    variations?: Variation[] | undefined;
    /** Each descendant type should override this property to use other object type for seo records */
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    reviews?: EditorialReview[] | undefined;
    associations?: ProductAssociation[] | undefined;
    referencedAssociations?: ProductAssociation[] | undefined;
    outlines?: Outline[] | undefined;
    /** System flag used to mark that object was inherited from other */
    isInherited?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class AggregationLabel implements IAggregationLabel {
    language?: string | undefined;
    label?: string | undefined;

    constructor(data?: IAggregationLabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): AggregationLabel {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationLabel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language;
        data["label"] = this.label;
        return data; 
    }
}

export interface IAggregationLabel {
    language?: string | undefined;
    label?: string | undefined;
}

export class AggregationItem implements IAggregationItem {
    /** Gets or sets the aggregation item value */
    value?: any | undefined;
    /** Gets or sets the aggregation item count */
    count?: number;
    /** Gets or sets the flag for aggregation item is applied */
    isApplied?: boolean;
    /** Gets or sets the collection of the aggregation item labels */
    labels?: AggregationLabel[] | undefined;
    /** Gets or sets the request lower bound for range aggregation value */
    requestedLowerBound?: string | undefined;
    /** Gets or sets the request lower bound for range aggregation value */
    requestedUpperBound?: string | undefined;

    constructor(data?: IAggregationItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.count = _data["count"];
            this.isApplied = _data["isApplied"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(AggregationLabel.fromJS(item));
            }
            this.requestedLowerBound = _data["requestedLowerBound"];
            this.requestedUpperBound = _data["requestedUpperBound"];
        }
    }

    static fromJS(data: any): AggregationItem {
        data = typeof data === 'object' ? data : {};
        let result = new AggregationItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["count"] = this.count;
        data["isApplied"] = this.isApplied;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        data["requestedLowerBound"] = this.requestedLowerBound;
        data["requestedUpperBound"] = this.requestedUpperBound;
        return data; 
    }
}

export interface IAggregationItem {
    /** Gets or sets the aggregation item value */
    value?: any | undefined;
    /** Gets or sets the aggregation item count */
    count?: number;
    /** Gets or sets the flag for aggregation item is applied */
    isApplied?: boolean;
    /** Gets or sets the collection of the aggregation item labels */
    labels?: AggregationLabel[] | undefined;
    /** Gets or sets the request lower bound for range aggregation value */
    requestedLowerBound?: string | undefined;
    /** Gets or sets the request lower bound for range aggregation value */
    requestedUpperBound?: string | undefined;
}

export class Aggregation implements IAggregation {
    /** Gets or sets the value of the aggregation type */
    aggregationType?: string | undefined;
    /** Gets or sets the value of the aggregation field */
    field?: string | undefined;
    /** Gets or sets the collection of the aggregation labels */
    labels?: AggregationLabel[] | undefined;
    /** Gets or sets the collection of the aggregation items */
    items?: AggregationItem[] | undefined;

    constructor(data?: IAggregation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aggregationType = _data["aggregationType"];
            this.field = _data["field"];
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels!.push(AggregationLabel.fromJS(item));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AggregationItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Aggregation {
        data = typeof data === 'object' ? data : {};
        let result = new Aggregation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aggregationType"] = this.aggregationType;
        data["field"] = this.field;
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAggregation {
    /** Gets or sets the value of the aggregation type */
    aggregationType?: string | undefined;
    /** Gets or sets the value of the aggregation field */
    field?: string | undefined;
    /** Gets or sets the collection of the aggregation labels */
    labels?: AggregationLabel[] | undefined;
    /** Gets or sets the collection of the aggregation items */
    items?: AggregationItem[] | undefined;
}

export class ProductIndexedSearchResult implements IProductIndexedSearchResult {
    totalCount?: number;
    items?: CatalogProduct[] | undefined;
    aggregations?: Aggregation[] | undefined;

    constructor(data?: IProductIndexedSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CatalogProduct.fromJS(item));
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(Aggregation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductIndexedSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductIndexedSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductIndexedSearchResult {
    totalCount?: number;
    items?: CatalogProduct[] | undefined;
    aggregations?: Aggregation[] | undefined;
}

export class CategoryIndexedSearchCriteria implements ICategoryIndexedSearchCriteria {
    objectType?: string | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    /** CategoryId1/CategoryId2, no catalog should be included in the outline */
    outline?: string | undefined;
    /** CategoryId1/CategoryId2, no catalog should be included in the outline */
    outlines?: string[] | undefined;
    /** Term format: name:value1,value2 */
    terms?: string[] | undefined;
    /** Assigned groups for current user. Data format: user_groups:value1,value2 */
    userGroups?: string[] | undefined;
    /** Enable fuzzy search, i.e. allow to search color:white even if color:wihte actually passed to criteria */
    isFuzzySearch?: boolean;
    /** Gets or sets the search provider specific raw search query; all other search criteria will be ignored */
    rawQuery?: string | undefined;
    /** Allows to retrieve only a specific set of fields in the result hits */
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICategoryIndexedSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.storeId = _data["storeId"];
            this.catalogId = _data["catalogId"];
            this.outline = _data["outline"];
            if (Array.isArray(_data["outlines"])) {
                this.outlines = [] as any;
                for (let item of _data["outlines"])
                    this.outlines!.push(item);
            }
            if (Array.isArray(_data["terms"])) {
                this.terms = [] as any;
                for (let item of _data["terms"])
                    this.terms!.push(item);
            }
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.isFuzzySearch = _data["isFuzzySearch"];
            this.rawQuery = _data["rawQuery"];
            if (Array.isArray(_data["includeFields"])) {
                this.includeFields = [] as any;
                for (let item of _data["includeFields"])
                    this.includeFields!.push(item);
            }
            this.searchPhrase = _data["searchPhrase"];
            this.keyword = _data["keyword"];
            this.responseGroup = _data["responseGroup"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CategoryIndexedSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryIndexedSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["storeId"] = this.storeId;
        data["catalogId"] = this.catalogId;
        data["outline"] = this.outline;
        if (Array.isArray(this.outlines)) {
            data["outlines"] = [];
            for (let item of this.outlines)
                data["outlines"].push(item);
        }
        if (Array.isArray(this.terms)) {
            data["terms"] = [];
            for (let item of this.terms)
                data["terms"].push(item);
        }
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["isFuzzySearch"] = this.isFuzzySearch;
        data["rawQuery"] = this.rawQuery;
        if (Array.isArray(this.includeFields)) {
            data["includeFields"] = [];
            for (let item of this.includeFields)
                data["includeFields"].push(item);
        }
        data["searchPhrase"] = this.searchPhrase;
        data["keyword"] = this.keyword;
        data["responseGroup"] = this.responseGroup;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ICategoryIndexedSearchCriteria {
    objectType?: string | undefined;
    storeId?: string | undefined;
    catalogId?: string | undefined;
    /** CategoryId1/CategoryId2, no catalog should be included in the outline */
    outline?: string | undefined;
    /** CategoryId1/CategoryId2, no catalog should be included in the outline */
    outlines?: string[] | undefined;
    /** Term format: name:value1,value2 */
    terms?: string[] | undefined;
    /** Assigned groups for current user. Data format: user_groups:value1,value2 */
    userGroups?: string[] | undefined;
    /** Enable fuzzy search, i.e. allow to search color:white even if color:wihte actually passed to criteria */
    isFuzzySearch?: boolean;
    /** Gets or sets the search provider specific raw search query; all other search criteria will be ignored */
    rawQuery?: string | undefined;
    /** Allows to retrieve only a specific set of fields in the result hits */
    includeFields?: string[] | undefined;
    searchPhrase?: string | undefined;
    keyword?: string | undefined;
    responseGroup?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CategoryIndexedSearchResult implements ICategoryIndexedSearchResult {
    totalCount?: number;
    items?: Category[] | undefined;
    aggregations?: Aggregation[] | undefined;

    constructor(data?: ICategoryIndexedSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Category.fromJS(item));
            }
            if (Array.isArray(_data["aggregations"])) {
                this.aggregations = [] as any;
                for (let item of _data["aggregations"])
                    this.aggregations!.push(Aggregation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryIndexedSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryIndexedSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.aggregations)) {
            data["aggregations"] = [];
            for (let item of this.aggregations)
                data["aggregations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICategoryIndexedSearchResult {
    totalCount?: number;
    items?: Category[] | undefined;
    aggregations?: Aggregation[] | undefined;
}

export class CatalogListEntrySearchCriteria implements ICatalogListEntrySearchCriteria {
    code?: string | undefined;
    /** Search by vendor */
    vendorId?: string | undefined;
    vendorIds?: string[] | undefined;
    /** Search product with specified type */
    productType?: string | undefined;
    productTypes?: string[] | undefined;
    /** Exclude a specified product type from the search */
    excludeProductType?: string | undefined;
    excludeProductTypes?: string[] | undefined;
    withHidden?: boolean;
    hideDirectLinkedCategories?: boolean;
    /** Search within variations of specified main product */
    mainProductId?: string | undefined;
    /** Search  in all children categories for specified catalog or categories */
    searchInChildren?: boolean;
    /** Also search in variations */
    searchInVariations?: boolean;
    onlyBuyable?: boolean | undefined;
    onlyWithTrackingInventory?: boolean | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    categoryId?: string | undefined;
    categoryIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICatalogListEntrySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.vendorId = _data["vendorId"];
            if (Array.isArray(_data["vendorIds"])) {
                this.vendorIds = [] as any;
                for (let item of _data["vendorIds"])
                    this.vendorIds!.push(item);
            }
            this.productType = _data["productType"];
            if (Array.isArray(_data["productTypes"])) {
                this.productTypes = [] as any;
                for (let item of _data["productTypes"])
                    this.productTypes!.push(item);
            }
            this.excludeProductType = _data["excludeProductType"];
            if (Array.isArray(_data["excludeProductTypes"])) {
                this.excludeProductTypes = [] as any;
                for (let item of _data["excludeProductTypes"])
                    this.excludeProductTypes!.push(item);
            }
            this.withHidden = _data["withHidden"];
            this.hideDirectLinkedCategories = _data["hideDirectLinkedCategories"];
            this.mainProductId = _data["mainProductId"];
            this.searchInChildren = _data["searchInChildren"];
            this.searchInVariations = _data["searchInVariations"];
            this.onlyBuyable = _data["onlyBuyable"];
            this.onlyWithTrackingInventory = _data["onlyWithTrackingInventory"];
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CatalogListEntrySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogListEntrySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["vendorId"] = this.vendorId;
        if (Array.isArray(this.vendorIds)) {
            data["vendorIds"] = [];
            for (let item of this.vendorIds)
                data["vendorIds"].push(item);
        }
        data["productType"] = this.productType;
        if (Array.isArray(this.productTypes)) {
            data["productTypes"] = [];
            for (let item of this.productTypes)
                data["productTypes"].push(item);
        }
        data["excludeProductType"] = this.excludeProductType;
        if (Array.isArray(this.excludeProductTypes)) {
            data["excludeProductTypes"] = [];
            for (let item of this.excludeProductTypes)
                data["excludeProductTypes"].push(item);
        }
        data["withHidden"] = this.withHidden;
        data["hideDirectLinkedCategories"] = this.hideDirectLinkedCategories;
        data["mainProductId"] = this.mainProductId;
        data["searchInChildren"] = this.searchInChildren;
        data["searchInVariations"] = this.searchInVariations;
        data["onlyBuyable"] = this.onlyBuyable;
        data["onlyWithTrackingInventory"] = this.onlyWithTrackingInventory;
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ICatalogListEntrySearchCriteria {
    code?: string | undefined;
    /** Search by vendor */
    vendorId?: string | undefined;
    vendorIds?: string[] | undefined;
    /** Search product with specified type */
    productType?: string | undefined;
    productTypes?: string[] | undefined;
    /** Exclude a specified product type from the search */
    excludeProductType?: string | undefined;
    excludeProductTypes?: string[] | undefined;
    withHidden?: boolean;
    hideDirectLinkedCategories?: boolean;
    /** Search within variations of specified main product */
    mainProductId?: string | undefined;
    /** Search  in all children categories for specified catalog or categories */
    searchInChildren?: boolean;
    /** Also search in variations */
    searchInVariations?: boolean;
    onlyBuyable?: boolean | undefined;
    onlyWithTrackingInventory?: boolean | undefined;
    catalogId?: string | undefined;
    catalogIds?: string[] | undefined;
    categoryId?: string | undefined;
    categoryIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

/** Base class for all entries used in catalog categories browsing. */
export class ListEntryBase implements IListEntryBase {
    /** Gets or sets the type. E.g. "product", "category" */
    type?: string | undefined;
    /** Gets or sets a value indicating whether this entry is active. */
    isActive?: boolean | undefined;
    /** Gets or sets the image URL. */
    imageUrl?: string | undefined;
    /** Gets or sets the entry code. */
    code?: string | undefined;
    /** Gets or sets the name. */
    name?: string | undefined;
    /** Gets or sets the links. */
    links?: CategoryLink[] | undefined;
    /** All entry parents ids */
    outline?: string[] | undefined;
    /** All entry parents names */
    path?: string[] | undefined;
    /** Gets or sets the catalog id. */
    catalogId?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IListEntryBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.isActive = _data["isActive"];
            this.imageUrl = _data["imageUrl"];
            this.code = _data["code"];
            this.name = _data["name"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(CategoryLink.fromJS(item));
            }
            if (Array.isArray(_data["outline"])) {
                this.outline = [] as any;
                for (let item of _data["outline"])
                    this.outline!.push(item);
            }
            if (Array.isArray(_data["path"])) {
                this.path = [] as any;
                for (let item of _data["path"])
                    this.path!.push(item);
            }
            this.catalogId = _data["catalogId"];
            this.seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ListEntryBase {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntryBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["isActive"] = this.isActive;
        data["imageUrl"] = this.imageUrl;
        data["code"] = this.code;
        data["name"] = this.name;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        if (Array.isArray(this.outline)) {
            data["outline"] = [];
            for (let item of this.outline)
                data["outline"].push(item);
        }
        if (Array.isArray(this.path)) {
            data["path"] = [];
            for (let item of this.path)
                data["path"].push(item);
        }
        data["catalogId"] = this.catalogId;
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

/** Base class for all entries used in catalog categories browsing. */
export interface IListEntryBase {
    /** Gets or sets the type. E.g. "product", "category" */
    type?: string | undefined;
    /** Gets or sets a value indicating whether this entry is active. */
    isActive?: boolean | undefined;
    /** Gets or sets the image URL. */
    imageUrl?: string | undefined;
    /** Gets or sets the entry code. */
    code?: string | undefined;
    /** Gets or sets the name. */
    name?: string | undefined;
    /** Gets or sets the links. */
    links?: CategoryLink[] | undefined;
    /** All entry parents ids */
    outline?: string[] | undefined;
    /** All entry parents names */
    path?: string[] | undefined;
    /** Gets or sets the catalog id. */
    catalogId?: string | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ListEntrySearchResult implements IListEntrySearchResult {
    /** Gets or sets the list entries. */
    readonly listEntries?: ListEntryBase[] | undefined;
    totalCount?: number;
    results?: ListEntryBase[] | undefined;

    constructor(data?: IListEntrySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["listEntries"])) {
                (<any>this).listEntries = [] as any;
                for (let item of _data["listEntries"])
                    (<any>this).listEntries!.push(ListEntryBase.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ListEntryBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntrySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.listEntries)) {
            data["listEntries"] = [];
            for (let item of this.listEntries)
                data["listEntries"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListEntrySearchResult {
    /** Gets or sets the list entries. */
    listEntries?: ListEntryBase[] | undefined;
    totalCount?: number;
    results?: ListEntryBase[] | undefined;
}

/** Information to search and create links to categories and items */
export class BulkLinkCreationRequest implements IBulkLinkCreationRequest {
    searchCriteria?: CatalogListEntrySearchCriteria;
    /** The target category identifier for the link */
    categoryId?: string | undefined;
    /** The target catalog identifier for the link */
    catalogId?: string | undefined;

    constructor(data?: IBulkLinkCreationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCriteria = _data["searchCriteria"] ? CatalogListEntrySearchCriteria.fromJS(_data["searchCriteria"]) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.catalogId = _data["catalogId"];
        }
    }

    static fromJS(data: any): BulkLinkCreationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BulkLinkCreationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCriteria"] = this.searchCriteria ? this.searchCriteria.toJSON() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["catalogId"] = this.catalogId;
        return data; 
    }
}

/** Information to search and create links to categories and items */
export interface IBulkLinkCreationRequest {
    searchCriteria?: CatalogListEntrySearchCriteria;
    /** The target category identifier for the link */
    categoryId?: string | undefined;
    /** The target catalog identifier for the link */
    catalogId?: string | undefined;
}

/** Represents  move list entries command */
export class ListEntriesMoveRequest implements IListEntriesMoveRequest {
    catalog?: string | undefined;
    readonly catalogId?: string | undefined;
    category?: string | undefined;
    listEntries?: ListEntryBase[] | undefined;

    constructor(data?: IListEntriesMoveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalog = _data["catalog"];
            (<any>this).catalogId = _data["catalogId"];
            this.category = _data["category"];
            if (Array.isArray(_data["listEntries"])) {
                this.listEntries = [] as any;
                for (let item of _data["listEntries"])
                    this.listEntries!.push(ListEntryBase.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListEntriesMoveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListEntriesMoveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalog"] = this.catalog;
        data["catalogId"] = this.catalogId;
        data["category"] = this.category;
        if (Array.isArray(this.listEntries)) {
            data["listEntries"] = [];
            for (let item of this.listEntries)
                data["listEntries"].push(item.toJSON());
        }
        return data; 
    }
}

/** Represents  move list entries command */
export interface IListEntriesMoveRequest {
    catalog?: string | undefined;
    catalogId?: string | undefined;
    category?: string | undefined;
    listEntries?: ListEntryBase[] | undefined;
}

/** Search criteria used for search property dictionary items */
export class PropertyDictionaryItemSearchCriteria implements IPropertyDictionaryItemSearchCriteria {
    propertyIds?: string[] | undefined;
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPropertyDictionaryItemSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["propertyIds"])) {
                this.propertyIds = [] as any;
                for (let item of _data["propertyIds"])
                    this.propertyIds!.push(item);
            }
            if (Array.isArray(_data["catalogIds"])) {
                this.catalogIds = [] as any;
                for (let item of _data["catalogIds"])
                    this.catalogIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PropertyDictionaryItemSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItemSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.propertyIds)) {
            data["propertyIds"] = [];
            for (let item of this.propertyIds)
                data["propertyIds"].push(item);
        }
        if (Array.isArray(this.catalogIds)) {
            data["catalogIds"] = [];
            for (let item of this.catalogIds)
                data["catalogIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

/** Search criteria used for search property dictionary items */
export interface IPropertyDictionaryItemSearchCriteria {
    propertyIds?: string[] | undefined;
    catalogIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PropertyDictionaryItemLocalizedValue implements IPropertyDictionaryItemLocalizedValue {
    languageCode?: string | undefined;
    value?: string | undefined;

    constructor(data?: IPropertyDictionaryItemLocalizedValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageCode = _data["languageCode"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PropertyDictionaryItemLocalizedValue {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItemLocalizedValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageCode"] = this.languageCode;
        data["value"] = this.value;
        return data; 
    }
}

export interface IPropertyDictionaryItemLocalizedValue {
    languageCode?: string | undefined;
    value?: string | undefined;
}

export class PropertyDictionaryItem implements IPropertyDictionaryItem {
    propertyId?: string | undefined;
    alias?: string | undefined;
    sortOrder?: number;
    localizedValues?: PropertyDictionaryItemLocalizedValue[] | undefined;
    id?: string | undefined;

    constructor(data?: IPropertyDictionaryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.alias = _data["alias"];
            this.sortOrder = _data["sortOrder"];
            if (Array.isArray(_data["localizedValues"])) {
                this.localizedValues = [] as any;
                for (let item of _data["localizedValues"])
                    this.localizedValues!.push(PropertyDictionaryItemLocalizedValue.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PropertyDictionaryItem {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["alias"] = this.alias;
        data["sortOrder"] = this.sortOrder;
        if (Array.isArray(this.localizedValues)) {
            data["localizedValues"] = [];
            for (let item of this.localizedValues)
                data["localizedValues"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IPropertyDictionaryItem {
    propertyId?: string | undefined;
    alias?: string | undefined;
    sortOrder?: number;
    localizedValues?: PropertyDictionaryItemLocalizedValue[] | undefined;
    id?: string | undefined;
}

export class PropertyDictionaryItemSearchResult implements IPropertyDictionaryItemSearchResult {
    totalCount?: number;
    results?: PropertyDictionaryItem[] | undefined;

    constructor(data?: IPropertyDictionaryItemSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PropertyDictionaryItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PropertyDictionaryItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDictionaryItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPropertyDictionaryItemSearchResult {
    totalCount?: number;
    results?: PropertyDictionaryItem[] | undefined;
}

export class CsvProductPropertyMap implements ICsvProductPropertyMap {
    entityColumnName?: string | undefined;
    csvColumnName?: string | undefined;
    isSystemProperty?: boolean;
    isRequired?: boolean;
    customValue?: string | undefined;
    stringFormat?: string | undefined;
    locale?: string | undefined;

    constructor(data?: ICsvProductPropertyMap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityColumnName = _data["entityColumnName"];
            this.csvColumnName = _data["csvColumnName"];
            this.isSystemProperty = _data["isSystemProperty"];
            this.isRequired = _data["isRequired"];
            this.customValue = _data["customValue"];
            this.stringFormat = _data["stringFormat"];
            this.locale = _data["locale"];
        }
    }

    static fromJS(data: any): CsvProductPropertyMap {
        data = typeof data === 'object' ? data : {};
        let result = new CsvProductPropertyMap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityColumnName"] = this.entityColumnName;
        data["csvColumnName"] = this.csvColumnName;
        data["isSystemProperty"] = this.isSystemProperty;
        data["isRequired"] = this.isRequired;
        data["customValue"] = this.customValue;
        data["stringFormat"] = this.stringFormat;
        data["locale"] = this.locale;
        return data; 
    }
}

export interface ICsvProductPropertyMap {
    entityColumnName?: string | undefined;
    csvColumnName?: string | undefined;
    isSystemProperty?: boolean;
    isRequired?: boolean;
    customValue?: string | undefined;
    stringFormat?: string | undefined;
    locale?: string | undefined;
}

export class CsvProductMappingConfiguration implements ICsvProductMappingConfiguration {
    eTag?: string | undefined;
    delimiter?: string | undefined;
    csvColumns?: string[] | undefined;
    propertyMaps?: CsvProductPropertyMap[] | undefined;
    propertyCsvColumns?: string[] | undefined;

    constructor(data?: ICsvProductMappingConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.eTag = _data["eTag"];
            this.delimiter = _data["delimiter"];
            if (Array.isArray(_data["csvColumns"])) {
                this.csvColumns = [] as any;
                for (let item of _data["csvColumns"])
                    this.csvColumns!.push(item);
            }
            if (Array.isArray(_data["propertyMaps"])) {
                this.propertyMaps = [] as any;
                for (let item of _data["propertyMaps"])
                    this.propertyMaps!.push(CsvProductPropertyMap.fromJS(item));
            }
            if (Array.isArray(_data["propertyCsvColumns"])) {
                this.propertyCsvColumns = [] as any;
                for (let item of _data["propertyCsvColumns"])
                    this.propertyCsvColumns!.push(item);
            }
        }
    }

    static fromJS(data: any): CsvProductMappingConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new CsvProductMappingConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["eTag"] = this.eTag;
        data["delimiter"] = this.delimiter;
        if (Array.isArray(this.csvColumns)) {
            data["csvColumns"] = [];
            for (let item of this.csvColumns)
                data["csvColumns"].push(item);
        }
        if (Array.isArray(this.propertyMaps)) {
            data["propertyMaps"] = [];
            for (let item of this.propertyMaps)
                data["propertyMaps"].push(item.toJSON());
        }
        if (Array.isArray(this.propertyCsvColumns)) {
            data["propertyCsvColumns"] = [];
            for (let item of this.propertyCsvColumns)
                data["propertyCsvColumns"].push(item);
        }
        return data; 
    }
}

export interface ICsvProductMappingConfiguration {
    eTag?: string | undefined;
    delimiter?: string | undefined;
    csvColumns?: string[] | undefined;
    propertyMaps?: CsvProductPropertyMap[] | undefined;
    propertyCsvColumns?: string[] | undefined;
}

export class CsvExportInfo implements ICsvExportInfo {
    catalogId?: string | undefined;
    productIds?: string[] | undefined;
    categoryIds?: string[] | undefined;
    priceListId?: string | undefined;
    fulfilmentCenterId?: string | undefined;
    currency?: string | undefined;
    configuration?: CsvProductMappingConfiguration;

    constructor(data?: ICsvExportInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            if (Array.isArray(_data["categoryIds"])) {
                this.categoryIds = [] as any;
                for (let item of _data["categoryIds"])
                    this.categoryIds!.push(item);
            }
            this.priceListId = _data["priceListId"];
            this.fulfilmentCenterId = _data["fulfilmentCenterId"];
            this.currency = _data["currency"];
            this.configuration = _data["configuration"] ? CsvProductMappingConfiguration.fromJS(_data["configuration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CsvExportInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CsvExportInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        if (Array.isArray(this.categoryIds)) {
            data["categoryIds"] = [];
            for (let item of this.categoryIds)
                data["categoryIds"].push(item);
        }
        data["priceListId"] = this.priceListId;
        data["fulfilmentCenterId"] = this.fulfilmentCenterId;
        data["currency"] = this.currency;
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICsvExportInfo {
    catalogId?: string | undefined;
    productIds?: string[] | undefined;
    categoryIds?: string[] | undefined;
    priceListId?: string | undefined;
    fulfilmentCenterId?: string | undefined;
    currency?: string | undefined;
    configuration?: CsvProductMappingConfiguration;
}

/** Notification for catalog data export job. */
export class ExportNotification implements IExportNotification {
    /** Gets or sets the URL for downloading exported data. */
    downloadUrl?: string | undefined;
    /** Gets or sets the job finish date and time. */
    finished?: Date | undefined;
    /** Gets or sets the total count of objects to process. */
    totalCount?: number;
    /** Gets or sets the count of processed objects. */
    processedCount?: number;
    /** Gets the count of errors during processing. */
    readonly errorCount?: number;
    /** Gets or sets the errors that has occurred during processing. */
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IExportNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadUrl = _data["downloadUrl"];
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ExportNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ExportNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadUrl"] = this.downloadUrl;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

/** Notification for catalog data export job. */
export interface IExportNotification {
    /** Gets or sets the URL for downloading exported data. */
    downloadUrl?: string | undefined;
    /** Gets or sets the job finish date and time. */
    finished?: Date | undefined;
    /** Gets or sets the total count of objects to process. */
    totalCount?: number;
    /** Gets or sets the count of processed objects. */
    processedCount?: number;
    /** Gets the count of errors during processing. */
    errorCount?: number;
    /** Gets or sets the errors that has occurred during processing. */
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class CsvImportInfo implements ICsvImportInfo {
    catalogId?: string | undefined;
    fileUrl?: string | undefined;
    configuration?: CsvProductMappingConfiguration;

    constructor(data?: ICsvImportInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.catalogId = _data["catalogId"];
            this.fileUrl = _data["fileUrl"];
            this.configuration = _data["configuration"] ? CsvProductMappingConfiguration.fromJS(_data["configuration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CsvImportInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CsvImportInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["catalogId"] = this.catalogId;
        data["fileUrl"] = this.fileUrl;
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICsvImportInfo {
    catalogId?: string | undefined;
    fileUrl?: string | undefined;
    configuration?: CsvProductMappingConfiguration;
}

/** Notification for catalog data import job. */
export class CatalogCsvImportNotification implements ICatalogCsvImportNotification {
    /** Gets or sets the job finish date and time. */
    finished?: Date | undefined;
    /** Gets or sets the total count of objects to process. */
    totalCount?: number;
    /** Gets or sets the count of processed objects. */
    processedCount?: number;
    /** Gets the count of errors during processing. */
    readonly errorCount?: number;
    /** Gets or sets the errors that has occurred during processing. */
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: ICatalogCsvImportNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CatalogCsvImportNotification {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogCsvImportNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

/** Notification for catalog data import job. */
export interface ICatalogCsvImportNotification {
    /** Gets or sets the job finish date and time. */
    finished?: Date | undefined;
    /** Gets or sets the total count of objects to process. */
    totalCount?: number;
    /** Gets or sets the count of processed objects. */
    processedCount?: number;
    /** Gets the count of errors during processing. */
    errorCount?: number;
    /** Gets or sets the errors that has occurred during processing. */
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ContentStatistic implements IContentStatistic {
    activeThemeName?: string | undefined;
    themesCount?: number;
    pagesCount?: number;
    blogsCount?: number;

    constructor(data?: IContentStatistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.activeThemeName = _data["activeThemeName"];
            this.themesCount = _data["themesCount"];
            this.pagesCount = _data["pagesCount"];
            this.blogsCount = _data["blogsCount"];
        }
    }

    static fromJS(data: any): ContentStatistic {
        data = typeof data === 'object' ? data : {};
        let result = new ContentStatistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activeThemeName"] = this.activeThemeName;
        data["themesCount"] = this.themesCount;
        data["pagesCount"] = this.pagesCount;
        data["blogsCount"] = this.blogsCount;
        return data; 
    }
}

export interface IContentStatistic {
    activeThemeName?: string | undefined;
    themesCount?: number;
    pagesCount?: number;
    blogsCount?: number;
}

export class ContentItem implements IContentItem {
    name?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    parentUrl?: string | undefined;
    modifiedDate?: Date | undefined;
    createdDate?: Date | undefined;

    constructor(data?: IContentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.url = _data["url"];
            this.relativeUrl = _data["relativeUrl"];
            this.parentUrl = _data["parentUrl"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentItem {
        data = typeof data === 'object' ? data : {};
        let result = new ContentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["url"] = this.url;
        data["relativeUrl"] = this.relativeUrl;
        data["parentUrl"] = this.parentUrl;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContentItem {
    name?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    parentUrl?: string | undefined;
    modifiedDate?: Date | undefined;
    createdDate?: Date | undefined;
}

export class ContentFolder implements IContentFolder {
    name?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    parentUrl?: string | undefined;
    modifiedDate?: Date | undefined;
    createdDate?: Date | undefined;

    constructor(data?: IContentFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.type = _data["type"];
            this.url = _data["url"];
            this.relativeUrl = _data["relativeUrl"];
            this.parentUrl = _data["parentUrl"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContentFolder {
        data = typeof data === 'object' ? data : {};
        let result = new ContentFolder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        data["url"] = this.url;
        data["relativeUrl"] = this.relativeUrl;
        data["parentUrl"] = this.parentUrl;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IContentFolder {
    name?: string | undefined;
    type?: string | undefined;
    url?: string | undefined;
    relativeUrl?: string | undefined;
    parentUrl?: string | undefined;
    modifiedDate?: Date | undefined;
    createdDate?: Date | undefined;
}

export class MenuLink implements IMenuLink {
    title?: string | undefined;
    url?: string | undefined;
    priority?: number;
    menuLinkListId?: string | undefined;
    associatedObjectId?: string | undefined;
    associatedObjectName?: string | undefined;
    associatedObjectType?: string | undefined;
    securityScopes?: string[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMenuLink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.url = _data["url"];
            this.priority = _data["priority"];
            this.menuLinkListId = _data["menuLinkListId"];
            this.associatedObjectId = _data["associatedObjectId"];
            this.associatedObjectName = _data["associatedObjectName"];
            this.associatedObjectType = _data["associatedObjectType"];
            if (Array.isArray(_data["securityScopes"])) {
                this.securityScopes = [] as any;
                for (let item of _data["securityScopes"])
                    this.securityScopes!.push(item);
            }
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MenuLink {
        data = typeof data === 'object' ? data : {};
        let result = new MenuLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["url"] = this.url;
        data["priority"] = this.priority;
        data["menuLinkListId"] = this.menuLinkListId;
        data["associatedObjectId"] = this.associatedObjectId;
        data["associatedObjectName"] = this.associatedObjectName;
        data["associatedObjectType"] = this.associatedObjectType;
        if (Array.isArray(this.securityScopes)) {
            data["securityScopes"] = [];
            for (let item of this.securityScopes)
                data["securityScopes"].push(item);
        }
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMenuLink {
    title?: string | undefined;
    url?: string | undefined;
    priority?: number;
    menuLinkListId?: string | undefined;
    associatedObjectId?: string | undefined;
    associatedObjectName?: string | undefined;
    associatedObjectType?: string | undefined;
    securityScopes?: string[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MenuLinkList implements IMenuLinkList {
    name?: string | undefined;
    storeId?: string | undefined;
    language?: string | undefined;
    menuLinks?: MenuLink[] | undefined;
    securityScopes?: string[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMenuLinkList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.storeId = _data["storeId"];
            this.language = _data["language"];
            if (Array.isArray(_data["menuLinks"])) {
                this.menuLinks = [] as any;
                for (let item of _data["menuLinks"])
                    this.menuLinks!.push(MenuLink.fromJS(item));
            }
            if (Array.isArray(_data["securityScopes"])) {
                this.securityScopes = [] as any;
                for (let item of _data["securityScopes"])
                    this.securityScopes!.push(item);
            }
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MenuLinkList {
        data = typeof data === 'object' ? data : {};
        let result = new MenuLinkList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["storeId"] = this.storeId;
        data["language"] = this.language;
        if (Array.isArray(this.menuLinks)) {
            data["menuLinks"] = [];
            for (let item of this.menuLinks)
                data["menuLinks"].push(item.toJSON());
        }
        if (Array.isArray(this.securityScopes)) {
            data["securityScopes"] = [];
            for (let item of this.securityScopes)
                data["securityScopes"].push(item);
        }
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMenuLinkList {
    name?: string | undefined;
    storeId?: string | undefined;
    language?: string | undefined;
    menuLinks?: MenuLink[] | undefined;
    securityScopes?: string[] | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export enum DigitShapes {
    Context = "Context",
    None = "None",
    NativeNational = "NativeNational",
}

export class NumberFormatInfo implements INumberFormatInfo {
    currencyDecimalDigits?: number;
    currencyDecimalSeparator?: string | undefined;
    readonly isReadOnly?: boolean;
    currencyGroupSizes?: number[] | undefined;
    numberGroupSizes?: number[] | undefined;
    percentGroupSizes?: number[] | undefined;
    currencyGroupSeparator?: string | undefined;
    currencySymbol?: string | undefined;
    naNSymbol?: string | undefined;
    currencyNegativePattern?: number;
    numberNegativePattern?: number;
    percentPositivePattern?: number;
    percentNegativePattern?: number;
    negativeInfinitySymbol?: string | undefined;
    negativeSign?: string | undefined;
    numberDecimalDigits?: number;
    numberDecimalSeparator?: string | undefined;
    numberGroupSeparator?: string | undefined;
    currencyPositivePattern?: number;
    positiveInfinitySymbol?: string | undefined;
    positiveSign?: string | undefined;
    percentDecimalDigits?: number;
    percentDecimalSeparator?: string | undefined;
    percentGroupSeparator?: string | undefined;
    percentSymbol?: string | undefined;
    perMilleSymbol?: string | undefined;
    nativeDigits?: string[] | undefined;
    digitSubstitution?: DigitShapes;

    constructor(data?: INumberFormatInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyDecimalDigits = _data["currencyDecimalDigits"];
            this.currencyDecimalSeparator = _data["currencyDecimalSeparator"];
            (<any>this).isReadOnly = _data["isReadOnly"];
            if (Array.isArray(_data["currencyGroupSizes"])) {
                this.currencyGroupSizes = [] as any;
                for (let item of _data["currencyGroupSizes"])
                    this.currencyGroupSizes!.push(item);
            }
            if (Array.isArray(_data["numberGroupSizes"])) {
                this.numberGroupSizes = [] as any;
                for (let item of _data["numberGroupSizes"])
                    this.numberGroupSizes!.push(item);
            }
            if (Array.isArray(_data["percentGroupSizes"])) {
                this.percentGroupSizes = [] as any;
                for (let item of _data["percentGroupSizes"])
                    this.percentGroupSizes!.push(item);
            }
            this.currencyGroupSeparator = _data["currencyGroupSeparator"];
            this.currencySymbol = _data["currencySymbol"];
            this.naNSymbol = _data["naNSymbol"];
            this.currencyNegativePattern = _data["currencyNegativePattern"];
            this.numberNegativePattern = _data["numberNegativePattern"];
            this.percentPositivePattern = _data["percentPositivePattern"];
            this.percentNegativePattern = _data["percentNegativePattern"];
            this.negativeInfinitySymbol = _data["negativeInfinitySymbol"];
            this.negativeSign = _data["negativeSign"];
            this.numberDecimalDigits = _data["numberDecimalDigits"];
            this.numberDecimalSeparator = _data["numberDecimalSeparator"];
            this.numberGroupSeparator = _data["numberGroupSeparator"];
            this.currencyPositivePattern = _data["currencyPositivePattern"];
            this.positiveInfinitySymbol = _data["positiveInfinitySymbol"];
            this.positiveSign = _data["positiveSign"];
            this.percentDecimalDigits = _data["percentDecimalDigits"];
            this.percentDecimalSeparator = _data["percentDecimalSeparator"];
            this.percentGroupSeparator = _data["percentGroupSeparator"];
            this.percentSymbol = _data["percentSymbol"];
            this.perMilleSymbol = _data["perMilleSymbol"];
            if (Array.isArray(_data["nativeDigits"])) {
                this.nativeDigits = [] as any;
                for (let item of _data["nativeDigits"])
                    this.nativeDigits!.push(item);
            }
            this.digitSubstitution = _data["digitSubstitution"];
        }
    }

    static fromJS(data: any): NumberFormatInfo {
        data = typeof data === 'object' ? data : {};
        let result = new NumberFormatInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyDecimalDigits"] = this.currencyDecimalDigits;
        data["currencyDecimalSeparator"] = this.currencyDecimalSeparator;
        data["isReadOnly"] = this.isReadOnly;
        if (Array.isArray(this.currencyGroupSizes)) {
            data["currencyGroupSizes"] = [];
            for (let item of this.currencyGroupSizes)
                data["currencyGroupSizes"].push(item);
        }
        if (Array.isArray(this.numberGroupSizes)) {
            data["numberGroupSizes"] = [];
            for (let item of this.numberGroupSizes)
                data["numberGroupSizes"].push(item);
        }
        if (Array.isArray(this.percentGroupSizes)) {
            data["percentGroupSizes"] = [];
            for (let item of this.percentGroupSizes)
                data["percentGroupSizes"].push(item);
        }
        data["currencyGroupSeparator"] = this.currencyGroupSeparator;
        data["currencySymbol"] = this.currencySymbol;
        data["naNSymbol"] = this.naNSymbol;
        data["currencyNegativePattern"] = this.currencyNegativePattern;
        data["numberNegativePattern"] = this.numberNegativePattern;
        data["percentPositivePattern"] = this.percentPositivePattern;
        data["percentNegativePattern"] = this.percentNegativePattern;
        data["negativeInfinitySymbol"] = this.negativeInfinitySymbol;
        data["negativeSign"] = this.negativeSign;
        data["numberDecimalDigits"] = this.numberDecimalDigits;
        data["numberDecimalSeparator"] = this.numberDecimalSeparator;
        data["numberGroupSeparator"] = this.numberGroupSeparator;
        data["currencyPositivePattern"] = this.currencyPositivePattern;
        data["positiveInfinitySymbol"] = this.positiveInfinitySymbol;
        data["positiveSign"] = this.positiveSign;
        data["percentDecimalDigits"] = this.percentDecimalDigits;
        data["percentDecimalSeparator"] = this.percentDecimalSeparator;
        data["percentGroupSeparator"] = this.percentGroupSeparator;
        data["percentSymbol"] = this.percentSymbol;
        data["perMilleSymbol"] = this.perMilleSymbol;
        if (Array.isArray(this.nativeDigits)) {
            data["nativeDigits"] = [];
            for (let item of this.nativeDigits)
                data["nativeDigits"].push(item);
        }
        data["digitSubstitution"] = this.digitSubstitution;
        return data; 
    }
}

export interface INumberFormatInfo {
    currencyDecimalDigits?: number;
    currencyDecimalSeparator?: string | undefined;
    isReadOnly?: boolean;
    currencyGroupSizes?: number[] | undefined;
    numberGroupSizes?: number[] | undefined;
    percentGroupSizes?: number[] | undefined;
    currencyGroupSeparator?: string | undefined;
    currencySymbol?: string | undefined;
    naNSymbol?: string | undefined;
    currencyNegativePattern?: number;
    numberNegativePattern?: number;
    percentPositivePattern?: number;
    percentNegativePattern?: number;
    negativeInfinitySymbol?: string | undefined;
    negativeSign?: string | undefined;
    numberDecimalDigits?: number;
    numberDecimalSeparator?: string | undefined;
    numberGroupSeparator?: string | undefined;
    currencyPositivePattern?: number;
    positiveInfinitySymbol?: string | undefined;
    positiveSign?: string | undefined;
    percentDecimalDigits?: number;
    percentDecimalSeparator?: string | undefined;
    percentGroupSeparator?: string | undefined;
    percentSymbol?: string | undefined;
    perMilleSymbol?: string | undefined;
    nativeDigits?: string[] | undefined;
    digitSubstitution?: DigitShapes;
}

/** Currency */
export class Currency implements ICurrency {
    /** Currency code may be used ISO 4217. */
    code?: string | undefined;
    cultureName?: string | undefined;
    englishName?: string | undefined;
    numberFormat?: NumberFormatInfo;
    /** name of the currency */
    name?: string | undefined;
    /** Flag specifies that this is the primary currency */
    isPrimary?: boolean;
    /** The exchange rate against the primary exchange rate of the currency. */
    exchangeRate?: number;
    /** Currency symbol */
    symbol?: string | undefined;
    /** Custom formatting pattern */
    customFormatting?: string | undefined;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.cultureName = _data["cultureName"];
            this.englishName = _data["englishName"];
            this.numberFormat = _data["numberFormat"] ? NumberFormatInfo.fromJS(_data["numberFormat"]) : <any>undefined;
            this.name = _data["name"];
            this.isPrimary = _data["isPrimary"];
            this.exchangeRate = _data["exchangeRate"];
            this.symbol = _data["symbol"];
            this.customFormatting = _data["customFormatting"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["cultureName"] = this.cultureName;
        data["englishName"] = this.englishName;
        data["numberFormat"] = this.numberFormat ? this.numberFormat.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["isPrimary"] = this.isPrimary;
        data["exchangeRate"] = this.exchangeRate;
        data["symbol"] = this.symbol;
        data["customFormatting"] = this.customFormatting;
        return data; 
    }
}

/** Currency */
export interface ICurrency {
    /** Currency code may be used ISO 4217. */
    code?: string | undefined;
    cultureName?: string | undefined;
    englishName?: string | undefined;
    numberFormat?: NumberFormatInfo;
    /** name of the currency */
    name?: string | undefined;
    /** Flag specifies that this is the primary currency */
    isPrimary?: boolean;
    /** The exchange rate against the primary exchange rate of the currency. */
    exchangeRate?: number;
    /** Currency symbol */
    symbol?: string | undefined;
    /** Custom formatting pattern */
    customFormatting?: string | undefined;
}

/** Represent predefined dimensions package type */
export class PackageType implements IPackageType {
    /** Package type name */
    name?: string | undefined;
    length?: number;
    width?: number;
    height?: number;
    measureUnit?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPackageType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.measureUnit = _data["measureUnit"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PackageType {
        data = typeof data === 'object' ? data : {};
        let result = new PackageType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["measureUnit"] = this.measureUnit;
        data["id"] = this.id;
        return data; 
    }
}

/** Represent predefined dimensions package type */
export interface IPackageType {
    /** Package type name */
    name?: string | undefined;
    length?: number;
    width?: number;
    height?: number;
    measureUnit?: string | undefined;
    id?: string | undefined;
}

export class Address implements IAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data; 
    }
}

export interface IAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class CustomerAddress implements ICustomerAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: ICustomerAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): CustomerAddress {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data; 
    }
}

export interface ICustomerAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class Note implements INote {
    title?: string | undefined;
    body?: string | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: INote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Note {
        data = typeof data === 'object' ? data : {};
        let result = new Note();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface INote {
    title?: string | undefined;
    body?: string | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Organization implements IOrganization {
    description?: string | undefined;
    businessCategory?: string | undefined;
    ownerId?: string | undefined;
    parentId?: string | undefined;
    readonly objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.businessCategory = _data["businessCategory"];
            this.ownerId = _data["ownerId"];
            this.parentId = _data["parentId"];
            (<any>this).objectType = _data["objectType"];
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["businessCategory"] = this.businessCategory;
        data["ownerId"] = this.ownerId;
        data["parentId"] = this.parentId;
        data["objectType"] = this.objectType;
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganization {
    description?: string | undefined;
    businessCategory?: string | undefined;
    ownerId?: string | undefined;
    parentId?: string | undefined;
    objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MembersSearchCriteria implements IMembersSearchCriteria {
    memberType?: string | undefined;
    memberTypes?: string[] | undefined;
    group?: string | undefined;
    groups?: string[] | undefined;
    memberId?: string | undefined;
    deepSearch?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IMembersSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberType = _data["memberType"];
            if (Array.isArray(_data["memberTypes"])) {
                this.memberTypes = [] as any;
                for (let item of _data["memberTypes"])
                    this.memberTypes!.push(item);
            }
            this.group = _data["group"];
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.memberId = _data["memberId"];
            this.deepSearch = _data["deepSearch"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): MembersSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new MembersSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        if (Array.isArray(this.memberTypes)) {
            data["memberTypes"] = [];
            for (let item of this.memberTypes)
                data["memberTypes"].push(item);
        }
        data["group"] = this.group;
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["memberId"] = this.memberId;
        data["deepSearch"] = this.deepSearch;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IMembersSearchCriteria {
    memberType?: string | undefined;
    memberTypes?: string[] | undefined;
    group?: string | undefined;
    groups?: string[] | undefined;
    memberId?: string | undefined;
    deepSearch?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class Member implements IMember {
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IMember) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMember {
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MemberSearchResult implements IMemberSearchResult {
    totalCount?: number;
    results?: Member[] | undefined;

    constructor(data?: IMemberSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Member.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new MemberSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMemberSearchResult {
    totalCount?: number;
    results?: Member[] | undefined;
}

export class Contact implements IContact {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    associatedOrganizations?: string[] | undefined;
    taxPayerId?: string | undefined;
    preferredDelivery?: string | undefined;
    preferredCommunication?: string | undefined;
    defaultShippingAddressId?: string | undefined;
    defaultBillingAddressId?: string | undefined;
    photoUrl?: string | undefined;
    readonly objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salutation = _data["salutation"];
            this.fullName = _data["fullName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.defaultLanguage = _data["defaultLanguage"];
            this.timeZone = _data["timeZone"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(item);
            }
            if (Array.isArray(_data["associatedOrganizations"])) {
                this.associatedOrganizations = [] as any;
                for (let item of _data["associatedOrganizations"])
                    this.associatedOrganizations!.push(item);
            }
            this.taxPayerId = _data["taxPayerId"];
            this.preferredDelivery = _data["preferredDelivery"];
            this.preferredCommunication = _data["preferredCommunication"];
            this.defaultShippingAddressId = _data["defaultShippingAddressId"];
            this.defaultBillingAddressId = _data["defaultBillingAddressId"];
            this.photoUrl = _data["photoUrl"];
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["securityAccounts"])) {
                this.securityAccounts = [] as any;
                for (let item of _data["securityAccounts"])
                    this.securityAccounts!.push(ApplicationUser.fromJS(item));
            }
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salutation"] = this.salutation;
        data["fullName"] = this.fullName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["defaultLanguage"] = this.defaultLanguage;
        data["timeZone"] = this.timeZone;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item);
        }
        if (Array.isArray(this.associatedOrganizations)) {
            data["associatedOrganizations"] = [];
            for (let item of this.associatedOrganizations)
                data["associatedOrganizations"].push(item);
        }
        data["taxPayerId"] = this.taxPayerId;
        data["preferredDelivery"] = this.preferredDelivery;
        data["preferredCommunication"] = this.preferredCommunication;
        data["defaultShippingAddressId"] = this.defaultShippingAddressId;
        data["defaultBillingAddressId"] = this.defaultBillingAddressId;
        data["photoUrl"] = this.photoUrl;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.securityAccounts)) {
            data["securityAccounts"] = [];
            for (let item of this.securityAccounts)
                data["securityAccounts"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContact {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    associatedOrganizations?: string[] | undefined;
    taxPayerId?: string | undefined;
    preferredDelivery?: string | undefined;
    preferredCommunication?: string | undefined;
    defaultShippingAddressId?: string | undefined;
    defaultBillingAddressId?: string | undefined;
    photoUrl?: string | undefined;
    objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class OrganizationSearchResult implements IOrganizationSearchResult {
    totalCount?: number;
    results?: Organization[] | undefined;

    constructor(data?: IOrganizationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Organization.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrganizationSearchResult {
    totalCount?: number;
    results?: Organization[] | undefined;
}

export class ContactSearchResult implements IContactSearchResult {
    totalCount?: number;
    results?: Contact[] | undefined;

    constructor(data?: IContactSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Contact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContactSearchResult {
    totalCount?: number;
    results?: Contact[] | undefined;
}

export class Vendor implements IVendor {
    description?: string | undefined;
    siteUrl?: string | undefined;
    logoUrl?: string | undefined;
    groupName?: string | undefined;
    readonly objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IVendor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.siteUrl = _data["siteUrl"];
            this.logoUrl = _data["logoUrl"];
            this.groupName = _data["groupName"];
            (<any>this).objectType = _data["objectType"];
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Vendor {
        data = typeof data === 'object' ? data : {};
        let result = new Vendor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["siteUrl"] = this.siteUrl;
        data["logoUrl"] = this.logoUrl;
        data["groupName"] = this.groupName;
        data["objectType"] = this.objectType;
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVendor {
    description?: string | undefined;
    siteUrl?: string | undefined;
    logoUrl?: string | undefined;
    groupName?: string | undefined;
    objectType?: string | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class VendorSearchResult implements IVendorSearchResult {
    readonly vendors?: Vendor[] | undefined;
    totalCount?: number;
    results?: Vendor[] | undefined;

    constructor(data?: IVendorSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["vendors"])) {
                (<any>this).vendors = [] as any;
                for (let item of _data["vendors"])
                    (<any>this).vendors!.push(Vendor.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Vendor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VendorSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.vendors)) {
            data["vendors"] = [];
            for (let item of this.vendors)
                data["vendors"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IVendorSearchResult {
    vendors?: Vendor[] | undefined;
    totalCount?: number;
    results?: Vendor[] | undefined;
}

export class Employee implements IEmployee {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    employeeType?: string | undefined;
    isActive?: boolean;
    photoUrl?: string | undefined;
    readonly objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.salutation = _data["salutation"];
            this.fullName = _data["fullName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.defaultLanguage = _data["defaultLanguage"];
            this.timeZone = _data["timeZone"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(item);
            }
            this.employeeType = _data["employeeType"];
            this.isActive = _data["isActive"];
            this.photoUrl = _data["photoUrl"];
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["securityAccounts"])) {
                this.securityAccounts = [] as any;
                for (let item of _data["securityAccounts"])
                    this.securityAccounts!.push(ApplicationUser.fromJS(item));
            }
            this.name = _data["name"];
            this.memberType = _data["memberType"];
            this.outerId = _data["outerId"];
            this.status = _data["status"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(CustomerAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["notes"])) {
                this.notes = [] as any;
                for (let item of _data["notes"])
                    this.notes!.push(Note.fromJS(item));
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["salutation"] = this.salutation;
        data["fullName"] = this.fullName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["defaultLanguage"] = this.defaultLanguage;
        data["timeZone"] = this.timeZone;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item);
        }
        data["employeeType"] = this.employeeType;
        data["isActive"] = this.isActive;
        data["photoUrl"] = this.photoUrl;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.securityAccounts)) {
            data["securityAccounts"] = [];
            for (let item of this.securityAccounts)
                data["securityAccounts"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["memberType"] = this.memberType;
        data["outerId"] = this.outerId;
        data["status"] = this.status;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.notes)) {
            data["notes"] = [];
            for (let item of this.notes)
                data["notes"].push(item.toJSON());
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEmployee {
    salutation?: string | undefined;
    fullName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    employeeType?: string | undefined;
    isActive?: boolean;
    photoUrl?: string | undefined;
    objectType?: string | undefined;
    securityAccounts?: ApplicationUser[] | undefined;
    name?: string | undefined;
    memberType?: string | undefined;
    outerId?: string | undefined;
    status?: string | undefined;
    addresses?: CustomerAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    notes?: Note[] | undefined;
    groups?: string[] | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

/** Export property information */
export class ExportedTypePropertyInfo implements IExportedTypePropertyInfo {
    /** Property name with the path from the exportable entity (e.g. for entity containing PropertyA with nested properties it could be "PropertyA.PropertyB.PropertyC"). */
    fullName?: string | undefined;
    /** Property group. Properties can be divided into different groups to simplify selection.
Group could be used for grouping property infos. */
    group?: string | undefined;
    /** User-friendly name for this property */
    displayName?: string | undefined;
    /** * Reserved for future use */
    isRequired?: boolean;

    constructor(data?: IExportedTypePropertyInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.group = _data["group"];
            this.displayName = _data["displayName"];
            this.isRequired = _data["isRequired"];
        }
    }

    static fromJS(data: any): ExportedTypePropertyInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ExportedTypePropertyInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["group"] = this.group;
        data["displayName"] = this.displayName;
        data["isRequired"] = this.isRequired;
        return data; 
    }
}

/** Export property information */
export interface IExportedTypePropertyInfo {
    /** Property name with the path from the exportable entity (e.g. for entity containing PropertyA with nested properties it could be "PropertyA.PropertyB.PropertyC"). */
    fullName?: string | undefined;
    /** Property group. Properties can be divided into different groups to simplify selection.
Group could be used for grouping property infos. */
    group?: string | undefined;
    /** User-friendly name for this property */
    displayName?: string | undefined;
    /** * Reserved for future use */
    isRequired?: boolean;
}

/** Metadata for exported type: properties information and version */
export class ExportedTypeMetadata implements IExportedTypeMetadata {
    version?: string | undefined;
    /** Exportable property infos array */
    propertyInfos?: ExportedTypePropertyInfo[] | undefined;

    constructor(data?: IExportedTypeMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            if (Array.isArray(_data["propertyInfos"])) {
                this.propertyInfos = [] as any;
                for (let item of _data["propertyInfos"])
                    this.propertyInfos!.push(ExportedTypePropertyInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportedTypeMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ExportedTypeMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        if (Array.isArray(this.propertyInfos)) {
            data["propertyInfos"] = [];
            for (let item of this.propertyInfos)
                data["propertyInfos"].push(item.toJSON());
        }
        return data; 
    }
}

/** Metadata for exported type: properties information and version */
export interface IExportedTypeMetadata {
    version?: string | undefined;
    /** Exportable property infos array */
    propertyInfos?: ExportedTypePropertyInfo[] | undefined;
}

/** Definition of exported entity type */
export class ExportedTypeDefinition implements IExportedTypeDefinition {
    /** Logical type name, given during registration. It could be non-equal to exportable type name. */
    typeName?: string | undefined;
    /** Logical group name. Entity types can be divided into different groups to simplify selection. */
    group?: string | undefined;
    metaData?: ExportedTypeMetadata;
    tabularMetaData?: ExportedTypeMetadata;
    /** Specific type name with which we could query exported type data. */
    exportDataQueryType?: string | undefined;
    /** Returns true if tabular export supported, VirtoCommerce.ExportModule.Core.Model.ExportedTypeDefinition.TabularMetaData is set . */
    readonly isTabularExportSupported?: boolean;
    /** Restrict access to select data for export */
    restrictDataSelectivity?: boolean;

    constructor(data?: IExportedTypeDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeName = _data["typeName"];
            this.group = _data["group"];
            this.metaData = _data["metaData"] ? ExportedTypeMetadata.fromJS(_data["metaData"]) : <any>undefined;
            this.tabularMetaData = _data["tabularMetaData"] ? ExportedTypeMetadata.fromJS(_data["tabularMetaData"]) : <any>undefined;
            this.exportDataQueryType = _data["exportDataQueryType"];
            (<any>this).isTabularExportSupported = _data["isTabularExportSupported"];
            this.restrictDataSelectivity = _data["restrictDataSelectivity"];
        }
    }

    static fromJS(data: any): ExportedTypeDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new ExportedTypeDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["group"] = this.group;
        data["metaData"] = this.metaData ? this.metaData.toJSON() : <any>undefined;
        data["tabularMetaData"] = this.tabularMetaData ? this.tabularMetaData.toJSON() : <any>undefined;
        data["exportDataQueryType"] = this.exportDataQueryType;
        data["isTabularExportSupported"] = this.isTabularExportSupported;
        data["restrictDataSelectivity"] = this.restrictDataSelectivity;
        return data; 
    }
}

/** Definition of exported entity type */
export interface IExportedTypeDefinition {
    /** Logical type name, given during registration. It could be non-equal to exportable type name. */
    typeName?: string | undefined;
    /** Logical group name. Entity types can be divided into different groups to simplify selection. */
    group?: string | undefined;
    metaData?: ExportedTypeMetadata;
    tabularMetaData?: ExportedTypeMetadata;
    /** Specific type name with which we could query exported type data. */
    exportDataQueryType?: string | undefined;
    /** Returns true if tabular export supported, VirtoCommerce.ExportModule.Core.Model.ExportedTypeDefinition.TabularMetaData is set . */
    isTabularExportSupported?: boolean;
    /** Restrict access to select data for export */
    restrictDataSelectivity?: boolean;
}

export class IExportProviderConfiguration implements IIExportProviderConfiguration {
    /** Type discriminator to instantiate proper descendant (e.g. thru the universal PolymorphJsonConverter) */
    type?: string | undefined;

    constructor(data?: IIExportProviderConfiguration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): IExportProviderConfiguration {
        data = typeof data === 'object' ? data : {};
        let result = new IExportProviderConfiguration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        return data; 
    }
}

export interface IIExportProviderConfiguration {
    /** Type discriminator to instantiate proper descendant (e.g. thru the universal PolymorphJsonConverter) */
    type?: string | undefined;
}

/** Interface for export provider implementation. The export provider allows to write object using the given TextWriter. */
export class IExportProvider implements IIExportProvider {
    /** Provider name. */
    readonly typeName?: string | undefined;
    /** Extension for resulting export file. */
    readonly exportedFileExtension?: string | undefined;
    /** Returns true if provider supports only plain tabular objects (without nested entities). */
    readonly isTabular?: boolean;
    configuration?: IExportProviderConfiguration;

    constructor(data?: IIExportProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeName = _data["typeName"];
            (<any>this).exportedFileExtension = _data["exportedFileExtension"];
            (<any>this).isTabular = _data["isTabular"];
            this.configuration = _data["configuration"] ? IExportProviderConfiguration.fromJS(_data["configuration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IExportProvider {
        data = typeof data === 'object' ? data : {};
        let result = new IExportProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["exportedFileExtension"] = this.exportedFileExtension;
        data["isTabular"] = this.isTabular;
        data["configuration"] = this.configuration ? this.configuration.toJSON() : <any>undefined;
        return data; 
    }
}

/** Interface for export provider implementation. The export provider allows to write object using the given TextWriter. */
export interface IIExportProvider {
    /** Provider name. */
    typeName?: string | undefined;
    /** Extension for resulting export file. */
    exportedFileExtension?: string | undefined;
    /** Returns true if provider supports only plain tabular objects (without nested entities). */
    isTabular?: boolean;
    configuration?: IExportProviderConfiguration;
}

/** Basic query information for data sources to retrieve exported data: included properties, paging, sorting, etc... Applied data sources expand it by adding certain criteria (for example, additional information for searching) */
export class ExportDataQuery implements IExportDataQuery {
    /** This used to instantiate a data query of this type at export start. */
    readonly exportTypeName?: string | undefined;
    /** Keyword to search data */
    keyword?: string | undefined;
    /** Object keys to search data */
    objectIds?: string[] | undefined;
    /** How to sort the dataset matching a query */
    sort?: string | undefined;
    /** User selected properties to export */
    includedProperties?: ExportedTypePropertyInfo[] | undefined;
    /** Paging: skip records */
    skip?: number | undefined;
    /** Paging: records in one page */
    take?: number | undefined;
    /** True means preview (lightweight) data is queried, false - full version requested */
    isPreview?: boolean;

    constructor(data?: IExportDataQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).exportTypeName = _data["exportTypeName"];
            this.keyword = _data["keyword"];
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.sort = _data["sort"];
            if (Array.isArray(_data["includedProperties"])) {
                this.includedProperties = [] as any;
                for (let item of _data["includedProperties"])
                    this.includedProperties!.push(ExportedTypePropertyInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
            this.isPreview = _data["isPreview"];
        }
    }

    static fromJS(data: any): ExportDataQuery {
        data = typeof data === 'object' ? data : {};
        let result = new ExportDataQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exportTypeName"] = this.exportTypeName;
        data["keyword"] = this.keyword;
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["sort"] = this.sort;
        if (Array.isArray(this.includedProperties)) {
            data["includedProperties"] = [];
            for (let item of this.includedProperties)
                data["includedProperties"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["isPreview"] = this.isPreview;
        return data; 
    }
}

/** Basic query information for data sources to retrieve exported data: included properties, paging, sorting, etc... Applied data sources expand it by adding certain criteria (for example, additional information for searching) */
export interface IExportDataQuery {
    /** This used to instantiate a data query of this type at export start. */
    exportTypeName?: string | undefined;
    /** Keyword to search data */
    keyword?: string | undefined;
    /** Object keys to search data */
    objectIds?: string[] | undefined;
    /** How to sort the dataset matching a query */
    sort?: string | undefined;
    /** User selected properties to export */
    includedProperties?: ExportedTypePropertyInfo[] | undefined;
    /** Paging: skip records */
    skip?: number | undefined;
    /** Paging: records in one page */
    take?: number | undefined;
    /** True means preview (lightweight) data is queried, false - full version requested */
    isPreview?: boolean;
}

/** Incapsulates data required to start export: export type, query for data to export, provider to record */
export class ExportDataRequest implements IExportDataRequest {
    /** Full type name of exportable entity */
    exportTypeName?: string | undefined;
    dataQuery?: ExportDataQuery;
    providerConfig?: IExportProviderConfiguration;
    /** Selected export provider name */
    providerName?: string | undefined;

    constructor(data?: IExportDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exportTypeName = _data["exportTypeName"];
            this.dataQuery = _data["dataQuery"] ? ExportDataQuery.fromJS(_data["dataQuery"]) : <any>undefined;
            this.providerConfig = _data["providerConfig"] ? IExportProviderConfiguration.fromJS(_data["providerConfig"]) : <any>undefined;
            this.providerName = _data["providerName"];
        }
    }

    static fromJS(data: any): ExportDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exportTypeName"] = this.exportTypeName;
        data["dataQuery"] = this.dataQuery ? this.dataQuery.toJSON() : <any>undefined;
        data["providerConfig"] = this.providerConfig ? this.providerConfig.toJSON() : <any>undefined;
        data["providerName"] = this.providerName;
        return data; 
    }
}

/** Incapsulates data required to start export: export type, query for data to export, provider to record */
export interface IExportDataRequest {
    /** Full type name of exportable entity */
    exportTypeName?: string | undefined;
    dataQuery?: ExportDataQuery;
    providerConfig?: IExportProviderConfiguration;
    /** Selected export provider name */
    providerName?: string | undefined;
}

/** Interface to implement exportble entities. */
export class IExportable implements IIExportable {
    id?: string | undefined;

    constructor(data?: IIExportable) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IExportable {
        data = typeof data === 'object' ? data : {};
        let result = new IExportable();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

/** Interface to implement exportble entities. */
export interface IIExportable {
    id?: string | undefined;
}

/** Exportable entities search result. */
export class ExportableSearchResult implements IExportableSearchResult {
    totalCount?: number;
    results?: IExportable[] | undefined;

    constructor(data?: IExportableSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(IExportable.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExportableSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ExportableSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

/** Exportable entities search result. */
export interface IExportableSearchResult {
    totalCount?: number;
    results?: IExportable[] | undefined;
}

export class PlatformExportPushNotification implements IPlatformExportPushNotification {
    downloadUrl?: string | undefined;
    jobId?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    readonly errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IPlatformExportPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.downloadUrl = _data["downloadUrl"];
            this.jobId = _data["jobId"];
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PlatformExportPushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new PlatformExportPushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["downloadUrl"] = this.downloadUrl;
        data["jobId"] = this.jobId;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPlatformExportPushNotification {
    downloadUrl?: string | undefined;
    jobId?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ExportCancellationRequest implements IExportCancellationRequest {
    jobId?: string | undefined;

    constructor(data?: IExportCancellationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): ExportCancellationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportCancellationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        return data; 
    }
}

export interface IExportCancellationRequest {
    jobId?: string | undefined;
}

export enum ResizeMethod {
    FixedSize = "FixedSize",
    FixedWidth = "FixedWidth",
    FixedHeight = "FixedHeight",
    Crop = "Crop",
}

export enum AnchorPosition {
    TopLeft = "TopLeft",
    TopCenter = "TopCenter",
    TopRight = "TopRight",
    CenterLeft = "CenterLeft",
    Center = "Center",
    CenterRight = "CenterRight",
    BottomLeft = "BottomLeft",
    BottomCenter = "BottomCenter",
    BottomRight = "BottomRight",
}

export enum JpegQuality {
    Low = "Low",
    Medium = "Medium",
    High = "High",
    VeryHigh = "VeryHigh",
}

export class ThumbnailOption implements IThumbnailOption {
    name?: string | undefined;
    fileSuffix?: string | undefined;
    resizeMethod?: ResizeMethod;
    width?: number | undefined;
    height?: number | undefined;
    backgroundColor?: string | undefined;
    anchorPosition?: AnchorPosition;
    jpegQuality?: JpegQuality;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IThumbnailOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fileSuffix = _data["fileSuffix"];
            this.resizeMethod = _data["resizeMethod"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.backgroundColor = _data["backgroundColor"];
            this.anchorPosition = _data["anchorPosition"];
            this.jpegQuality = _data["jpegQuality"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ThumbnailOption {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fileSuffix"] = this.fileSuffix;
        data["resizeMethod"] = this.resizeMethod;
        data["width"] = this.width;
        data["height"] = this.height;
        data["backgroundColor"] = this.backgroundColor;
        data["anchorPosition"] = this.anchorPosition;
        data["jpegQuality"] = this.jpegQuality;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IThumbnailOption {
    name?: string | undefined;
    fileSuffix?: string | undefined;
    resizeMethod?: ResizeMethod;
    width?: number | undefined;
    height?: number | undefined;
    backgroundColor?: string | undefined;
    anchorPosition?: AnchorPosition;
    jpegQuality?: JpegQuality;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ThumbnailOptionSearchCriteria implements IThumbnailOptionSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IThumbnailOptionSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ThumbnailOptionSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailOptionSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IThumbnailOptionSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ThumbnailOptionSearchResult implements IThumbnailOptionSearchResult {
    totalCount?: number;
    results?: ThumbnailOption[] | undefined;

    constructor(data?: IThumbnailOptionSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ThumbnailOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ThumbnailOptionSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailOptionSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IThumbnailOptionSearchResult {
    totalCount?: number;
    results?: ThumbnailOption[] | undefined;
}

export class ThumbnailTask implements IThumbnailTask {
    name?: string | undefined;
    lastRun?: Date | undefined;
    workPath?: string | undefined;
    thumbnailOptions?: ThumbnailOption[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IThumbnailTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.lastRun = _data["lastRun"] ? new Date(_data["lastRun"].toString()) : <any>undefined;
            this.workPath = _data["workPath"];
            if (Array.isArray(_data["thumbnailOptions"])) {
                this.thumbnailOptions = [] as any;
                for (let item of _data["thumbnailOptions"])
                    this.thumbnailOptions!.push(ThumbnailOption.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ThumbnailTask {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["lastRun"] = this.lastRun ? this.lastRun.toISOString() : <any>undefined;
        data["workPath"] = this.workPath;
        if (Array.isArray(this.thumbnailOptions)) {
            data["thumbnailOptions"] = [];
            for (let item of this.thumbnailOptions)
                data["thumbnailOptions"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IThumbnailTask {
    name?: string | undefined;
    lastRun?: Date | undefined;
    workPath?: string | undefined;
    thumbnailOptions?: ThumbnailOption[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ThumbnailTaskSearchCriteria implements IThumbnailTaskSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IThumbnailTaskSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ThumbnailTaskSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailTaskSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IThumbnailTaskSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ThumbnailTaskSearchResult implements IThumbnailTaskSearchResult {
    totalCount?: number;
    results?: ThumbnailTask[] | undefined;

    constructor(data?: IThumbnailTaskSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ThumbnailTask.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ThumbnailTaskSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailTaskSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IThumbnailTaskSearchResult {
    totalCount?: number;
    results?: ThumbnailTask[] | undefined;
}

export class ThumbnailsTaskRunRequest implements IThumbnailsTaskRunRequest {
    taskIds?: string[] | undefined;
    regenerate?: boolean;

    constructor(data?: IThumbnailsTaskRunRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["taskIds"])) {
                this.taskIds = [] as any;
                for (let item of _data["taskIds"])
                    this.taskIds!.push(item);
            }
            this.regenerate = _data["regenerate"];
        }
    }

    static fromJS(data: any): ThumbnailsTaskRunRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailsTaskRunRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.taskIds)) {
            data["taskIds"] = [];
            for (let item of this.taskIds)
                data["taskIds"].push(item);
        }
        data["regenerate"] = this.regenerate;
        return data; 
    }
}

export interface IThumbnailsTaskRunRequest {
    taskIds?: string[] | undefined;
    regenerate?: boolean;
}

export class ThumbnailProcessNotification implements IThumbnailProcessNotification {
    jobId?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IThumbnailProcessNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            this.errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ThumbnailProcessNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ThumbnailProcessNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IThumbnailProcessNotification {
    jobId?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class InventorySearchCriteria implements IInventorySearchCriteria {
    fulfillmentCenterIds?: string[] | undefined;
    productIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IInventorySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fulfillmentCenterIds"])) {
                this.fulfillmentCenterIds = [] as any;
                for (let item of _data["fulfillmentCenterIds"])
                    this.fulfillmentCenterIds!.push(item);
            }
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): InventorySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new InventorySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fulfillmentCenterIds)) {
            data["fulfillmentCenterIds"] = [];
            for (let item of this.fulfillmentCenterIds)
                data["fulfillmentCenterIds"].push(item);
        }
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IInventorySearchCriteria {
    fulfillmentCenterIds?: string[] | undefined;
    productIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class InventoryAddress implements IInventoryAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: IInventoryAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): InventoryAddress {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data; 
    }
}

export interface IInventoryAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class FulfillmentCenter implements IFulfillmentCenter {
    name?: string | undefined;
    description?: string | undefined;
    geoLocation?: string | undefined;
    address?: InventoryAddress;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IFulfillmentCenter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.geoLocation = _data["geoLocation"];
            this.address = _data["address"] ? InventoryAddress.fromJS(_data["address"]) : <any>undefined;
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): FulfillmentCenter {
        data = typeof data === 'object' ? data : {};
        let result = new FulfillmentCenter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["geoLocation"] = this.geoLocation;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IFulfillmentCenter {
    name?: string | undefined;
    description?: string | undefined;
    geoLocation?: string | undefined;
    address?: InventoryAddress;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export enum InventoryStatus {
    Disabled = "Disabled",
    Enabled = "Enabled",
    Ignored = "Ignored",
}

export class InventoryInfo implements IInventoryInfo {
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    fulfillmentCenter?: FulfillmentCenter;
    productId?: string | undefined;
    inStockQuantity?: number;
    reservedQuantity?: number;
    reorderMinQuantity?: number;
    preorderQuantity?: number;
    backorderQuantity?: number;
    allowBackorder?: boolean;
    allowPreorder?: boolean;
    inTransit?: number;
    preorderAvailabilityDate?: Date | undefined;
    backorderAvailabilityDate?: Date | undefined;
    status?: InventoryStatus;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IInventoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fulfillmentCenterId = _data["fulfillmentCenterId"];
            this.fulfillmentCenterName = _data["fulfillmentCenterName"];
            this.fulfillmentCenter = _data["fulfillmentCenter"] ? FulfillmentCenter.fromJS(_data["fulfillmentCenter"]) : <any>undefined;
            this.productId = _data["productId"];
            this.inStockQuantity = _data["inStockQuantity"];
            this.reservedQuantity = _data["reservedQuantity"];
            this.reorderMinQuantity = _data["reorderMinQuantity"];
            this.preorderQuantity = _data["preorderQuantity"];
            this.backorderQuantity = _data["backorderQuantity"];
            this.allowBackorder = _data["allowBackorder"];
            this.allowPreorder = _data["allowPreorder"];
            this.inTransit = _data["inTransit"];
            this.preorderAvailabilityDate = _data["preorderAvailabilityDate"] ? new Date(_data["preorderAvailabilityDate"].toString()) : <any>undefined;
            this.backorderAvailabilityDate = _data["backorderAvailabilityDate"] ? new Date(_data["backorderAvailabilityDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): InventoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fulfillmentCenterId"] = this.fulfillmentCenterId;
        data["fulfillmentCenterName"] = this.fulfillmentCenterName;
        data["fulfillmentCenter"] = this.fulfillmentCenter ? this.fulfillmentCenter.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["inStockQuantity"] = this.inStockQuantity;
        data["reservedQuantity"] = this.reservedQuantity;
        data["reorderMinQuantity"] = this.reorderMinQuantity;
        data["preorderQuantity"] = this.preorderQuantity;
        data["backorderQuantity"] = this.backorderQuantity;
        data["allowBackorder"] = this.allowBackorder;
        data["allowPreorder"] = this.allowPreorder;
        data["inTransit"] = this.inTransit;
        data["preorderAvailabilityDate"] = this.preorderAvailabilityDate ? this.preorderAvailabilityDate.toISOString() : <any>undefined;
        data["backorderAvailabilityDate"] = this.backorderAvailabilityDate ? this.backorderAvailabilityDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IInventoryInfo {
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    fulfillmentCenter?: FulfillmentCenter;
    productId?: string | undefined;
    inStockQuantity?: number;
    reservedQuantity?: number;
    reorderMinQuantity?: number;
    preorderQuantity?: number;
    backorderQuantity?: number;
    allowBackorder?: boolean;
    allowPreorder?: boolean;
    inTransit?: number;
    preorderAvailabilityDate?: Date | undefined;
    backorderAvailabilityDate?: Date | undefined;
    status?: InventoryStatus;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class InventoryInfoSearchResult implements IInventoryInfoSearchResult {
    totalCount?: number;
    results?: InventoryInfo[] | undefined;

    constructor(data?: IInventoryInfoSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(InventoryInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InventoryInfoSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryInfoSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInventoryInfoSearchResult {
    totalCount?: number;
    results?: InventoryInfo[] | undefined;
}

export class ProductInventorySearchCriteria implements IProductInventorySearchCriteria {
    productId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IProductInventorySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ProductInventorySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInventorySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IProductInventorySearchCriteria {
    productId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class FulfillmentCenterSearchCriteria implements IFulfillmentCenterSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IFulfillmentCenterSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): FulfillmentCenterSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new FulfillmentCenterSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IFulfillmentCenterSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class FulfillmentCenterSearchResult implements IFulfillmentCenterSearchResult {
    totalCount?: number;
    results?: FulfillmentCenter[] | undefined;

    constructor(data?: IFulfillmentCenterSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(FulfillmentCenter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FulfillmentCenterSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new FulfillmentCenterSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFulfillmentCenterSearchResult {
    totalCount?: number;
    results?: FulfillmentCenter[] | undefined;
}

export class DynamicContentPlaceSearchCriteria implements IDynamicContentPlaceSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicContentPlaceSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.folderId = _data["folderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicContentPlaceSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPlaceSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["folderId"] = this.folderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IDynamicContentPlaceSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class DynamicContentListEntry implements IDynamicContentListEntry {
    /** Gets or sets the type. E.g. "folder", "content-item", "content-place" */
    objectType?: string | undefined;
    /** Gets or sets the image URL. */
    imageUrl?: string | undefined;
    /** Gets or sets the name. */
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentListEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentListEntry {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentListEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicContentListEntry {
    /** Gets or sets the type. E.g. "folder", "content-item", "content-place" */
    objectType?: string | undefined;
    /** Gets or sets the image URL. */
    imageUrl?: string | undefined;
    /** Gets or sets the name. */
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentListEntrySearchResult implements IDynamicContentListEntrySearchResult {
    totalCount?: number;
    results?: DynamicContentListEntry[] | undefined;

    constructor(data?: IDynamicContentListEntrySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentListEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentListEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentListEntrySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDynamicContentListEntrySearchResult {
    totalCount?: number;
    results?: DynamicContentListEntry[] | undefined;
}

export class DynamicContentFolder implements IDynamicContentFolder {
    /** all parent folders names concatenated (Root\Child\Child2) */
    readonly path?: string | undefined;
    /** all parent folders ids concatenated (1;21;344) */
    readonly outline?: string | undefined;
    parentFolderId?: string | undefined;
    parentFolder?: DynamicContentFolder;
    readonly objectType?: string | undefined;
    /** Gets or sets the image URL. */
    imageUrl?: string | undefined;
    /** Gets or sets the name. */
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).path = _data["path"];
            (<any>this).outline = _data["outline"];
            this.parentFolderId = _data["parentFolderId"];
            this.parentFolder = _data["parentFolder"] ? DynamicContentFolder.fromJS(_data["parentFolder"]) : <any>undefined;
            (<any>this).objectType = _data["objectType"];
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentFolder {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentFolder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["outline"] = this.outline;
        data["parentFolderId"] = this.parentFolderId;
        data["parentFolder"] = this.parentFolder ? this.parentFolder.toJSON() : <any>undefined;
        data["objectType"] = this.objectType;
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicContentFolder {
    /** all parent folders names concatenated (Root\Child\Child2) */
    path?: string | undefined;
    /** all parent folders ids concatenated (1;21;344) */
    outline?: string | undefined;
    parentFolderId?: string | undefined;
    parentFolder?: DynamicContentFolder;
    objectType?: string | undefined;
    /** Gets or sets the image URL. */
    imageUrl?: string | undefined;
    /** Gets or sets the name. */
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentPlace implements IDynamicContentPlace {
    /** all parent folders ids concatenated (1;21;344) */
    readonly outline?: string | undefined;
    /** all parent folders names concatenated (Root\Child\Child2) */
    readonly path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    /** Gets or sets the type. E.g. "folder", "content-item", "content-place" */
    objectType?: string | undefined;
    /** Gets or sets the image URL. */
    imageUrl?: string | undefined;
    /** Gets or sets the name. */
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentPlace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            this.folderId = _data["folderId"];
            this.folder = _data["folder"] ? DynamicContentFolder.fromJS(_data["folder"]) : <any>undefined;
            this.objectType = _data["objectType"];
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentPlace {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPlace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["folderId"] = this.folderId;
        data["folder"] = this.folder ? this.folder.toJSON() : <any>undefined;
        data["objectType"] = this.objectType;
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicContentPlace {
    /** all parent folders ids concatenated (1;21;344) */
    outline?: string | undefined;
    /** all parent folders names concatenated (Root\Child\Child2) */
    path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    /** Gets or sets the type. E.g. "folder", "content-item", "content-place" */
    objectType?: string | undefined;
    /** Gets or sets the image URL. */
    imageUrl?: string | undefined;
    /** Gets or sets the name. */
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentPlaceSearchResult implements IDynamicContentPlaceSearchResult {
    totalCount?: number;
    results?: DynamicContentPlace[] | undefined;

    constructor(data?: IDynamicContentPlaceSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentPlace.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentPlaceSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPlaceSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDynamicContentPlaceSearchResult {
    totalCount?: number;
    results?: DynamicContentPlace[] | undefined;
}

export class DynamicContentItemSearchCriteria implements IDynamicContentItemSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicContentItemSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.folderId = _data["folderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicContentItemSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentItemSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["folderId"] = this.folderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IDynamicContentItemSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class DynamicContentItem implements IDynamicContentItem {
    contentType?: string | undefined;
    priority?: number;
    /** all parent folders ids concatenated (1;21;344) */
    readonly outline?: string | undefined;
    /** all parent folders names concatenated (Root\Child\Child2) */
    readonly path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    /** Gets or sets the image URL. */
    imageUrl?: string | undefined;
    /** Gets or sets the name. */
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentType = _data["contentType"];
            this.priority = _data["priority"];
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            this.folderId = _data["folderId"];
            this.folder = _data["folder"] ? DynamicContentFolder.fromJS(_data["folder"]) : <any>undefined;
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentItem {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        data["priority"] = this.priority;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["folderId"] = this.folderId;
        data["folder"] = this.folder ? this.folder.toJSON() : <any>undefined;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicContentItem {
    contentType?: string | undefined;
    priority?: number;
    /** all parent folders ids concatenated (1;21;344) */
    outline?: string | undefined;
    /** all parent folders names concatenated (Root\Child\Child2) */
    path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    /** Gets or sets the image URL. */
    imageUrl?: string | undefined;
    /** Gets or sets the name. */
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentItemSearchResult implements IDynamicContentItemSearchResult {
    totalCount?: number;
    results?: DynamicContentItem[] | undefined;

    constructor(data?: IDynamicContentItemSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDynamicContentItemSearchResult {
    totalCount?: number;
    results?: DynamicContentItem[] | undefined;
}

export class DynamicContentPublicationSearchCriteria implements IDynamicContentPublicationSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    placeName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicContentPublicationSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlyActive = _data["onlyActive"];
            this.store = _data["store"];
            this.placeName = _data["placeName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.folderId = _data["folderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicContentPublicationSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPublicationSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlyActive"] = this.onlyActive;
        data["store"] = this.store;
        data["placeName"] = this.placeName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["folderId"] = this.folderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IDynamicContentPublicationSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    placeName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class DynamicContentConditionTree implements IDynamicContentConditionTree {
    all?: boolean;
    not?: boolean;
    readonly id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;

    constructor(data?: IDynamicContentConditionTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.all = _data["all"];
            this.not = _data["not"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                this.availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    this.availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentConditionTree {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentConditionTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["all"] = this.all;
        data["not"] = this.not;
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDynamicContentConditionTree {
    all?: boolean;
    not?: boolean;
    id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

export class DynamicContentPublication implements IDynamicContentPublication {
    name?: string | undefined;
    description?: string | undefined;
    priority?: number;
    isActive?: boolean;
    storeId?: string | undefined;
    dynamicExpression?: DynamicContentConditionTree;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    contentItems?: DynamicContentItem[] | undefined;
    contentPlaces?: DynamicContentPlace[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentPublication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.priority = _data["priority"];
            this.isActive = _data["isActive"];
            this.storeId = _data["storeId"];
            this.dynamicExpression = _data["dynamicExpression"] ? DynamicContentConditionTree.fromJS(_data["dynamicExpression"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["contentItems"])) {
                this.contentItems = [] as any;
                for (let item of _data["contentItems"])
                    this.contentItems!.push(DynamicContentItem.fromJS(item));
            }
            if (Array.isArray(_data["contentPlaces"])) {
                this.contentPlaces = [] as any;
                for (let item of _data["contentPlaces"])
                    this.contentPlaces!.push(DynamicContentPlace.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentPublication {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPublication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["priority"] = this.priority;
        data["isActive"] = this.isActive;
        data["storeId"] = this.storeId;
        data["dynamicExpression"] = this.dynamicExpression ? this.dynamicExpression.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.contentItems)) {
            data["contentItems"] = [];
            for (let item of this.contentItems)
                data["contentItems"].push(item.toJSON());
        }
        if (Array.isArray(this.contentPlaces)) {
            data["contentPlaces"] = [];
            for (let item of this.contentPlaces)
                data["contentPlaces"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IDynamicContentPublication {
    name?: string | undefined;
    description?: string | undefined;
    priority?: number;
    isActive?: boolean;
    storeId?: string | undefined;
    dynamicExpression?: DynamicContentConditionTree;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    contentItems?: DynamicContentItem[] | undefined;
    contentPlaces?: DynamicContentPlace[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentPublicationSearchResult implements IDynamicContentPublicationSearchResult {
    totalCount?: number;
    results?: DynamicContentPublication[] | undefined;

    constructor(data?: IDynamicContentPublicationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentPublication.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentPublicationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPublicationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDynamicContentPublicationSearchResult {
    totalCount?: number;
    results?: DynamicContentPublication[] | undefined;
}

export class DynamicContentEvaluationContext implements IDynamicContentEvaluationContext {
    storeId?: string | undefined;
    placeName?: string | undefined;
    tags?: string[] | undefined;
    toDate?: Date;
    categoryId?: string | undefined;
    productId?: string | undefined;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;

    constructor(data?: IDynamicContentEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.placeName = _data["placeName"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.productId = _data["productId"];
            this.contextObject = _data["contextObject"];
            this.geoCity = _data["geoCity"];
            this.geoState = _data["geoState"];
            this.geoCountry = _data["geoCountry"];
            this.geoContinent = _data["geoContinent"];
            this.geoZipCode = _data["geoZipCode"];
            this.geoConnectionType = _data["geoConnectionType"];
            this.geoTimeZone = _data["geoTimeZone"];
            this.geoIpRoutingType = _data["geoIpRoutingType"];
            this.geoIspSecondLevel = _data["geoIspSecondLevel"];
            this.geoIspTopLevel = _data["geoIspTopLevel"];
            this.shopperAge = _data["shopperAge"];
            this.shopperGender = _data["shopperGender"];
            this.language = _data["language"];
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
            this.shopperSearchedPhraseOnInternet = _data["shopperSearchedPhraseOnInternet"];
            this.currentUrl = _data["currentUrl"];
            this.referredUrl = _data["referredUrl"];
        }
    }

    static fromJS(data: any): DynamicContentEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["placeName"] = this.placeName;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["productId"] = this.productId;
        data["contextObject"] = this.contextObject;
        data["geoCity"] = this.geoCity;
        data["geoState"] = this.geoState;
        data["geoCountry"] = this.geoCountry;
        data["geoContinent"] = this.geoContinent;
        data["geoZipCode"] = this.geoZipCode;
        data["geoConnectionType"] = this.geoConnectionType;
        data["geoTimeZone"] = this.geoTimeZone;
        data["geoIpRoutingType"] = this.geoIpRoutingType;
        data["geoIspSecondLevel"] = this.geoIspSecondLevel;
        data["geoIspTopLevel"] = this.geoIspTopLevel;
        data["shopperAge"] = this.shopperAge;
        data["shopperGender"] = this.shopperGender;
        data["language"] = this.language;
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
        data["shopperSearchedPhraseOnInternet"] = this.shopperSearchedPhraseOnInternet;
        data["currentUrl"] = this.currentUrl;
        data["referredUrl"] = this.referredUrl;
        return data; 
    }
}

export interface IDynamicContentEvaluationContext {
    storeId?: string | undefined;
    placeName?: string | undefined;
    tags?: string[] | undefined;
    toDate?: Date;
    categoryId?: string | undefined;
    productId?: string | undefined;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;
}

export class PromotionSearchCriteria implements IPromotionSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPromotionSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlyActive = _data["onlyActive"];
            this.store = _data["store"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PromotionSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlyActive"] = this.onlyActive;
        data["store"] = this.store;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IPromotionSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PromotionConditionAndRewardTree implements IPromotionConditionAndRewardTree {
    all?: boolean;
    not?: boolean;
    readonly id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;

    constructor(data?: IPromotionConditionAndRewardTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.all = _data["all"];
            this.not = _data["not"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                this.availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    this.availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PromotionConditionAndRewardTree {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionConditionAndRewardTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["all"] = this.all;
        data["not"] = this.not;
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPromotionConditionAndRewardTree {
    all?: boolean;
    not?: boolean;
    id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

export class Promotion implements IPromotion {
    /** If this flag is set to true, it allows this promotion to combine with itself.
Special for case when need to return same promotion rewards for multiple coupons */
    isAllowCombiningWithSelf?: boolean;
    dynamicExpression?: PromotionConditionAndRewardTree;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    /** Promotion name */
    name?: string | undefined;
    /** Required for UI. TODO: remove later */
    type?: string | undefined;
    isActive?: boolean;
    /** Represents a promotion priority, for combination policies when it is necessary to select a promotion with a higher priority */
    priority?: number;
    /** If a promotion with this setting is applied, no other promotions can be applied to the order. */
    isExclusive?: boolean;
    hasCoupons?: boolean;
    description?: string | undefined;
    /** Maximum redemptions for this promotion */
    maxUsageCount?: number;
    /** Maximum redemptions on a single order */
    maxUsageOnOrder?: number;
    /** Maximum redemptions by a single customer */
    maxPersonalUsageCount?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPromotion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAllowCombiningWithSelf = _data["isAllowCombiningWithSelf"];
            this.dynamicExpression = _data["dynamicExpression"] ? PromotionConditionAndRewardTree.fromJS(_data["dynamicExpression"]) : <any>undefined;
            this.store = _data["store"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.name = _data["name"];
            this.type = _data["type"];
            this.isActive = _data["isActive"];
            this.priority = _data["priority"];
            this.isExclusive = _data["isExclusive"];
            this.hasCoupons = _data["hasCoupons"];
            this.description = _data["description"];
            this.maxUsageCount = _data["maxUsageCount"];
            this.maxUsageOnOrder = _data["maxUsageOnOrder"];
            this.maxPersonalUsageCount = _data["maxPersonalUsageCount"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Promotion {
        data = typeof data === 'object' ? data : {};
        let result = new Promotion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAllowCombiningWithSelf"] = this.isAllowCombiningWithSelf;
        data["dynamicExpression"] = this.dynamicExpression ? this.dynamicExpression.toJSON() : <any>undefined;
        data["store"] = this.store;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["name"] = this.name;
        data["type"] = this.type;
        data["isActive"] = this.isActive;
        data["priority"] = this.priority;
        data["isExclusive"] = this.isExclusive;
        data["hasCoupons"] = this.hasCoupons;
        data["description"] = this.description;
        data["maxUsageCount"] = this.maxUsageCount;
        data["maxUsageOnOrder"] = this.maxUsageOnOrder;
        data["maxPersonalUsageCount"] = this.maxPersonalUsageCount;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPromotion {
    /** If this flag is set to true, it allows this promotion to combine with itself.
Special for case when need to return same promotion rewards for multiple coupons */
    isAllowCombiningWithSelf?: boolean;
    dynamicExpression?: PromotionConditionAndRewardTree;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    /** Promotion name */
    name?: string | undefined;
    /** Required for UI. TODO: remove later */
    type?: string | undefined;
    isActive?: boolean;
    /** Represents a promotion priority, for combination policies when it is necessary to select a promotion with a higher priority */
    priority?: number;
    /** If a promotion with this setting is applied, no other promotions can be applied to the order. */
    isExclusive?: boolean;
    hasCoupons?: boolean;
    description?: string | undefined;
    /** Maximum redemptions for this promotion */
    maxUsageCount?: number;
    /** Maximum redemptions on a single order */
    maxUsageOnOrder?: number;
    /** Maximum redemptions by a single customer */
    maxPersonalUsageCount?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class PromotionSearchResult implements IPromotionSearchResult {
    totalCount?: number;
    results?: Promotion[] | undefined;

    constructor(data?: IPromotionSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Promotion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PromotionSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPromotionSearchResult {
    totalCount?: number;
    results?: Promotion[] | undefined;
}

export class ProductPromoEntry implements IProductPromoEntry {
    code?: string | undefined;
    quantity?: number;
    inStockQuantity?: number;
    price?: number;
    listPrice?: number;
    discount?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    productId?: string | undefined;
    owner?: any | undefined;
    outline?: string | undefined;
    variations?: ProductPromoEntry[] | undefined;
    attributes?: { [key: string]: string; } | undefined;

    constructor(data?: IProductPromoEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.quantity = _data["quantity"];
            this.inStockQuantity = _data["inStockQuantity"];
            this.price = _data["price"];
            this.listPrice = _data["listPrice"];
            this.discount = _data["discount"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.productId = _data["productId"];
            this.owner = _data["owner"];
            this.outline = _data["outline"];
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(ProductPromoEntry.fromJS(item));
            }
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductPromoEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPromoEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["quantity"] = this.quantity;
        data["inStockQuantity"] = this.inStockQuantity;
        data["price"] = this.price;
        data["listPrice"] = this.listPrice;
        data["discount"] = this.discount;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["productId"] = this.productId;
        data["owner"] = this.owner;
        data["outline"] = this.outline;
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IProductPromoEntry {
    code?: string | undefined;
    quantity?: number;
    inStockQuantity?: number;
    price?: number;
    listPrice?: number;
    discount?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    productId?: string | undefined;
    owner?: any | undefined;
    outline?: string | undefined;
    variations?: ProductPromoEntry[] | undefined;
    attributes?: { [key: string]: string; } | undefined;
}

export class PromotionEvaluationContext implements IPromotionEvaluationContext {
    refusedGiftIds?: string[] | undefined;
    storeId?: string | undefined;
    currency?: string | undefined;
    /** Customer id */
    customerId?: string | undefined;
    isRegisteredUser?: boolean;
    /** Has user made any orders */
    isFirstTimeBuyer?: boolean;
    isEveryone?: boolean;
    cartTotal?: number;
    /** Current shipment method */
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    shipmentMethodPrice?: number;
    availableShipmentMethodCodes?: string[] | undefined;
    /** Current payment method */
    paymentMethodCode?: string | undefined;
    paymentMethodPrice?: number;
    availablePaymentMethodCodes?: string[] | undefined;
    /** Entered coupon */
    coupon?: string | undefined;
    coupons?: string[] | undefined;
    /** List of product promo in cart */
    cartPromoEntries?: ProductPromoEntry[] | undefined;
    /** List of products for promo evaluation */
    promoEntries?: ProductPromoEntry[] | undefined;
    promoEntry?: ProductPromoEntry;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;

    constructor(data?: IPromotionEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["refusedGiftIds"])) {
                this.refusedGiftIds = [] as any;
                for (let item of _data["refusedGiftIds"])
                    this.refusedGiftIds!.push(item);
            }
            this.storeId = _data["storeId"];
            this.currency = _data["currency"];
            this.customerId = _data["customerId"];
            this.isRegisteredUser = _data["isRegisteredUser"];
            this.isFirstTimeBuyer = _data["isFirstTimeBuyer"];
            this.isEveryone = _data["isEveryone"];
            this.cartTotal = _data["cartTotal"];
            this.shipmentMethodCode = _data["shipmentMethodCode"];
            this.shipmentMethodOption = _data["shipmentMethodOption"];
            this.shipmentMethodPrice = _data["shipmentMethodPrice"];
            if (Array.isArray(_data["availableShipmentMethodCodes"])) {
                this.availableShipmentMethodCodes = [] as any;
                for (let item of _data["availableShipmentMethodCodes"])
                    this.availableShipmentMethodCodes!.push(item);
            }
            this.paymentMethodCode = _data["paymentMethodCode"];
            this.paymentMethodPrice = _data["paymentMethodPrice"];
            if (Array.isArray(_data["availablePaymentMethodCodes"])) {
                this.availablePaymentMethodCodes = [] as any;
                for (let item of _data["availablePaymentMethodCodes"])
                    this.availablePaymentMethodCodes!.push(item);
            }
            this.coupon = _data["coupon"];
            if (Array.isArray(_data["coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["coupons"])
                    this.coupons!.push(item);
            }
            if (Array.isArray(_data["cartPromoEntries"])) {
                this.cartPromoEntries = [] as any;
                for (let item of _data["cartPromoEntries"])
                    this.cartPromoEntries!.push(ProductPromoEntry.fromJS(item));
            }
            if (Array.isArray(_data["promoEntries"])) {
                this.promoEntries = [] as any;
                for (let item of _data["promoEntries"])
                    this.promoEntries!.push(ProductPromoEntry.fromJS(item));
            }
            this.promoEntry = _data["promoEntry"] ? ProductPromoEntry.fromJS(_data["promoEntry"]) : <any>undefined;
            this.contextObject = _data["contextObject"];
            this.geoCity = _data["geoCity"];
            this.geoState = _data["geoState"];
            this.geoCountry = _data["geoCountry"];
            this.geoContinent = _data["geoContinent"];
            this.geoZipCode = _data["geoZipCode"];
            this.geoConnectionType = _data["geoConnectionType"];
            this.geoTimeZone = _data["geoTimeZone"];
            this.geoIpRoutingType = _data["geoIpRoutingType"];
            this.geoIspSecondLevel = _data["geoIspSecondLevel"];
            this.geoIspTopLevel = _data["geoIspTopLevel"];
            this.shopperAge = _data["shopperAge"];
            this.shopperGender = _data["shopperGender"];
            this.language = _data["language"];
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
            this.shopperSearchedPhraseOnInternet = _data["shopperSearchedPhraseOnInternet"];
            this.currentUrl = _data["currentUrl"];
            this.referredUrl = _data["referredUrl"];
        }
    }

    static fromJS(data: any): PromotionEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.refusedGiftIds)) {
            data["refusedGiftIds"] = [];
            for (let item of this.refusedGiftIds)
                data["refusedGiftIds"].push(item);
        }
        data["storeId"] = this.storeId;
        data["currency"] = this.currency;
        data["customerId"] = this.customerId;
        data["isRegisteredUser"] = this.isRegisteredUser;
        data["isFirstTimeBuyer"] = this.isFirstTimeBuyer;
        data["isEveryone"] = this.isEveryone;
        data["cartTotal"] = this.cartTotal;
        data["shipmentMethodCode"] = this.shipmentMethodCode;
        data["shipmentMethodOption"] = this.shipmentMethodOption;
        data["shipmentMethodPrice"] = this.shipmentMethodPrice;
        if (Array.isArray(this.availableShipmentMethodCodes)) {
            data["availableShipmentMethodCodes"] = [];
            for (let item of this.availableShipmentMethodCodes)
                data["availableShipmentMethodCodes"].push(item);
        }
        data["paymentMethodCode"] = this.paymentMethodCode;
        data["paymentMethodPrice"] = this.paymentMethodPrice;
        if (Array.isArray(this.availablePaymentMethodCodes)) {
            data["availablePaymentMethodCodes"] = [];
            for (let item of this.availablePaymentMethodCodes)
                data["availablePaymentMethodCodes"].push(item);
        }
        data["coupon"] = this.coupon;
        if (Array.isArray(this.coupons)) {
            data["coupons"] = [];
            for (let item of this.coupons)
                data["coupons"].push(item);
        }
        if (Array.isArray(this.cartPromoEntries)) {
            data["cartPromoEntries"] = [];
            for (let item of this.cartPromoEntries)
                data["cartPromoEntries"].push(item.toJSON());
        }
        if (Array.isArray(this.promoEntries)) {
            data["promoEntries"] = [];
            for (let item of this.promoEntries)
                data["promoEntries"].push(item.toJSON());
        }
        data["promoEntry"] = this.promoEntry ? this.promoEntry.toJSON() : <any>undefined;
        data["contextObject"] = this.contextObject;
        data["geoCity"] = this.geoCity;
        data["geoState"] = this.geoState;
        data["geoCountry"] = this.geoCountry;
        data["geoContinent"] = this.geoContinent;
        data["geoZipCode"] = this.geoZipCode;
        data["geoConnectionType"] = this.geoConnectionType;
        data["geoTimeZone"] = this.geoTimeZone;
        data["geoIpRoutingType"] = this.geoIpRoutingType;
        data["geoIspSecondLevel"] = this.geoIspSecondLevel;
        data["geoIspTopLevel"] = this.geoIspTopLevel;
        data["shopperAge"] = this.shopperAge;
        data["shopperGender"] = this.shopperGender;
        data["language"] = this.language;
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
        data["shopperSearchedPhraseOnInternet"] = this.shopperSearchedPhraseOnInternet;
        data["currentUrl"] = this.currentUrl;
        data["referredUrl"] = this.referredUrl;
        return data; 
    }
}

export interface IPromotionEvaluationContext {
    refusedGiftIds?: string[] | undefined;
    storeId?: string | undefined;
    currency?: string | undefined;
    /** Customer id */
    customerId?: string | undefined;
    isRegisteredUser?: boolean;
    /** Has user made any orders */
    isFirstTimeBuyer?: boolean;
    isEveryone?: boolean;
    cartTotal?: number;
    /** Current shipment method */
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    shipmentMethodPrice?: number;
    availableShipmentMethodCodes?: string[] | undefined;
    /** Current payment method */
    paymentMethodCode?: string | undefined;
    paymentMethodPrice?: number;
    availablePaymentMethodCodes?: string[] | undefined;
    /** Entered coupon */
    coupon?: string | undefined;
    coupons?: string[] | undefined;
    /** List of product promo in cart */
    cartPromoEntries?: ProductPromoEntry[] | undefined;
    /** List of products for promo evaluation */
    promoEntries?: ProductPromoEntry[] | undefined;
    promoEntry?: ProductPromoEntry;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;
}

export enum RewardAmountType {
    Absolute = "Absolute",
    Relative = "Relative",
}

/** need to backward compatibility with v.2 */
export class PromotionReward implements IPromotionReward {
    /** Gets or sets the flag of promotion reward is valid. Also used as a flag for applicability (applied or potential) */
    isValid?: boolean;
    /** Gets or sets the value of promotion reward description */
    description?: string | undefined;
    /** Gets or sets the value of coupon amount */
    couponAmount?: number;
    /** Gets or sets the value of coupon code */
    coupon?: string | undefined;
    /** Gets or sets the value of minimum order total cost for applying coupon */
    couponMinOrderAmount?: number | undefined;
    /** Gets or sets the value of promotion id */
    promotionId?: string | undefined;
    promotion?: Promotion;
    /** Gets or sets the value of promotion reward type */
    rewardType?: string | undefined;
    amountType?: RewardAmountType;
    /** Gets or sets the value of promotion reward amount */
    amount?: number;
    /** Gets or sets the value of line item quantity for applying promotion reward */
    quantity?: number;
    /** Gets or sets the value of line item id */
    lineItemId?: string | undefined;
    /** Gets or sets the value of product id */
    productId?: string | undefined;
    /** Conditional product
For N items of entry ProductId  in every Y items of entry ConditionalProductId get %X off */
    conditionalProductId?: string | undefined;
    /** Gets or sets the value of category id */
    categoryId?: string | undefined;
    /** Gets or sets the value of measurement unit */
    measureUnit?: string | undefined;
    /** Gets or sets the value of promotion reward logo absolute URL */
    imageUrl?: string | undefined;
    /** Gets or sets the value of reward shipping method code */
    shippingMethod?: string | undefined;
    /** Gets or sets the value of reward payment method code */
    paymentMethod?: string | undefined;
    /** Gets or sets the max limit for relative rewards */
    maxLimit?: number;
    forNthQuantity?: number;
    inEveryNthQuantity?: number;

    constructor(data?: IPromotionReward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            this.description = _data["description"];
            this.couponAmount = _data["couponAmount"];
            this.coupon = _data["coupon"];
            this.couponMinOrderAmount = _data["couponMinOrderAmount"];
            this.promotionId = _data["promotionId"];
            this.promotion = _data["promotion"] ? Promotion.fromJS(_data["promotion"]) : <any>undefined;
            this.rewardType = _data["rewardType"];
            this.amountType = _data["amountType"];
            this.amount = _data["amount"];
            this.quantity = _data["quantity"];
            this.lineItemId = _data["lineItemId"];
            this.productId = _data["productId"];
            this.conditionalProductId = _data["conditionalProductId"];
            this.categoryId = _data["categoryId"];
            this.measureUnit = _data["measureUnit"];
            this.imageUrl = _data["imageUrl"];
            this.shippingMethod = _data["shippingMethod"];
            this.paymentMethod = _data["paymentMethod"];
            this.maxLimit = _data["maxLimit"];
            this.forNthQuantity = _data["forNthQuantity"];
            this.inEveryNthQuantity = _data["inEveryNthQuantity"];
        }
    }

    static fromJS(data: any): PromotionReward {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionReward();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        data["description"] = this.description;
        data["couponAmount"] = this.couponAmount;
        data["coupon"] = this.coupon;
        data["couponMinOrderAmount"] = this.couponMinOrderAmount;
        data["promotionId"] = this.promotionId;
        data["promotion"] = this.promotion ? this.promotion.toJSON() : <any>undefined;
        data["rewardType"] = this.rewardType;
        data["amountType"] = this.amountType;
        data["amount"] = this.amount;
        data["quantity"] = this.quantity;
        data["lineItemId"] = this.lineItemId;
        data["productId"] = this.productId;
        data["conditionalProductId"] = this.conditionalProductId;
        data["categoryId"] = this.categoryId;
        data["measureUnit"] = this.measureUnit;
        data["imageUrl"] = this.imageUrl;
        data["shippingMethod"] = this.shippingMethod;
        data["paymentMethod"] = this.paymentMethod;
        data["maxLimit"] = this.maxLimit;
        data["forNthQuantity"] = this.forNthQuantity;
        data["inEveryNthQuantity"] = this.inEveryNthQuantity;
        return data; 
    }
}

/** need to backward compatibility with v.2 */
export interface IPromotionReward {
    /** Gets or sets the flag of promotion reward is valid. Also used as a flag for applicability (applied or potential) */
    isValid?: boolean;
    /** Gets or sets the value of promotion reward description */
    description?: string | undefined;
    /** Gets or sets the value of coupon amount */
    couponAmount?: number;
    /** Gets or sets the value of coupon code */
    coupon?: string | undefined;
    /** Gets or sets the value of minimum order total cost for applying coupon */
    couponMinOrderAmount?: number | undefined;
    /** Gets or sets the value of promotion id */
    promotionId?: string | undefined;
    promotion?: Promotion;
    /** Gets or sets the value of promotion reward type */
    rewardType?: string | undefined;
    amountType?: RewardAmountType;
    /** Gets or sets the value of promotion reward amount */
    amount?: number;
    /** Gets or sets the value of line item quantity for applying promotion reward */
    quantity?: number;
    /** Gets or sets the value of line item id */
    lineItemId?: string | undefined;
    /** Gets or sets the value of product id */
    productId?: string | undefined;
    /** Conditional product
For N items of entry ProductId  in every Y items of entry ConditionalProductId get %X off */
    conditionalProductId?: string | undefined;
    /** Gets or sets the value of category id */
    categoryId?: string | undefined;
    /** Gets or sets the value of measurement unit */
    measureUnit?: string | undefined;
    /** Gets or sets the value of promotion reward logo absolute URL */
    imageUrl?: string | undefined;
    /** Gets or sets the value of reward shipping method code */
    shippingMethod?: string | undefined;
    /** Gets or sets the value of reward payment method code */
    paymentMethod?: string | undefined;
    /** Gets or sets the max limit for relative rewards */
    maxLimit?: number;
    forNthQuantity?: number;
    inEveryNthQuantity?: number;
}

export class CouponSearchCriteria implements ICouponSearchCriteria {
    code?: string | undefined;
    codes?: string[] | undefined;
    promotionId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICouponSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            if (Array.isArray(_data["codes"])) {
                this.codes = [] as any;
                for (let item of _data["codes"])
                    this.codes!.push(item);
            }
            this.promotionId = _data["promotionId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CouponSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CouponSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        if (Array.isArray(this.codes)) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        data["promotionId"] = this.promotionId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ICouponSearchCriteria {
    code?: string | undefined;
    codes?: string[] | undefined;
    promotionId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class Coupon implements ICoupon {
    /** Restriction of total coupon usages
0 infinitive */
    maxUsesNumber?: number;
    /** Maximum number of uses per registered user
0 infinitive */
    maxUsesPerUser?: number;
    expirationDate?: Date | undefined;
    /** coupon code */
    code?: string | undefined;
    promotionId?: string | undefined;
    /** Total number of uses */
    totalUsesCount?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxUsesNumber = _data["maxUsesNumber"];
            this.maxUsesPerUser = _data["maxUsesPerUser"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.promotionId = _data["promotionId"];
            this.totalUsesCount = _data["totalUsesCount"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxUsesNumber"] = this.maxUsesNumber;
        data["maxUsesPerUser"] = this.maxUsesPerUser;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["promotionId"] = this.promotionId;
        data["totalUsesCount"] = this.totalUsesCount;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICoupon {
    /** Restriction of total coupon usages
0 infinitive */
    maxUsesNumber?: number;
    /** Maximum number of uses per registered user
0 infinitive */
    maxUsesPerUser?: number;
    expirationDate?: Date | undefined;
    /** coupon code */
    code?: string | undefined;
    promotionId?: string | undefined;
    /** Total number of uses */
    totalUsesCount?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CouponSearchResult implements ICouponSearchResult {
    totalCount?: number;
    results?: Coupon[] | undefined;

    constructor(data?: ICouponSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Coupon.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CouponSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CouponSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICouponSearchResult {
    totalCount?: number;
    results?: Coupon[] | undefined;
}

export class ImportRequest implements IImportRequest {
    fileUrl?: string | undefined;
    delimiter?: string | undefined;
    promotionId?: string | undefined;
    expirationDate?: Date | undefined;

    constructor(data?: IImportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUrl = _data["fileUrl"];
            this.delimiter = _data["delimiter"];
            this.promotionId = _data["promotionId"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl;
        data["delimiter"] = this.delimiter;
        data["promotionId"] = this.promotionId;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IImportRequest {
    fileUrl?: string | undefined;
    delimiter?: string | undefined;
    promotionId?: string | undefined;
    expirationDate?: Date | undefined;
}

export class ImportNotification implements IImportNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IImportNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            this.errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImportNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ImportNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IImportNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

/** Criteria for searching */
export class NotificationSearchCriteria implements INotificationSearchCriteria {
    notificationType?: string | undefined;
    /** Owner Id of Notification */
    tenantId?: string | undefined;
    /** Owner Type of Notification */
    tenantType?: string | undefined;
    /** only active notification */
    isActive?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: INotificationSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationType = _data["notificationType"];
            this.tenantId = _data["tenantId"];
            this.tenantType = _data["tenantType"];
            this.isActive = _data["isActive"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): NotificationSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationType"] = this.notificationType;
        data["tenantId"] = this.tenantId;
        data["tenantType"] = this.tenantType;
        data["isActive"] = this.isActive;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

/** Criteria for searching */
export interface INotificationSearchCriteria {
    notificationType?: string | undefined;
    /** Owner Id of Notification */
    tenantId?: string | undefined;
    /** Owner Type of Notification */
    tenantType?: string | undefined;
    /** only active notification */
    isActive?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

/** Template of Notification with a different language */
export class NotificationTemplate implements INotificationTemplate {
    /** Code of Language */
    languageCode?: string | undefined;
    /** For detecting kind of notifications (email, sms and etc.) */
    readonly kind?: string | undefined;
    /** Discriminator of NotificationTemplate, name of real template descendant */
    readonly type?: string | undefined;
    isReadonly?: boolean;
    outerId?: string | undefined;
    isPredefined?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: INotificationTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageCode = _data["languageCode"];
            (<any>this).kind = _data["kind"];
            (<any>this).type = _data["type"];
            this.isReadonly = _data["isReadonly"];
            this.outerId = _data["outerId"];
            this.isPredefined = _data["isPredefined"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageCode"] = this.languageCode;
        data["kind"] = this.kind;
        data["type"] = this.type;
        data["isReadonly"] = this.isReadonly;
        data["outerId"] = this.outerId;
        data["isPredefined"] = this.isPredefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

/** Template of Notification with a different language */
export interface INotificationTemplate {
    /** Code of Language */
    languageCode?: string | undefined;
    /** For detecting kind of notifications (email, sms and etc.) */
    kind?: string | undefined;
    /** Discriminator of NotificationTemplate, name of real template descendant */
    type?: string | undefined;
    isReadonly?: boolean;
    outerId?: string | undefined;
    isPredefined?: boolean;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

/** Base class for Notification */
export class Notification implements INotification {
    tenantIdentity?: TenantIdentity;
    isActive?: boolean | undefined;
    languageCode?: string | undefined;
    /** This field represents an alias for the notification type
and is used only for backward compatibility with old notification names
that are stored and used by API clients. */
    alias?: string | undefined;
    /** Type of notifications, like Identifier */
    type?: string | undefined;
    /** For detecting kind of notifications (email, sms and etc.) */
    readonly kind?: string | undefined;
    outerId?: string | undefined;
    templates?: NotificationTemplate[] | undefined;
    /** need for saving validation errors
if the property is not empty then the notification is not sent
for seting use SetCustomValidationError */
    readonly customValidationError?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: INotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantIdentity = _data["tenantIdentity"] ? TenantIdentity.fromJS(_data["tenantIdentity"]) : <any>undefined;
            this.isActive = _data["isActive"];
            this.languageCode = _data["languageCode"];
            this.alias = _data["alias"];
            this.type = _data["type"];
            (<any>this).kind = _data["kind"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["templates"])) {
                this.templates = [] as any;
                for (let item of _data["templates"])
                    this.templates!.push(NotificationTemplate.fromJS(item));
            }
            (<any>this).customValidationError = _data["customValidationError"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantIdentity"] = this.tenantIdentity ? this.tenantIdentity.toJSON() : <any>undefined;
        data["isActive"] = this.isActive;
        data["languageCode"] = this.languageCode;
        data["alias"] = this.alias;
        data["type"] = this.type;
        data["kind"] = this.kind;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.templates)) {
            data["templates"] = [];
            for (let item of this.templates)
                data["templates"].push(item.toJSON());
        }
        data["customValidationError"] = this.customValidationError;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

/** Base class for Notification */
export interface INotification {
    tenantIdentity?: TenantIdentity;
    isActive?: boolean | undefined;
    languageCode?: string | undefined;
    /** This field represents an alias for the notification type
and is used only for backward compatibility with old notification names
that are stored and used by API clients. */
    alias?: string | undefined;
    /** Type of notifications, like Identifier */
    type?: string | undefined;
    /** For detecting kind of notifications (email, sms and etc.) */
    kind?: string | undefined;
    outerId?: string | undefined;
    templates?: NotificationTemplate[] | undefined;
    /** need for saving validation errors
if the property is not empty then the notification is not sent
for seting use SetCustomValidationError */
    customValidationError?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class NotificationSearchResult implements INotificationSearchResult {
    totalCount?: number;
    results?: Notification[] | undefined;

    constructor(data?: INotificationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Notification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INotificationSearchResult {
    totalCount?: number;
    results?: Notification[] | undefined;
}

export class NotificationTemplateRequest implements INotificationTemplateRequest {
    text?: string | undefined;
    data?: Notification;

    constructor(data?: INotificationTemplateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.data = _data["data"] ? Notification.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NotificationTemplateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationTemplateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }
}

export interface INotificationTemplateRequest {
    text?: string | undefined;
    data?: Notification;
}

/** Result of notification sending */
export class NotificationSendResult implements INotificationSendResult {
    errorMessage?: string | undefined;
    isSuccess?: boolean;

    constructor(data?: INotificationSendResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorMessage = _data["errorMessage"];
            this.isSuccess = _data["isSuccess"];
        }
    }

    static fromJS(data: any): NotificationSendResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSendResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorMessage"] = this.errorMessage;
        data["isSuccess"] = this.isSuccess;
        return data; 
    }
}

/** Result of notification sending */
export interface INotificationSendResult {
    errorMessage?: string | undefined;
    isSuccess?: boolean;
}

export enum NotificationParameterValueType {
    String = "String",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
}

export class NotificationParameter implements INotificationParameter {
    parameterName?: string | undefined;
    parameterDescription?: string | undefined;
    parameterCodeInView?: string | undefined;
    isDictionary?: boolean;
    isArray?: boolean;
    type?: NotificationParameterValueType;
    value?: any | undefined;

    constructor(data?: INotificationParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parameterName = _data["parameterName"];
            this.parameterDescription = _data["parameterDescription"];
            this.parameterCodeInView = _data["parameterCodeInView"];
            this.isDictionary = _data["isDictionary"];
            this.isArray = _data["isArray"];
            this.type = _data["type"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NotificationParameter {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parameterName"] = this.parameterName;
        data["parameterDescription"] = this.parameterDescription;
        data["parameterCodeInView"] = this.parameterCodeInView;
        data["isDictionary"] = this.isDictionary;
        data["isArray"] = this.isArray;
        data["type"] = this.type;
        data["value"] = this.value;
        return data; 
    }
}

export interface INotificationParameter {
    parameterName?: string | undefined;
    parameterDescription?: string | undefined;
    parameterCodeInView?: string | undefined;
    isDictionary?: boolean;
    isArray?: boolean;
    type?: NotificationParameterValueType;
    value?: any | undefined;
}

export class NotificationRequest implements INotificationRequest {
    type?: string | undefined;
    objectId?: string | undefined;
    objectTypeId?: string | undefined;
    language?: string | undefined;
    notificationParameters?: NotificationParameter[] | undefined;

    constructor(data?: INotificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.objectId = _data["objectId"];
            this.objectTypeId = _data["objectTypeId"];
            this.language = _data["language"];
            if (Array.isArray(_data["notificationParameters"])) {
                this.notificationParameters = [] as any;
                for (let item of _data["notificationParameters"])
                    this.notificationParameters!.push(NotificationParameter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["objectId"] = this.objectId;
        data["objectTypeId"] = this.objectTypeId;
        data["language"] = this.language;
        if (Array.isArray(this.notificationParameters)) {
            data["notificationParameters"] = [];
            for (let item of this.notificationParameters)
                data["notificationParameters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INotificationRequest {
    type?: string | undefined;
    objectId?: string | undefined;
    objectTypeId?: string | undefined;
    language?: string | undefined;
    notificationParameters?: NotificationParameter[] | undefined;
}

export class NotificationMessageSearchCriteria implements INotificationMessageSearchCriteria {
    notificationType?: string | undefined;
    status?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: INotificationMessageSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationType = _data["notificationType"];
            this.status = _data["status"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): NotificationMessageSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationMessageSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationType"] = this.notificationType;
        data["status"] = this.status;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface INotificationMessageSearchCriteria {
    notificationType?: string | undefined;
    status?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export enum NotificationMessageStatus {
    Pending = "Pending",
    Sent = "Sent",
    Error = "Error",
}

/** Base class for message of a notification with information about sending */
export class NotificationMessage implements INotificationMessage {
    readonly kind?: string | undefined;
    /** Discriminator of NotificationMessage, name of real message descendant */
    readonly type?: string | undefined;
    tenantIdentity?: TenantIdentity;
    /** Id of Notification */
    notificationId?: string | undefined;
    /** Type of Notification */
    notificationType?: string | undefined;
    /** Count of sending attempt */
    sendAttemptCount?: number;
    /** Max count of sending attempt */
    maxSendAttemptCount?: number;
    /** The last error of sending */
    lastSendError?: string | undefined;
    /** The last date of sending attempt */
    lastSendAttemptDate?: Date | undefined;
    /** Date of sending */
    sendDate?: Date | undefined;
    /** Code of language */
    languageCode?: string | undefined;
    status?: NotificationMessageStatus;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: INotificationMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).kind = _data["kind"];
            (<any>this).type = _data["type"];
            this.tenantIdentity = _data["tenantIdentity"] ? TenantIdentity.fromJS(_data["tenantIdentity"]) : <any>undefined;
            this.notificationId = _data["notificationId"];
            this.notificationType = _data["notificationType"];
            this.sendAttemptCount = _data["sendAttemptCount"];
            this.maxSendAttemptCount = _data["maxSendAttemptCount"];
            this.lastSendError = _data["lastSendError"];
            this.lastSendAttemptDate = _data["lastSendAttemptDate"] ? new Date(_data["lastSendAttemptDate"].toString()) : <any>undefined;
            this.sendDate = _data["sendDate"] ? new Date(_data["sendDate"].toString()) : <any>undefined;
            this.languageCode = _data["languageCode"];
            this.status = _data["status"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): NotificationMessage {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["kind"] = this.kind;
        data["type"] = this.type;
        data["tenantIdentity"] = this.tenantIdentity ? this.tenantIdentity.toJSON() : <any>undefined;
        data["notificationId"] = this.notificationId;
        data["notificationType"] = this.notificationType;
        data["sendAttemptCount"] = this.sendAttemptCount;
        data["maxSendAttemptCount"] = this.maxSendAttemptCount;
        data["lastSendError"] = this.lastSendError;
        data["lastSendAttemptDate"] = this.lastSendAttemptDate ? this.lastSendAttemptDate.toISOString() : <any>undefined;
        data["sendDate"] = this.sendDate ? this.sendDate.toISOString() : <any>undefined;
        data["languageCode"] = this.languageCode;
        data["status"] = this.status;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

/** Base class for message of a notification with information about sending */
export interface INotificationMessage {
    kind?: string | undefined;
    /** Discriminator of NotificationMessage, name of real message descendant */
    type?: string | undefined;
    tenantIdentity?: TenantIdentity;
    /** Id of Notification */
    notificationId?: string | undefined;
    /** Type of Notification */
    notificationType?: string | undefined;
    /** Count of sending attempt */
    sendAttemptCount?: number;
    /** Max count of sending attempt */
    maxSendAttemptCount?: number;
    /** The last error of sending */
    lastSendError?: string | undefined;
    /** The last date of sending attempt */
    lastSendAttemptDate?: Date | undefined;
    /** Date of sending */
    sendDate?: Date | undefined;
    /** Code of language */
    languageCode?: string | undefined;
    status?: NotificationMessageStatus;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class NotificationMessageSearchResult implements INotificationMessageSearchResult {
    totalCount?: number;
    results?: NotificationMessage[] | undefined;

    constructor(data?: INotificationMessageSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(NotificationMessage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NotificationMessageSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationMessageSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INotificationMessageSearchResult {
    totalCount?: number;
    results?: NotificationMessage[] | undefined;
}

export class CustomerOrderSearchCriteria implements ICustomerOrderSearchCriteria {
    /** Search orders with flag IsPrototype */
    withPrototypes?: boolean;
    /** Search only recurring orders created by subscription */
    onlyRecurring?: boolean;
    /** Search orders with given subscription */
    subscriptionId?: string | undefined;
    subscriptionIds?: string[] | undefined;
    /** It used to limit search within an operation (customer order for example) */
    operationId?: string | undefined;
    customerId?: string | undefined;
    customerIds?: string[] | undefined;
    ids?: string[] | undefined;
    employeeId?: string | undefined;
    storeIds?: string[] | undefined;
    /** Search by status */
    status?: string | undefined;
    statuses?: string[] | undefined;
    /** Search by numbers */
    number?: string | undefined;
    numbers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICustomerOrderSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.withPrototypes = _data["withPrototypes"];
            this.onlyRecurring = _data["onlyRecurring"];
            this.subscriptionId = _data["subscriptionId"];
            if (Array.isArray(_data["subscriptionIds"])) {
                this.subscriptionIds = [] as any;
                for (let item of _data["subscriptionIds"])
                    this.subscriptionIds!.push(item);
            }
            this.operationId = _data["operationId"];
            this.customerId = _data["customerId"];
            if (Array.isArray(_data["customerIds"])) {
                this.customerIds = [] as any;
                for (let item of _data["customerIds"])
                    this.customerIds!.push(item);
            }
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.status = _data["status"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.number = _data["number"];
            if (Array.isArray(_data["numbers"])) {
                this.numbers = [] as any;
                for (let item of _data["numbers"])
                    this.numbers!.push(item);
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CustomerOrderSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrderSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["withPrototypes"] = this.withPrototypes;
        data["onlyRecurring"] = this.onlyRecurring;
        data["subscriptionId"] = this.subscriptionId;
        if (Array.isArray(this.subscriptionIds)) {
            data["subscriptionIds"] = [];
            for (let item of this.subscriptionIds)
                data["subscriptionIds"].push(item);
        }
        data["operationId"] = this.operationId;
        data["customerId"] = this.customerId;
        if (Array.isArray(this.customerIds)) {
            data["customerIds"] = [];
            for (let item of this.customerIds)
                data["customerIds"].push(item);
        }
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["status"] = this.status;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["number"] = this.number;
        if (Array.isArray(this.numbers)) {
            data["numbers"] = [];
            for (let item of this.numbers)
                data["numbers"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ICustomerOrderSearchCriteria {
    /** Search orders with flag IsPrototype */
    withPrototypes?: boolean;
    /** Search only recurring orders created by subscription */
    onlyRecurring?: boolean;
    /** Search orders with given subscription */
    subscriptionId?: string | undefined;
    subscriptionIds?: string[] | undefined;
    /** It used to limit search within an operation (customer order for example) */
    operationId?: string | undefined;
    customerId?: string | undefined;
    customerIds?: string[] | undefined;
    ids?: string[] | undefined;
    employeeId?: string | undefined;
    storeIds?: string[] | undefined;
    /** Search by status */
    status?: string | undefined;
    statuses?: string[] | undefined;
    /** Search by numbers */
    number?: string | undefined;
    numbers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class OrderAddress implements IOrderAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: IOrderAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): OrderAddress {
        data = typeof data === 'object' ? data : {};
        let result = new OrderAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data; 
    }
}

export interface IOrderAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export enum PaymentStatus {
    New = "New",
    Pending = "Pending",
    Authorized = "Authorized",
    Paid = "Paid",
    PartiallyRefunded = "PartiallyRefunded",
    Refunded = "Refunded",
    Voided = "Voided",
    Custom = "Custom",
    Cancelled = "Cancelled",
    Declined = "Declined",
    Error = "Error",
}

export class ProcessPaymentRequestResult implements IProcessPaymentRequestResult {
    redirectUrl?: string | undefined;
    htmlForm?: string | undefined;
    outerId?: string | undefined;
    paymentMethod?: PaymentMethod;
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    newPaymentStatus?: PaymentStatus;

    constructor(data?: IProcessPaymentRequestResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.redirectUrl = _data["redirectUrl"];
            this.htmlForm = _data["htmlForm"];
            this.outerId = _data["outerId"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.newPaymentStatus = _data["newPaymentStatus"];
        }
    }

    static fromJS(data: any): ProcessPaymentRequestResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessPaymentRequestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["redirectUrl"] = this.redirectUrl;
        data["htmlForm"] = this.htmlForm;
        data["outerId"] = this.outerId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["newPaymentStatus"] = this.newPaymentStatus;
        return data; 
    }
}

export interface IProcessPaymentRequestResult {
    redirectUrl?: string | undefined;
    htmlForm?: string | undefined;
    outerId?: string | undefined;
    paymentMethod?: PaymentMethod;
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    newPaymentStatus?: PaymentStatus;
}

export class PaymentGatewayTransaction implements IPaymentGatewayTransaction {
    amount?: number;
    currencyCode?: string | undefined;
    /** Flag represent that current transaction is processed */
    isProcessed?: boolean;
    /** Date when this transaction was handled */
    processedDate?: Date | undefined;
    processError?: string | undefined;
    processAttemptCount?: number;
    /** Raw request data */
    requestData?: string | undefined;
    /** Raw response data */
    responseData?: string | undefined;
    /** Gateway or VC response status code */
    responseCode?: string | undefined;
    /** Gateway IP address */
    gatewayIpAddress?: string | undefined;
    /** The type of payment interaction.The payment can be Capture or CheckReceived. 
The value also includes customer payment interactions such as Website, Call, Store, or Unknown. */
    type?: string | undefined;
    /** "Active", "Expired", and "Inactive" or other */
    status?: string | undefined;
    note?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPaymentGatewayTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.currencyCode = _data["currencyCode"];
            this.isProcessed = _data["isProcessed"];
            this.processedDate = _data["processedDate"] ? new Date(_data["processedDate"].toString()) : <any>undefined;
            this.processError = _data["processError"];
            this.processAttemptCount = _data["processAttemptCount"];
            this.requestData = _data["requestData"];
            this.responseData = _data["responseData"];
            this.responseCode = _data["responseCode"];
            this.gatewayIpAddress = _data["gatewayIpAddress"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.note = _data["note"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentGatewayTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currencyCode"] = this.currencyCode;
        data["isProcessed"] = this.isProcessed;
        data["processedDate"] = this.processedDate ? this.processedDate.toISOString() : <any>undefined;
        data["processError"] = this.processError;
        data["processAttemptCount"] = this.processAttemptCount;
        data["requestData"] = this.requestData;
        data["responseData"] = this.responseData;
        data["responseCode"] = this.responseCode;
        data["gatewayIpAddress"] = this.gatewayIpAddress;
        data["type"] = this.type;
        data["status"] = this.status;
        data["note"] = this.note;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaymentGatewayTransaction {
    amount?: number;
    currencyCode?: string | undefined;
    /** Flag represent that current transaction is processed */
    isProcessed?: boolean;
    /** Date when this transaction was handled */
    processedDate?: Date | undefined;
    processError?: string | undefined;
    processAttemptCount?: number;
    /** Raw request data */
    requestData?: string | undefined;
    /** Raw response data */
    responseData?: string | undefined;
    /** Gateway or VC response status code */
    responseCode?: string | undefined;
    /** Gateway IP address */
    gatewayIpAddress?: string | undefined;
    /** The type of payment interaction.The payment can be Capture or CheckReceived. 
The value also includes customer payment interactions such as Website, Call, Store, or Unknown. */
    type?: string | undefined;
    /** "Active", "Expired", and "Inactive" or other */
    status?: string | undefined;
    note?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class IOperation implements IIOperation {
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    childrenOperations?: IOperation[] | undefined;
    id?: string | undefined;

    constructor(data?: IIOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationType = _data["operationType"];
            this.parentOperationId = _data["parentOperationId"];
            this.number = _data["number"];
            this.isApproved = _data["isApproved"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.currency = _data["currency"];
            if (Array.isArray(_data["childrenOperations"])) {
                this.childrenOperations = [] as any;
                for (let item of _data["childrenOperations"])
                    this.childrenOperations!.push(IOperation.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IOperation {
        data = typeof data === 'object' ? data : {};
        let result = new IOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationType"] = this.operationType;
        data["parentOperationId"] = this.parentOperationId;
        data["number"] = this.number;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["currency"] = this.currency;
        if (Array.isArray(this.childrenOperations)) {
            data["childrenOperations"] = [];
            for (let item of this.childrenOperations)
                data["childrenOperations"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IIOperation {
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    childrenOperations?: IOperation[] | undefined;
    id?: string | undefined;
}

export class PaymentIn implements IPaymentIn {
    orderId?: string | undefined;
    purpose?: string | undefined;
    /** Payment method (gateway) code */
    gatewayCode?: string | undefined;
    paymentMethod?: PaymentMethod;
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    customerId?: string | undefined;
    customerName?: string | undefined;
    incomingDate?: Date | undefined;
    billingAddress?: OrderAddress;
    paymentStatus?: PaymentStatus;
    authorizedDate?: Date | undefined;
    capturedDate?: Date | undefined;
    voidedDate?: Date | undefined;
    processPaymentResult?: ProcessPaymentRequestResult;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    objectType?: string | undefined;
    /** Tax category or type */
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    discounts?: Discount[] | undefined;
    transactions?: PaymentGatewayTransaction[] | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPaymentIn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.purpose = _data["purpose"];
            this.gatewayCode = _data["gatewayCode"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.incomingDate = _data["incomingDate"] ? new Date(_data["incomingDate"].toString()) : <any>undefined;
            this.billingAddress = _data["billingAddress"] ? OrderAddress.fromJS(_data["billingAddress"]) : <any>undefined;
            this.paymentStatus = _data["paymentStatus"];
            this.authorizedDate = _data["authorizedDate"] ? new Date(_data["authorizedDate"].toString()) : <any>undefined;
            this.capturedDate = _data["capturedDate"] ? new Date(_data["capturedDate"].toString()) : <any>undefined;
            this.voidedDate = _data["voidedDate"] ? new Date(_data["voidedDate"].toString()) : <any>undefined;
            this.processPaymentResult = _data["processPaymentResult"] ? ProcessPaymentRequestResult.fromJS(_data["processPaymentResult"]) : <any>undefined;
            this.price = _data["price"];
            this.priceWithTax = _data["priceWithTax"];
            this.total = _data["total"];
            this.totalWithTax = _data["totalWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.objectType = _data["objectType"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["transactions"])
                    this.transactions!.push(PaymentGatewayTransaction.fromJS(item));
            }
            this.operationType = _data["operationType"];
            this.parentOperationId = _data["parentOperationId"];
            this.number = _data["number"];
            this.isApproved = _data["isApproved"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.currency = _data["currency"];
            this.sum = _data["sum"];
            this.outerId = _data["outerId"];
            this.isCancelled = _data["isCancelled"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelReason = _data["cancelReason"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            if (Array.isArray(_data["operationsLog"])) {
                this.operationsLog = [] as any;
                for (let item of _data["operationsLog"])
                    this.operationsLog!.push(OperationLog.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentIn {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentIn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["purpose"] = this.purpose;
        data["gatewayCode"] = this.gatewayCode;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["incomingDate"] = this.incomingDate ? this.incomingDate.toISOString() : <any>undefined;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : <any>undefined;
        data["paymentStatus"] = this.paymentStatus;
        data["authorizedDate"] = this.authorizedDate ? this.authorizedDate.toISOString() : <any>undefined;
        data["capturedDate"] = this.capturedDate ? this.capturedDate.toISOString() : <any>undefined;
        data["voidedDate"] = this.voidedDate ? this.voidedDate.toISOString() : <any>undefined;
        data["processPaymentResult"] = this.processPaymentResult ? this.processPaymentResult.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["total"] = this.total;
        data["totalWithTax"] = this.totalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["objectType"] = this.objectType;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.transactions)) {
            data["transactions"] = [];
            for (let item of this.transactions)
                data["transactions"].push(item.toJSON());
        }
        data["operationType"] = this.operationType;
        data["parentOperationId"] = this.parentOperationId;
        data["number"] = this.number;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["currency"] = this.currency;
        data["sum"] = this.sum;
        data["outerId"] = this.outerId;
        data["isCancelled"] = this.isCancelled;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelReason"] = this.cancelReason;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.operationsLog)) {
            data["operationsLog"] = [];
            for (let item of this.operationsLog)
                data["operationsLog"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaymentIn {
    orderId?: string | undefined;
    purpose?: string | undefined;
    /** Payment method (gateway) code */
    gatewayCode?: string | undefined;
    paymentMethod?: PaymentMethod;
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    customerId?: string | undefined;
    customerName?: string | undefined;
    incomingDate?: Date | undefined;
    billingAddress?: OrderAddress;
    paymentStatus?: PaymentStatus;
    authorizedDate?: Date | undefined;
    capturedDate?: Date | undefined;
    voidedDate?: Date | undefined;
    processPaymentResult?: ProcessPaymentRequestResult;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    objectType?: string | undefined;
    /** Tax category or type */
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    discounts?: Discount[] | undefined;
    transactions?: PaymentGatewayTransaction[] | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class OrderLineItem implements IOrderLineItem {
    /** Price id */
    priceId?: string | undefined;
    currency?: string | undefined;
    /** unit price without discount and tax */
    price?: number;
    priceWithTax?: number;
    /** Resulting price with discount for one unit */
    placedPrice?: number;
    placedPriceWithTax?: number;
    extendedPrice?: number;
    extendedPriceWithTax?: number;
    /** Gets the value of the single qty line item discount amount */
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    /** Tax category or type */
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    /** Reserve quantity */
    reserveQuantity?: number;
    quantity?: number;
    productId?: string | undefined;
    sku?: string | undefined;
    productType?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    name?: string | undefined;
    comment?: string | undefined;
    imageUrl?: string | undefined;
    isGift?: boolean | undefined;
    shippingMethodCode?: string | undefined;
    fulfillmentLocationCode?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    outerId?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOrderLineItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.priceId = _data["priceId"];
            this.currency = _data["currency"];
            this.price = _data["price"];
            this.priceWithTax = _data["priceWithTax"];
            this.placedPrice = _data["placedPrice"];
            this.placedPriceWithTax = _data["placedPriceWithTax"];
            this.extendedPrice = _data["extendedPrice"];
            this.extendedPriceWithTax = _data["extendedPriceWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.discountTotal = _data["discountTotal"];
            this.discountTotalWithTax = _data["discountTotalWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            this.reserveQuantity = _data["reserveQuantity"];
            this.quantity = _data["quantity"];
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.productType = _data["productType"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.comment = _data["comment"];
            this.imageUrl = _data["imageUrl"];
            this.isGift = _data["isGift"];
            this.shippingMethodCode = _data["shippingMethodCode"];
            this.fulfillmentLocationCode = _data["fulfillmentLocationCode"];
            this.fulfillmentCenterId = _data["fulfillmentCenterId"];
            this.fulfillmentCenterName = _data["fulfillmentCenterName"];
            this.outerId = _data["outerId"];
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.isCancelled = _data["isCancelled"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelReason = _data["cancelReason"];
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrderLineItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderLineItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceId"] = this.priceId;
        data["currency"] = this.currency;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["placedPrice"] = this.placedPrice;
        data["placedPriceWithTax"] = this.placedPriceWithTax;
        data["extendedPrice"] = this.extendedPrice;
        data["extendedPriceWithTax"] = this.extendedPriceWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["discountTotal"] = this.discountTotal;
        data["discountTotalWithTax"] = this.discountTotalWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        data["reserveQuantity"] = this.reserveQuantity;
        data["quantity"] = this.quantity;
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["productType"] = this.productType;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["comment"] = this.comment;
        data["imageUrl"] = this.imageUrl;
        data["isGift"] = this.isGift;
        data["shippingMethodCode"] = this.shippingMethodCode;
        data["fulfillmentLocationCode"] = this.fulfillmentLocationCode;
        data["fulfillmentCenterId"] = this.fulfillmentCenterId;
        data["fulfillmentCenterName"] = this.fulfillmentCenterName;
        data["outerId"] = this.outerId;
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["isCancelled"] = this.isCancelled;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelReason"] = this.cancelReason;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrderLineItem {
    /** Price id */
    priceId?: string | undefined;
    currency?: string | undefined;
    /** unit price without discount and tax */
    price?: number;
    priceWithTax?: number;
    /** Resulting price with discount for one unit */
    placedPrice?: number;
    placedPriceWithTax?: number;
    extendedPrice?: number;
    extendedPriceWithTax?: number;
    /** Gets the value of the single qty line item discount amount */
    discountAmount?: number;
    discountAmountWithTax?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    /** Tax category or type */
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    /** Reserve quantity */
    reserveQuantity?: number;
    quantity?: number;
    productId?: string | undefined;
    sku?: string | undefined;
    productType?: string | undefined;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    name?: string | undefined;
    comment?: string | undefined;
    imageUrl?: string | undefined;
    isGift?: boolean | undefined;
    shippingMethodCode?: string | undefined;
    fulfillmentLocationCode?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    outerId?: string | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    discounts?: Discount[] | undefined;
    taxDetails?: TaxDetail[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class OrderShipmentItem implements IOrderShipmentItem {
    lineItemId?: string | undefined;
    lineItem?: OrderLineItem;
    barCode?: string | undefined;
    quantity?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOrderShipmentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lineItemId = _data["lineItemId"];
            this.lineItem = _data["lineItem"] ? OrderLineItem.fromJS(_data["lineItem"]) : <any>undefined;
            this.barCode = _data["barCode"];
            this.quantity = _data["quantity"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrderShipmentItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderShipmentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lineItemId"] = this.lineItemId;
        data["lineItem"] = this.lineItem ? this.lineItem.toJSON() : <any>undefined;
        data["barCode"] = this.barCode;
        data["quantity"] = this.quantity;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrderShipmentItem {
    lineItemId?: string | undefined;
    lineItem?: OrderLineItem;
    barCode?: string | undefined;
    quantity?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ShipmentPackage implements IShipmentPackage {
    barCode?: string | undefined;
    packageType?: string | undefined;
    items?: OrderShipmentItem[] | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IShipmentPackage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.barCode = _data["barCode"];
            this.packageType = _data["packageType"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderShipmentItem.fromJS(item));
            }
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ShipmentPackage {
        data = typeof data === 'object' ? data : {};
        let result = new ShipmentPackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["barCode"] = this.barCode;
        data["packageType"] = this.packageType;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IShipmentPackage {
    barCode?: string | undefined;
    packageType?: string | undefined;
    items?: OrderShipmentItem[] | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class OrderShipment implements IOrderShipment {
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    /** Current shipment method code */
    shipmentMethodCode?: string | undefined;
    /** Current shipment option code */
    shipmentMethodOption?: string | undefined;
    shippingMethod?: ShippingMethod;
    customerOrderId?: string | undefined;
    customerOrder?: CustomerOrder;
    items?: OrderShipmentItem[] | undefined;
    packages?: ShipmentPackage[] | undefined;
    inPayments?: PaymentIn[] | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    discounts?: Discount[] | undefined;
    deliveryAddress?: OrderAddress;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    objectType?: string | undefined;
    /** Tax category or type */
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IOrderShipment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.fulfillmentCenterId = _data["fulfillmentCenterId"];
            this.fulfillmentCenterName = _data["fulfillmentCenterName"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.shipmentMethodCode = _data["shipmentMethodCode"];
            this.shipmentMethodOption = _data["shipmentMethodOption"];
            this.shippingMethod = _data["shippingMethod"] ? ShippingMethod.fromJS(_data["shippingMethod"]) : <any>undefined;
            this.customerOrderId = _data["customerOrderId"];
            this.customerOrder = _data["customerOrder"] ? CustomerOrder.fromJS(_data["customerOrder"]) : <any>undefined;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderShipmentItem.fromJS(item));
            }
            if (Array.isArray(_data["packages"])) {
                this.packages = [] as any;
                for (let item of _data["packages"])
                    this.packages!.push(ShipmentPackage.fromJS(item));
            }
            if (Array.isArray(_data["inPayments"])) {
                this.inPayments = [] as any;
                for (let item of _data["inPayments"])
                    this.inPayments!.push(PaymentIn.fromJS(item));
            }
            this.weightUnit = _data["weightUnit"];
            this.weight = _data["weight"];
            this.measureUnit = _data["measureUnit"];
            this.height = _data["height"];
            this.length = _data["length"];
            this.width = _data["width"];
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            this.deliveryAddress = _data["deliveryAddress"] ? OrderAddress.fromJS(_data["deliveryAddress"]) : <any>undefined;
            this.price = _data["price"];
            this.priceWithTax = _data["priceWithTax"];
            this.total = _data["total"];
            this.totalWithTax = _data["totalWithTax"];
            this.discountAmount = _data["discountAmount"];
            this.discountAmountWithTax = _data["discountAmountWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            this.objectType = _data["objectType"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            this.operationType = _data["operationType"];
            this.parentOperationId = _data["parentOperationId"];
            this.number = _data["number"];
            this.isApproved = _data["isApproved"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.currency = _data["currency"];
            this.sum = _data["sum"];
            this.outerId = _data["outerId"];
            this.isCancelled = _data["isCancelled"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelReason = _data["cancelReason"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            if (Array.isArray(_data["operationsLog"])) {
                this.operationsLog = [] as any;
                for (let item of _data["operationsLog"])
                    this.operationsLog!.push(OperationLog.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrderShipment {
        data = typeof data === 'object' ? data : {};
        let result = new OrderShipment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["fulfillmentCenterId"] = this.fulfillmentCenterId;
        data["fulfillmentCenterName"] = this.fulfillmentCenterName;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["shipmentMethodCode"] = this.shipmentMethodCode;
        data["shipmentMethodOption"] = this.shipmentMethodOption;
        data["shippingMethod"] = this.shippingMethod ? this.shippingMethod.toJSON() : <any>undefined;
        data["customerOrderId"] = this.customerOrderId;
        data["customerOrder"] = this.customerOrder ? this.customerOrder.toJSON() : <any>undefined;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.packages)) {
            data["packages"] = [];
            for (let item of this.packages)
                data["packages"].push(item.toJSON());
        }
        if (Array.isArray(this.inPayments)) {
            data["inPayments"] = [];
            for (let item of this.inPayments)
                data["inPayments"].push(item.toJSON());
        }
        data["weightUnit"] = this.weightUnit;
        data["weight"] = this.weight;
        data["measureUnit"] = this.measureUnit;
        data["height"] = this.height;
        data["length"] = this.length;
        data["width"] = this.width;
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        data["deliveryAddress"] = this.deliveryAddress ? this.deliveryAddress.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["priceWithTax"] = this.priceWithTax;
        data["total"] = this.total;
        data["totalWithTax"] = this.totalWithTax;
        data["discountAmount"] = this.discountAmount;
        data["discountAmountWithTax"] = this.discountAmountWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        data["objectType"] = this.objectType;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        data["operationType"] = this.operationType;
        data["parentOperationId"] = this.parentOperationId;
        data["number"] = this.number;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["currency"] = this.currency;
        data["sum"] = this.sum;
        data["outerId"] = this.outerId;
        data["isCancelled"] = this.isCancelled;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelReason"] = this.cancelReason;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.operationsLog)) {
            data["operationsLog"] = [];
            for (let item of this.operationsLog)
                data["operationsLog"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrderShipment {
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    fulfillmentCenterId?: string | undefined;
    fulfillmentCenterName?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    /** Current shipment method code */
    shipmentMethodCode?: string | undefined;
    /** Current shipment option code */
    shipmentMethodOption?: string | undefined;
    shippingMethod?: ShippingMethod;
    customerOrderId?: string | undefined;
    customerOrder?: CustomerOrder;
    items?: OrderShipmentItem[] | undefined;
    packages?: ShipmentPackage[] | undefined;
    inPayments?: PaymentIn[] | undefined;
    weightUnit?: string | undefined;
    weight?: number | undefined;
    measureUnit?: string | undefined;
    height?: number | undefined;
    length?: number | undefined;
    width?: number | undefined;
    discounts?: Discount[] | undefined;
    deliveryAddress?: OrderAddress;
    price?: number;
    priceWithTax?: number;
    total?: number;
    totalWithTax?: number;
    discountAmount?: number;
    discountAmountWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    objectType?: string | undefined;
    /** Tax category or type */
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    taxDetails?: TaxDetail[] | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CustomerOrder implements ICustomerOrder {
    customerId?: string | undefined;
    customerName?: string | undefined;
    channelId?: string | undefined;
    storeId?: string | undefined;
    storeName?: string | undefined;
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    /** The basis shopping cart id of which the order was created */
    shoppingCartId?: string | undefined;
    /** Flag determines that the order is the prototype */
    isPrototype?: boolean;
    /** Internal number of order provided by customer */
    purchaseOrderNumber?: string | undefined;
    /** Number for subscription  associated with this order */
    subscriptionNumber?: string | undefined;
    /** Identifier for subscription  associated with this order */
    subscriptionId?: string | undefined;
    objectType?: string | undefined;
    addresses?: OrderAddress[] | undefined;
    inPayments?: PaymentIn[] | undefined;
    items?: OrderLineItem[] | undefined;
    shipments?: OrderShipment[] | undefined;
    discounts?: Discount[] | undefined;
    /** When a discount is applied to the order, the tax calculation has already been applied, and is reflected in the tax.
Therefore, a discount applying to the order  will occur after tax. 
For instance, if the cart subtotal is $100, and $15 is the tax subtotal, a cart-wide discount of 10% will yield a total of $105 ($100 subtotal  $10 discount + $15 tax on the original $100). */
    discountAmount?: number;
    taxDetails?: TaxDetail[] | undefined;
    scopes?: string[] | undefined;
    /** Grand order total */
    total?: number;
    subTotal?: number;
    subTotalWithTax?: number;
    subTotalDiscount?: number;
    subTotalDiscountWithTax?: number;
    subTotalTaxTotal?: number;
    shippingTotal?: number;
    shippingTotalWithTax?: number;
    shippingSubTotal?: number;
    shippingSubTotalWithTax?: number;
    shippingDiscountTotal?: number;
    shippingDiscountTotalWithTax?: number;
    shippingTaxTotal?: number;
    paymentTotal?: number;
    paymentTotalWithTax?: number;
    paymentSubTotal?: number;
    paymentSubTotalWithTax?: number;
    paymentDiscountTotal?: number;
    paymentDiscountTotalWithTax?: number;
    paymentTaxTotal?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    feeTotal?: number;
    feeTotalWithTax?: number;
    /** Tax category or type */
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    languageCode?: string | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICustomerOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.channelId = _data["channelId"];
            this.storeId = _data["storeId"];
            this.storeName = _data["storeName"];
            this.organizationId = _data["organizationId"];
            this.organizationName = _data["organizationName"];
            this.employeeId = _data["employeeId"];
            this.employeeName = _data["employeeName"];
            this.shoppingCartId = _data["shoppingCartId"];
            this.isPrototype = _data["isPrototype"];
            this.purchaseOrderNumber = _data["purchaseOrderNumber"];
            this.subscriptionNumber = _data["subscriptionNumber"];
            this.subscriptionId = _data["subscriptionId"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(OrderAddress.fromJS(item));
            }
            if (Array.isArray(_data["inPayments"])) {
                this.inPayments = [] as any;
                for (let item of _data["inPayments"])
                    this.inPayments!.push(PaymentIn.fromJS(item));
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderLineItem.fromJS(item));
            }
            if (Array.isArray(_data["shipments"])) {
                this.shipments = [] as any;
                for (let item of _data["shipments"])
                    this.shipments!.push(OrderShipment.fromJS(item));
            }
            if (Array.isArray(_data["discounts"])) {
                this.discounts = [] as any;
                for (let item of _data["discounts"])
                    this.discounts!.push(Discount.fromJS(item));
            }
            this.discountAmount = _data["discountAmount"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.total = _data["total"];
            this.subTotal = _data["subTotal"];
            this.subTotalWithTax = _data["subTotalWithTax"];
            this.subTotalDiscount = _data["subTotalDiscount"];
            this.subTotalDiscountWithTax = _data["subTotalDiscountWithTax"];
            this.subTotalTaxTotal = _data["subTotalTaxTotal"];
            this.shippingTotal = _data["shippingTotal"];
            this.shippingTotalWithTax = _data["shippingTotalWithTax"];
            this.shippingSubTotal = _data["shippingSubTotal"];
            this.shippingSubTotalWithTax = _data["shippingSubTotalWithTax"];
            this.shippingDiscountTotal = _data["shippingDiscountTotal"];
            this.shippingDiscountTotalWithTax = _data["shippingDiscountTotalWithTax"];
            this.shippingTaxTotal = _data["shippingTaxTotal"];
            this.paymentTotal = _data["paymentTotal"];
            this.paymentTotalWithTax = _data["paymentTotalWithTax"];
            this.paymentSubTotal = _data["paymentSubTotal"];
            this.paymentSubTotalWithTax = _data["paymentSubTotalWithTax"];
            this.paymentDiscountTotal = _data["paymentDiscountTotal"];
            this.paymentDiscountTotalWithTax = _data["paymentDiscountTotalWithTax"];
            this.paymentTaxTotal = _data["paymentTaxTotal"];
            this.discountTotal = _data["discountTotal"];
            this.discountTotalWithTax = _data["discountTotalWithTax"];
            this.fee = _data["fee"];
            this.feeWithTax = _data["feeWithTax"];
            this.feeTotal = _data["feeTotal"];
            this.feeTotalWithTax = _data["feeTotalWithTax"];
            this.taxType = _data["taxType"];
            this.taxTotal = _data["taxTotal"];
            this.taxPercentRate = _data["taxPercentRate"];
            this.languageCode = _data["languageCode"];
            this.operationType = _data["operationType"];
            this.parentOperationId = _data["parentOperationId"];
            this.number = _data["number"];
            this.isApproved = _data["isApproved"];
            this.status = _data["status"];
            this.comment = _data["comment"];
            this.currency = _data["currency"];
            this.sum = _data["sum"];
            this.outerId = _data["outerId"];
            this.isCancelled = _data["isCancelled"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelReason = _data["cancelReason"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            if (Array.isArray(_data["operationsLog"])) {
                this.operationsLog = [] as any;
                for (let item of _data["operationsLog"])
                    this.operationsLog!.push(OperationLog.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CustomerOrder {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["channelId"] = this.channelId;
        data["storeId"] = this.storeId;
        data["storeName"] = this.storeName;
        data["organizationId"] = this.organizationId;
        data["organizationName"] = this.organizationName;
        data["employeeId"] = this.employeeId;
        data["employeeName"] = this.employeeName;
        data["shoppingCartId"] = this.shoppingCartId;
        data["isPrototype"] = this.isPrototype;
        data["purchaseOrderNumber"] = this.purchaseOrderNumber;
        data["subscriptionNumber"] = this.subscriptionNumber;
        data["subscriptionId"] = this.subscriptionId;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.inPayments)) {
            data["inPayments"] = [];
            for (let item of this.inPayments)
                data["inPayments"].push(item.toJSON());
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.shipments)) {
            data["shipments"] = [];
            for (let item of this.shipments)
                data["shipments"].push(item.toJSON());
        }
        if (Array.isArray(this.discounts)) {
            data["discounts"] = [];
            for (let item of this.discounts)
                data["discounts"].push(item.toJSON());
        }
        data["discountAmount"] = this.discountAmount;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["total"] = this.total;
        data["subTotal"] = this.subTotal;
        data["subTotalWithTax"] = this.subTotalWithTax;
        data["subTotalDiscount"] = this.subTotalDiscount;
        data["subTotalDiscountWithTax"] = this.subTotalDiscountWithTax;
        data["subTotalTaxTotal"] = this.subTotalTaxTotal;
        data["shippingTotal"] = this.shippingTotal;
        data["shippingTotalWithTax"] = this.shippingTotalWithTax;
        data["shippingSubTotal"] = this.shippingSubTotal;
        data["shippingSubTotalWithTax"] = this.shippingSubTotalWithTax;
        data["shippingDiscountTotal"] = this.shippingDiscountTotal;
        data["shippingDiscountTotalWithTax"] = this.shippingDiscountTotalWithTax;
        data["shippingTaxTotal"] = this.shippingTaxTotal;
        data["paymentTotal"] = this.paymentTotal;
        data["paymentTotalWithTax"] = this.paymentTotalWithTax;
        data["paymentSubTotal"] = this.paymentSubTotal;
        data["paymentSubTotalWithTax"] = this.paymentSubTotalWithTax;
        data["paymentDiscountTotal"] = this.paymentDiscountTotal;
        data["paymentDiscountTotalWithTax"] = this.paymentDiscountTotalWithTax;
        data["paymentTaxTotal"] = this.paymentTaxTotal;
        data["discountTotal"] = this.discountTotal;
        data["discountTotalWithTax"] = this.discountTotalWithTax;
        data["fee"] = this.fee;
        data["feeWithTax"] = this.feeWithTax;
        data["feeTotal"] = this.feeTotal;
        data["feeTotalWithTax"] = this.feeTotalWithTax;
        data["taxType"] = this.taxType;
        data["taxTotal"] = this.taxTotal;
        data["taxPercentRate"] = this.taxPercentRate;
        data["languageCode"] = this.languageCode;
        data["operationType"] = this.operationType;
        data["parentOperationId"] = this.parentOperationId;
        data["number"] = this.number;
        data["isApproved"] = this.isApproved;
        data["status"] = this.status;
        data["comment"] = this.comment;
        data["currency"] = this.currency;
        data["sum"] = this.sum;
        data["outerId"] = this.outerId;
        data["isCancelled"] = this.isCancelled;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelReason"] = this.cancelReason;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.operationsLog)) {
            data["operationsLog"] = [];
            for (let item of this.operationsLog)
                data["operationsLog"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICustomerOrder {
    customerId?: string | undefined;
    customerName?: string | undefined;
    channelId?: string | undefined;
    storeId?: string | undefined;
    storeName?: string | undefined;
    organizationId?: string | undefined;
    organizationName?: string | undefined;
    employeeId?: string | undefined;
    employeeName?: string | undefined;
    /** The basis shopping cart id of which the order was created */
    shoppingCartId?: string | undefined;
    /** Flag determines that the order is the prototype */
    isPrototype?: boolean;
    /** Internal number of order provided by customer */
    purchaseOrderNumber?: string | undefined;
    /** Number for subscription  associated with this order */
    subscriptionNumber?: string | undefined;
    /** Identifier for subscription  associated with this order */
    subscriptionId?: string | undefined;
    objectType?: string | undefined;
    addresses?: OrderAddress[] | undefined;
    inPayments?: PaymentIn[] | undefined;
    items?: OrderLineItem[] | undefined;
    shipments?: OrderShipment[] | undefined;
    discounts?: Discount[] | undefined;
    /** When a discount is applied to the order, the tax calculation has already been applied, and is reflected in the tax.
Therefore, a discount applying to the order  will occur after tax. 
For instance, if the cart subtotal is $100, and $15 is the tax subtotal, a cart-wide discount of 10% will yield a total of $105 ($100 subtotal  $10 discount + $15 tax on the original $100). */
    discountAmount?: number;
    taxDetails?: TaxDetail[] | undefined;
    scopes?: string[] | undefined;
    /** Grand order total */
    total?: number;
    subTotal?: number;
    subTotalWithTax?: number;
    subTotalDiscount?: number;
    subTotalDiscountWithTax?: number;
    subTotalTaxTotal?: number;
    shippingTotal?: number;
    shippingTotalWithTax?: number;
    shippingSubTotal?: number;
    shippingSubTotalWithTax?: number;
    shippingDiscountTotal?: number;
    shippingDiscountTotalWithTax?: number;
    shippingTaxTotal?: number;
    paymentTotal?: number;
    paymentTotalWithTax?: number;
    paymentSubTotal?: number;
    paymentSubTotalWithTax?: number;
    paymentDiscountTotal?: number;
    paymentDiscountTotalWithTax?: number;
    paymentTaxTotal?: number;
    discountTotal?: number;
    discountTotalWithTax?: number;
    fee?: number;
    feeWithTax?: number;
    feeTotal?: number;
    feeTotalWithTax?: number;
    /** Tax category or type */
    taxType?: string | undefined;
    taxTotal?: number;
    taxPercentRate?: number;
    languageCode?: string | undefined;
    operationType?: string | undefined;
    parentOperationId?: string | undefined;
    number?: string | undefined;
    isApproved?: boolean;
    status?: string | undefined;
    comment?: string | undefined;
    currency?: string | undefined;
    sum?: number;
    outerId?: string | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    operationsLog?: OperationLog[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CustomerOrderSearchResult implements ICustomerOrderSearchResult {
    readonly customerOrders?: CustomerOrder[] | undefined;
    totalCount?: number;
    results?: CustomerOrder[] | undefined;

    constructor(data?: ICustomerOrderSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["customerOrders"])) {
                (<any>this).customerOrders = [] as any;
                for (let item of _data["customerOrders"])
                    (<any>this).customerOrders!.push(CustomerOrder.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CustomerOrder.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerOrderSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrderSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customerOrders)) {
            data["customerOrders"] = [];
            for (let item of this.customerOrders)
                data["customerOrders"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerOrderSearchResult {
    customerOrders?: CustomerOrder[] | undefined;
    totalCount?: number;
    results?: CustomerOrder[] | undefined;
}

export class BankCardInfo implements IBankCardInfo {
    bankCardNumber?: string | undefined;
    bankCardType?: string | undefined;
    bankCardMonth?: number;
    bankCardYear?: number;
    bankCardCVV2?: string | undefined;
    cardholderName?: string | undefined;

    constructor(data?: IBankCardInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankCardNumber = _data["bankCardNumber"];
            this.bankCardType = _data["bankCardType"];
            this.bankCardMonth = _data["bankCardMonth"];
            this.bankCardYear = _data["bankCardYear"];
            this.bankCardCVV2 = _data["bankCardCVV2"];
            this.cardholderName = _data["cardholderName"];
        }
    }

    static fromJS(data: any): BankCardInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BankCardInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankCardNumber"] = this.bankCardNumber;
        data["bankCardType"] = this.bankCardType;
        data["bankCardMonth"] = this.bankCardMonth;
        data["bankCardYear"] = this.bankCardYear;
        data["bankCardCVV2"] = this.bankCardCVV2;
        data["cardholderName"] = this.cardholderName;
        return data; 
    }
}

export interface IBankCardInfo {
    bankCardNumber?: string | undefined;
    bankCardType?: string | undefined;
    bankCardMonth?: number;
    bankCardYear?: number;
    bankCardCVV2?: string | undefined;
    cardholderName?: string | undefined;
}

export class Money implements IMoney {
    currency?: string | undefined;
    amount?: number;

    constructor(data?: IMoney) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currency = _data["currency"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): Money {
        data = typeof data === 'object' ? data : {};
        let result = new Money();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IMoney {
    currency?: string | undefined;
    amount?: number;
}

export class QuarterPeriodMoney implements IQuarterPeriodMoney {
    year?: number;
    quarter?: number;
    currency?: string | undefined;
    amount?: number;

    constructor(data?: IQuarterPeriodMoney) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.quarter = _data["quarter"];
            this.currency = _data["currency"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): QuarterPeriodMoney {
        data = typeof data === 'object' ? data : {};
        let result = new QuarterPeriodMoney();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["quarter"] = this.quarter;
        data["currency"] = this.currency;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IQuarterPeriodMoney {
    year?: number;
    quarter?: number;
    currency?: string | undefined;
    amount?: number;
}

export class DashboardStatisticsResult implements IDashboardStatisticsResult {
    startDate?: Date;
    endDate?: Date;
    revenue?: Money[] | undefined;
    revenuePeriodDetails?: QuarterPeriodMoney[] | undefined;
    orderCount?: number;
    customersCount?: number;
    revenuePerCustomer?: Money[] | undefined;
    avgOrderValue?: Money[] | undefined;
    avgOrderValuePeriodDetails?: QuarterPeriodMoney[] | undefined;
    itemsPurchased?: number;
    lineitemsPerOrder?: number;

    constructor(data?: IDashboardStatisticsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["revenue"])) {
                this.revenue = [] as any;
                for (let item of _data["revenue"])
                    this.revenue!.push(Money.fromJS(item));
            }
            if (Array.isArray(_data["revenuePeriodDetails"])) {
                this.revenuePeriodDetails = [] as any;
                for (let item of _data["revenuePeriodDetails"])
                    this.revenuePeriodDetails!.push(QuarterPeriodMoney.fromJS(item));
            }
            this.orderCount = _data["orderCount"];
            this.customersCount = _data["customersCount"];
            if (Array.isArray(_data["revenuePerCustomer"])) {
                this.revenuePerCustomer = [] as any;
                for (let item of _data["revenuePerCustomer"])
                    this.revenuePerCustomer!.push(Money.fromJS(item));
            }
            if (Array.isArray(_data["avgOrderValue"])) {
                this.avgOrderValue = [] as any;
                for (let item of _data["avgOrderValue"])
                    this.avgOrderValue!.push(Money.fromJS(item));
            }
            if (Array.isArray(_data["avgOrderValuePeriodDetails"])) {
                this.avgOrderValuePeriodDetails = [] as any;
                for (let item of _data["avgOrderValuePeriodDetails"])
                    this.avgOrderValuePeriodDetails!.push(QuarterPeriodMoney.fromJS(item));
            }
            this.itemsPurchased = _data["itemsPurchased"];
            this.lineitemsPerOrder = _data["lineitemsPerOrder"];
        }
    }

    static fromJS(data: any): DashboardStatisticsResult {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardStatisticsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.revenue)) {
            data["revenue"] = [];
            for (let item of this.revenue)
                data["revenue"].push(item.toJSON());
        }
        if (Array.isArray(this.revenuePeriodDetails)) {
            data["revenuePeriodDetails"] = [];
            for (let item of this.revenuePeriodDetails)
                data["revenuePeriodDetails"].push(item.toJSON());
        }
        data["orderCount"] = this.orderCount;
        data["customersCount"] = this.customersCount;
        if (Array.isArray(this.revenuePerCustomer)) {
            data["revenuePerCustomer"] = [];
            for (let item of this.revenuePerCustomer)
                data["revenuePerCustomer"].push(item.toJSON());
        }
        if (Array.isArray(this.avgOrderValue)) {
            data["avgOrderValue"] = [];
            for (let item of this.avgOrderValue)
                data["avgOrderValue"].push(item.toJSON());
        }
        if (Array.isArray(this.avgOrderValuePeriodDetails)) {
            data["avgOrderValuePeriodDetails"] = [];
            for (let item of this.avgOrderValuePeriodDetails)
                data["avgOrderValuePeriodDetails"].push(item.toJSON());
        }
        data["itemsPurchased"] = this.itemsPurchased;
        data["lineitemsPerOrder"] = this.lineitemsPerOrder;
        return data; 
    }
}

export interface IDashboardStatisticsResult {
    startDate?: Date;
    endDate?: Date;
    revenue?: Money[] | undefined;
    revenuePeriodDetails?: QuarterPeriodMoney[] | undefined;
    orderCount?: number;
    customersCount?: number;
    revenuePerCustomer?: Money[] | undefined;
    avgOrderValue?: Money[] | undefined;
    avgOrderValuePeriodDetails?: QuarterPeriodMoney[] | undefined;
    itemsPurchased?: number;
    lineitemsPerOrder?: number;
}

export class KeyValuePair implements IKeyValuePair {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): KeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IKeyValuePair {
    key?: string | undefined;
    value?: string | undefined;
}

export class PaymentCallbackParameters implements IPaymentCallbackParameters {
    parameters?: KeyValuePair[] | undefined;

    constructor(data?: IPaymentCallbackParameters) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["parameters"])) {
                this.parameters = [] as any;
                for (let item of _data["parameters"])
                    this.parameters!.push(KeyValuePair.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentCallbackParameters {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentCallbackParameters();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.parameters)) {
            data["parameters"] = [];
            for (let item of this.parameters)
                data["parameters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaymentCallbackParameters {
    parameters?: KeyValuePair[] | undefined;
}

export class PostProcessPaymentRequestResult implements IPostProcessPaymentRequestResult {
    returnUrl?: string | undefined;
    orderId?: string | undefined;
    outerId?: string | undefined;
    paymentMethod?: PaymentMethod;
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    newPaymentStatus?: PaymentStatus;

    constructor(data?: IPostProcessPaymentRequestResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.returnUrl = _data["returnUrl"];
            this.orderId = _data["orderId"];
            this.outerId = _data["outerId"];
            this.paymentMethod = _data["paymentMethod"] ? PaymentMethod.fromJS(_data["paymentMethod"]) : <any>undefined;
            this.isSuccess = _data["isSuccess"];
            this.errorMessage = _data["errorMessage"];
            this.newPaymentStatus = _data["newPaymentStatus"];
        }
    }

    static fromJS(data: any): PostProcessPaymentRequestResult {
        data = typeof data === 'object' ? data : {};
        let result = new PostProcessPaymentRequestResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["returnUrl"] = this.returnUrl;
        data["orderId"] = this.orderId;
        data["outerId"] = this.outerId;
        data["paymentMethod"] = this.paymentMethod ? this.paymentMethod.toJSON() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["errorMessage"] = this.errorMessage;
        data["newPaymentStatus"] = this.newPaymentStatus;
        return data; 
    }
}

export interface IPostProcessPaymentRequestResult {
    returnUrl?: string | undefined;
    orderId?: string | undefined;
    outerId?: string | undefined;
    paymentMethod?: PaymentMethod;
    isSuccess?: boolean;
    errorMessage?: string | undefined;
    newPaymentStatus?: PaymentStatus;
}

export class CustomerOrderHistorySearchCriteria implements ICustomerOrderHistorySearchCriteria {
    orderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICustomerOrderHistorySearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CustomerOrderHistorySearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrderHistorySearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ICustomerOrderHistorySearchCriteria {
    orderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class CustomerOrderIndexedSearchCriteria implements ICustomerOrderIndexedSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICustomerOrderIndexedSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CustomerOrderIndexedSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerOrderIndexedSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ICustomerOrderIndexedSearchCriteria {
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PaymentSearchCriteria implements IPaymentSearchCriteria {
    /** It used to limit search within a customer order id */
    orderId?: string | undefined;
    /** It used to limit search within a customer order number */
    orderNumber?: string | undefined;
    /** Filter payments by customer */
    customerId?: string | undefined;
    capturedStartDate?: Date | undefined;
    capturedEndDate?: Date | undefined;
    authorizedStartDate?: Date | undefined;
    authorizedEndDate?: Date | undefined;
    ids?: string[] | undefined;
    employeeId?: string | undefined;
    storeIds?: string[] | undefined;
    /** Search by status */
    status?: string | undefined;
    statuses?: string[] | undefined;
    /** Search by numbers */
    number?: string | undefined;
    numbers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPaymentSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.orderNumber = _data["orderNumber"];
            this.customerId = _data["customerId"];
            this.capturedStartDate = _data["capturedStartDate"] ? new Date(_data["capturedStartDate"].toString()) : <any>undefined;
            this.capturedEndDate = _data["capturedEndDate"] ? new Date(_data["capturedEndDate"].toString()) : <any>undefined;
            this.authorizedStartDate = _data["authorizedStartDate"] ? new Date(_data["authorizedStartDate"].toString()) : <any>undefined;
            this.authorizedEndDate = _data["authorizedEndDate"] ? new Date(_data["authorizedEndDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
            this.employeeId = _data["employeeId"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.status = _data["status"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.number = _data["number"];
            if (Array.isArray(_data["numbers"])) {
                this.numbers = [] as any;
                for (let item of _data["numbers"])
                    this.numbers!.push(item);
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PaymentSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["orderNumber"] = this.orderNumber;
        data["customerId"] = this.customerId;
        data["capturedStartDate"] = this.capturedStartDate ? this.capturedStartDate.toISOString() : <any>undefined;
        data["capturedEndDate"] = this.capturedEndDate ? this.capturedEndDate.toISOString() : <any>undefined;
        data["authorizedStartDate"] = this.authorizedStartDate ? this.authorizedStartDate.toISOString() : <any>undefined;
        data["authorizedEndDate"] = this.authorizedEndDate ? this.authorizedEndDate.toISOString() : <any>undefined;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        data["employeeId"] = this.employeeId;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["status"] = this.status;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["number"] = this.number;
        if (Array.isArray(this.numbers)) {
            data["numbers"] = [];
            for (let item of this.numbers)
                data["numbers"].push(item);
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IPaymentSearchCriteria {
    /** It used to limit search within a customer order id */
    orderId?: string | undefined;
    /** It used to limit search within a customer order number */
    orderNumber?: string | undefined;
    /** Filter payments by customer */
    customerId?: string | undefined;
    capturedStartDate?: Date | undefined;
    capturedEndDate?: Date | undefined;
    authorizedStartDate?: Date | undefined;
    authorizedEndDate?: Date | undefined;
    ids?: string[] | undefined;
    employeeId?: string | undefined;
    storeIds?: string[] | undefined;
    /** Search by status */
    status?: string | undefined;
    statuses?: string[] | undefined;
    /** Search by numbers */
    number?: string | undefined;
    numbers?: string[] | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PaymentSearchResult implements IPaymentSearchResult {
    totalCount?: number;
    results?: PaymentIn[] | undefined;

    constructor(data?: IPaymentSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PaymentIn.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaymentSearchResult {
    totalCount?: number;
    results?: PaymentIn[] | undefined;
}

export class PaymentMethodsSearchCriteria implements IPaymentMethodsSearchCriteria {
    storeId?: string | undefined;
    codes?: string[] | undefined;
    isActive?: boolean | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPaymentMethodsSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["codes"])) {
                this.codes = [] as any;
                for (let item of _data["codes"])
                    this.codes!.push(item);
            }
            this.isActive = _data["isActive"];
            this.withoutTransient = _data["withoutTransient"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PaymentMethodsSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodsSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        if (Array.isArray(this.codes)) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        data["isActive"] = this.isActive;
        data["withoutTransient"] = this.withoutTransient;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IPaymentMethodsSearchCriteria {
    storeId?: string | undefined;
    codes?: string[] | undefined;
    isActive?: boolean | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PaymentMethodsSearchResult implements IPaymentMethodsSearchResult {
    totalCount?: number;
    results?: PaymentMethod[] | undefined;

    constructor(data?: IPaymentMethodsSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PaymentMethod.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PaymentMethodsSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentMethodsSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPaymentMethodsSearchResult {
    totalCount?: number;
    results?: PaymentMethod[] | undefined;
}

export class PriceEvaluationContext implements IPriceEvaluationContext {
    storeId?: string | undefined;
    catalogId?: string | undefined;
    productIds?: string[] | undefined;
    pricelistIds?: string[] | undefined;
    returnAllMatchedPrices?: boolean;
    quantity?: number;
    customerId?: string | undefined;
    organizationId?: string | undefined;
    certainDate?: Date | undefined;
    currency?: string | undefined;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;

    constructor(data?: IPriceEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.catalogId = _data["catalogId"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            if (Array.isArray(_data["pricelistIds"])) {
                this.pricelistIds = [] as any;
                for (let item of _data["pricelistIds"])
                    this.pricelistIds!.push(item);
            }
            this.returnAllMatchedPrices = _data["returnAllMatchedPrices"];
            this.quantity = _data["quantity"];
            this.customerId = _data["customerId"];
            this.organizationId = _data["organizationId"];
            this.certainDate = _data["certainDate"] ? new Date(_data["certainDate"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.contextObject = _data["contextObject"];
            this.geoCity = _data["geoCity"];
            this.geoState = _data["geoState"];
            this.geoCountry = _data["geoCountry"];
            this.geoContinent = _data["geoContinent"];
            this.geoZipCode = _data["geoZipCode"];
            this.geoConnectionType = _data["geoConnectionType"];
            this.geoTimeZone = _data["geoTimeZone"];
            this.geoIpRoutingType = _data["geoIpRoutingType"];
            this.geoIspSecondLevel = _data["geoIspSecondLevel"];
            this.geoIspTopLevel = _data["geoIspTopLevel"];
            this.shopperAge = _data["shopperAge"];
            this.shopperGender = _data["shopperGender"];
            this.language = _data["language"];
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
            this.shopperSearchedPhraseOnInternet = _data["shopperSearchedPhraseOnInternet"];
            this.currentUrl = _data["currentUrl"];
            this.referredUrl = _data["referredUrl"];
        }
    }

    static fromJS(data: any): PriceEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new PriceEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["catalogId"] = this.catalogId;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        if (Array.isArray(this.pricelistIds)) {
            data["pricelistIds"] = [];
            for (let item of this.pricelistIds)
                data["pricelistIds"].push(item);
        }
        data["returnAllMatchedPrices"] = this.returnAllMatchedPrices;
        data["quantity"] = this.quantity;
        data["customerId"] = this.customerId;
        data["organizationId"] = this.organizationId;
        data["certainDate"] = this.certainDate ? this.certainDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["contextObject"] = this.contextObject;
        data["geoCity"] = this.geoCity;
        data["geoState"] = this.geoState;
        data["geoCountry"] = this.geoCountry;
        data["geoContinent"] = this.geoContinent;
        data["geoZipCode"] = this.geoZipCode;
        data["geoConnectionType"] = this.geoConnectionType;
        data["geoTimeZone"] = this.geoTimeZone;
        data["geoIpRoutingType"] = this.geoIpRoutingType;
        data["geoIspSecondLevel"] = this.geoIspSecondLevel;
        data["geoIspTopLevel"] = this.geoIspTopLevel;
        data["shopperAge"] = this.shopperAge;
        data["shopperGender"] = this.shopperGender;
        data["language"] = this.language;
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
        data["shopperSearchedPhraseOnInternet"] = this.shopperSearchedPhraseOnInternet;
        data["currentUrl"] = this.currentUrl;
        data["referredUrl"] = this.referredUrl;
        return data; 
    }
}

export interface IPriceEvaluationContext {
    storeId?: string | undefined;
    catalogId?: string | undefined;
    productIds?: string[] | undefined;
    pricelistIds?: string[] | undefined;
    returnAllMatchedPrices?: boolean;
    quantity?: number;
    customerId?: string | undefined;
    organizationId?: string | undefined;
    certainDate?: Date | undefined;
    currency?: string | undefined;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    /** Any tags or groups belongs to user such as VIP, Wholesaler etc */
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;
}

export class PricelistSearchResult implements IPricelistSearchResult {
    totalCount?: number;
    results?: Pricelist[] | undefined;

    constructor(data?: IPricelistSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Pricelist.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PricelistSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PricelistSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPricelistSearchResult {
    totalCount?: number;
    results?: Pricelist[] | undefined;
}

export class PricelistAssignmentSearchResult implements IPricelistAssignmentSearchResult {
    totalCount?: number;
    results?: PricelistAssignment[] | undefined;

    constructor(data?: IPricelistAssignmentSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(PricelistAssignment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PricelistAssignmentSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PricelistAssignmentSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPricelistAssignmentSearchResult {
    totalCount?: number;
    results?: PricelistAssignment[] | undefined;
}

export class ProductPrice implements IProductPrice {
    productId?: string | undefined;
    product?: CatalogProduct;
    /** List prices for the products. It includes tiered prices also. (Depending on the quantity, for example) */
    prices?: Price[] | undefined;

    constructor(data?: IProductPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.product = _data["product"] ? CatalogProduct.fromJS(_data["product"]) : <any>undefined;
            if (Array.isArray(_data["prices"])) {
                this.prices = [] as any;
                for (let item of _data["prices"])
                    this.prices!.push(Price.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductPrice {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        if (Array.isArray(this.prices)) {
            data["prices"] = [];
            for (let item of this.prices)
                data["prices"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductPrice {
    productId?: string | undefined;
    product?: CatalogProduct;
    /** List prices for the products. It includes tiered prices also. (Depending on the quantity, for example) */
    prices?: Price[] | undefined;
}

export class ProductPriceSearchResult implements IProductPriceSearchResult {
    totalCount?: number;
    results?: ProductPrice[] | undefined;

    constructor(data?: IProductPriceSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ProductPrice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductPriceSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPriceSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductPriceSearchResult {
    totalCount?: number;
    results?: ProductPrice[] | undefined;
}

export class PricesSearchCriteria implements IPricesSearchCriteria {
    groupByProducts?: boolean;
    priceListId?: string | undefined;
    priceListIds?: string[] | undefined;
    productId?: string | undefined;
    productIds?: string[] | undefined;
    modifiedSince?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPricesSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupByProducts = _data["groupByProducts"];
            this.priceListId = _data["priceListId"];
            if (Array.isArray(_data["priceListIds"])) {
                this.priceListIds = [] as any;
                for (let item of _data["priceListIds"])
                    this.priceListIds!.push(item);
            }
            this.productId = _data["productId"];
            if (Array.isArray(_data["productIds"])) {
                this.productIds = [] as any;
                for (let item of _data["productIds"])
                    this.productIds!.push(item);
            }
            this.modifiedSince = _data["modifiedSince"] ? new Date(_data["modifiedSince"].toString()) : <any>undefined;
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PricesSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PricesSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupByProducts"] = this.groupByProducts;
        data["priceListId"] = this.priceListId;
        if (Array.isArray(this.priceListIds)) {
            data["priceListIds"] = [];
            for (let item of this.priceListIds)
                data["priceListIds"].push(item);
        }
        data["productId"] = this.productId;
        if (Array.isArray(this.productIds)) {
            data["productIds"] = [];
            for (let item of this.productIds)
                data["productIds"].push(item);
        }
        data["modifiedSince"] = this.modifiedSince ? this.modifiedSince.toISOString() : <any>undefined;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IPricesSearchCriteria {
    groupByProducts?: boolean;
    priceListId?: string | undefined;
    priceListIds?: string[] | undefined;
    productId?: string | undefined;
    productIds?: string[] | undefined;
    modifiedSince?: Date | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class IndexState implements IIndexState {
    provider?: string | undefined;
    scope?: string | undefined;
    documentType?: string | undefined;
    indexedDocumentsCount?: number | undefined;
    lastIndexationDate?: Date | undefined;

    constructor(data?: IIndexState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.provider = _data["provider"];
            this.scope = _data["scope"];
            this.documentType = _data["documentType"];
            this.indexedDocumentsCount = _data["indexedDocumentsCount"];
            this.lastIndexationDate = _data["lastIndexationDate"] ? new Date(_data["lastIndexationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): IndexState {
        data = typeof data === 'object' ? data : {};
        let result = new IndexState();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["scope"] = this.scope;
        data["documentType"] = this.documentType;
        data["indexedDocumentsCount"] = this.indexedDocumentsCount;
        data["lastIndexationDate"] = this.lastIndexationDate ? this.lastIndexationDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IIndexState {
    provider?: string | undefined;
    scope?: string | undefined;
    documentType?: string | undefined;
    indexedDocumentsCount?: number | undefined;
    lastIndexationDate?: Date | undefined;
}

export class IndexDocumentField implements IIndexDocumentField {
    name?: string | undefined;
    values?: any[] | undefined;
    value?: any | undefined;
    isRetrievable?: boolean;
    isFilterable?: boolean;
    isSearchable?: boolean;
    isCollection?: boolean;

    constructor(data?: IIndexDocumentField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
            this.value = _data["value"];
            this.isRetrievable = _data["isRetrievable"];
            this.isFilterable = _data["isFilterable"];
            this.isSearchable = _data["isSearchable"];
            this.isCollection = _data["isCollection"];
        }
    }

    static fromJS(data: any): IndexDocumentField {
        data = typeof data === 'object' ? data : {};
        let result = new IndexDocumentField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        data["value"] = this.value;
        data["isRetrievable"] = this.isRetrievable;
        data["isFilterable"] = this.isFilterable;
        data["isSearchable"] = this.isSearchable;
        data["isCollection"] = this.isCollection;
        return data; 
    }
}

export interface IIndexDocumentField {
    name?: string | undefined;
    values?: any[] | undefined;
    value?: any | undefined;
    isRetrievable?: boolean;
    isFilterable?: boolean;
    isSearchable?: boolean;
    isCollection?: boolean;
}

export class IndexDocument implements IIndexDocument {
    fields?: IndexDocumentField[] | undefined;
    id?: string | undefined;

    constructor(data?: IIndexDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(IndexDocumentField.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IndexDocument {
        data = typeof data === 'object' ? data : {};
        let result = new IndexDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IIndexDocument {
    fields?: IndexDocumentField[] | undefined;
    id?: string | undefined;
}

export class IndexingOptions implements IIndexingOptions {
    documentType?: string | undefined;
    documentIds?: string[] | undefined;
    deleteExistingIndex?: boolean;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    batchSize?: number | undefined;

    constructor(data?: IIndexingOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"];
            if (Array.isArray(_data["documentIds"])) {
                this.documentIds = [] as any;
                for (let item of _data["documentIds"])
                    this.documentIds!.push(item);
            }
            this.deleteExistingIndex = _data["deleteExistingIndex"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.batchSize = _data["batchSize"];
        }
    }

    static fromJS(data: any): IndexingOptions {
        data = typeof data === 'object' ? data : {};
        let result = new IndexingOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        if (Array.isArray(this.documentIds)) {
            data["documentIds"] = [];
            for (let item of this.documentIds)
                data["documentIds"].push(item);
        }
        data["deleteExistingIndex"] = this.deleteExistingIndex;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["batchSize"] = this.batchSize;
        return data; 
    }
}

export interface IIndexingOptions {
    documentType?: string | undefined;
    documentIds?: string[] | undefined;
    deleteExistingIndex?: boolean;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    batchSize?: number | undefined;
}

export class IndexProgressPushNotification implements IIndexProgressPushNotification {
    documentType?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IIndexProgressPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentType = _data["documentType"];
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            this.errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IndexProgressPushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new IndexProgressPushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentType"] = this.documentType;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface IIndexProgressPushNotification {
    documentType?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ShippingMethodsSearchCriteria implements IShippingMethodsSearchCriteria {
    storeId?: string | undefined;
    codes?: string[] | undefined;
    isActive?: boolean | undefined;
    taxType?: string | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IShippingMethodsSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["codes"])) {
                this.codes = [] as any;
                for (let item of _data["codes"])
                    this.codes!.push(item);
            }
            this.isActive = _data["isActive"];
            this.taxType = _data["taxType"];
            this.withoutTransient = _data["withoutTransient"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): ShippingMethodsSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingMethodsSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        if (Array.isArray(this.codes)) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        data["isActive"] = this.isActive;
        data["taxType"] = this.taxType;
        data["withoutTransient"] = this.withoutTransient;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IShippingMethodsSearchCriteria {
    storeId?: string | undefined;
    codes?: string[] | undefined;
    isActive?: boolean | undefined;
    taxType?: string | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class ShippingMethodsSearchResult implements IShippingMethodsSearchResult {
    totalCount?: number;
    results?: ShippingMethod[] | undefined;

    constructor(data?: IShippingMethodsSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ShippingMethod.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShippingMethodsSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingMethodsSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IShippingMethodsSearchResult {
    totalCount?: number;
    results?: ShippingMethod[] | undefined;
}

export class SitemapSearchCriteria implements ISitemapSearchCriteria {
    storeId?: string | undefined;
    location?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISitemapSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.location = _data["location"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SitemapSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["location"] = this.location;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ISitemapSearchCriteria {
    storeId?: string | undefined;
    location?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SitemapItemAlternateLinkRecord implements ISitemapItemAlternateLinkRecord {
    url?: string | undefined;
    language?: string | undefined;
    type?: string | undefined;

    constructor(data?: ISitemapItemAlternateLinkRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.language = _data["language"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): SitemapItemAlternateLinkRecord {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapItemAlternateLinkRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["language"] = this.language;
        data["type"] = this.type;
        return data; 
    }
}

export interface ISitemapItemAlternateLinkRecord {
    url?: string | undefined;
    language?: string | undefined;
    type?: string | undefined;
}

export class SitemapItemRecord implements ISitemapItemRecord {
    url?: string | undefined;
    modifiedDate?: Date;
    updateFrequency?: string | undefined;
    priority?: number;
    alternates?: SitemapItemAlternateLinkRecord[] | undefined;

    constructor(data?: ISitemapItemRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.updateFrequency = _data["updateFrequency"];
            this.priority = _data["priority"];
            if (Array.isArray(_data["alternates"])) {
                this.alternates = [] as any;
                for (let item of _data["alternates"])
                    this.alternates!.push(SitemapItemAlternateLinkRecord.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitemapItemRecord {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapItemRecord();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["updateFrequency"] = this.updateFrequency;
        data["priority"] = this.priority;
        if (Array.isArray(this.alternates)) {
            data["alternates"] = [];
            for (let item of this.alternates)
                data["alternates"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISitemapItemRecord {
    url?: string | undefined;
    modifiedDate?: Date;
    updateFrequency?: string | undefined;
    priority?: number;
    alternates?: SitemapItemAlternateLinkRecord[] | undefined;
}

export class SitemapItem implements ISitemapItem {
    sitemapId?: string | undefined;
    title?: string | undefined;
    imageUrl?: string | undefined;
    objectId?: string | undefined;
    objectType?: string | undefined;
    urlTemplate?: string | undefined;
    itemsRecords?: SitemapItemRecord[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISitemapItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sitemapId = _data["sitemapId"];
            this.title = _data["title"];
            this.imageUrl = _data["imageUrl"];
            this.objectId = _data["objectId"];
            this.objectType = _data["objectType"];
            this.urlTemplate = _data["urlTemplate"];
            if (Array.isArray(_data["itemsRecords"])) {
                this.itemsRecords = [] as any;
                for (let item of _data["itemsRecords"])
                    this.itemsRecords!.push(SitemapItemRecord.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SitemapItem {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sitemapId"] = this.sitemapId;
        data["title"] = this.title;
        data["imageUrl"] = this.imageUrl;
        data["objectId"] = this.objectId;
        data["objectType"] = this.objectType;
        data["urlTemplate"] = this.urlTemplate;
        if (Array.isArray(this.itemsRecords)) {
            data["itemsRecords"] = [];
            for (let item of this.itemsRecords)
                data["itemsRecords"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISitemapItem {
    sitemapId?: string | undefined;
    title?: string | undefined;
    imageUrl?: string | undefined;
    objectId?: string | undefined;
    objectType?: string | undefined;
    urlTemplate?: string | undefined;
    itemsRecords?: SitemapItemRecord[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class Sitemap implements ISitemap {
    location?: string | undefined;
    storeId?: string | undefined;
    items?: SitemapItem[] | undefined;
    urlTemplate?: string | undefined;
    totalItemsCount?: number;
    pagedLocations?: string[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISitemap) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SitemapItem.fromJS(item));
            }
            this.urlTemplate = _data["urlTemplate"];
            this.totalItemsCount = _data["totalItemsCount"];
            if (Array.isArray(_data["pagedLocations"])) {
                this.pagedLocations = [] as any;
                for (let item of _data["pagedLocations"])
                    this.pagedLocations!.push(item);
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Sitemap {
        data = typeof data === 'object' ? data : {};
        let result = new Sitemap();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["storeId"] = this.storeId;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["urlTemplate"] = this.urlTemplate;
        data["totalItemsCount"] = this.totalItemsCount;
        if (Array.isArray(this.pagedLocations)) {
            data["pagedLocations"] = [];
            for (let item of this.pagedLocations)
                data["pagedLocations"].push(item);
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISitemap {
    location?: string | undefined;
    storeId?: string | undefined;
    items?: SitemapItem[] | undefined;
    urlTemplate?: string | undefined;
    totalItemsCount?: number;
    pagedLocations?: string[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class SitemapSearchResult implements ISitemapSearchResult {
    totalCount?: number;
    results?: Sitemap[] | undefined;

    constructor(data?: ISitemapSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Sitemap.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitemapSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISitemapSearchResult {
    totalCount?: number;
    results?: Sitemap[] | undefined;
}

export class SitemapItemSearchCriteria implements ISitemapItemSearchCriteria {
    sitemapId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISitemapItemSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sitemapId = _data["sitemapId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SitemapItemSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapItemSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sitemapId"] = this.sitemapId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ISitemapItemSearchCriteria {
    sitemapId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SitemapItemsSearchResult implements ISitemapItemsSearchResult {
    totalCount?: number;
    results?: SitemapItem[] | undefined;

    constructor(data?: ISitemapItemsSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(SitemapItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SitemapItemsSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapItemsSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISitemapItemsSearchResult {
    totalCount?: number;
    results?: SitemapItem[] | undefined;
}

export class SitemapDownloadNotification implements ISitemapDownloadNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    readonly errorCount?: number;
    errors?: string[] | undefined;
    downloadUrl?: string | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: ISitemapDownloadNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.downloadUrl = _data["downloadUrl"];
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SitemapDownloadNotification {
        data = typeof data === 'object' ? data : {};
        let result = new SitemapDownloadNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["downloadUrl"] = this.downloadUrl;
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISitemapDownloadNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    downloadUrl?: string | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export enum StoreState {
    Open = "Open",
    Closed = "Closed",
    RestrictedAccess = "RestrictedAccess",
}

export class StoreSearchCriteria implements IStoreSearchCriteria {
    storeIds?: string[] | undefined;
    storeStates?: StoreState[] | undefined;
    fulfillmentCenterIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IStoreSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            if (Array.isArray(_data["storeStates"])) {
                this.storeStates = [] as any;
                for (let item of _data["storeStates"])
                    this.storeStates!.push(item);
            }
            if (Array.isArray(_data["fulfillmentCenterIds"])) {
                this.fulfillmentCenterIds = [] as any;
                for (let item of _data["fulfillmentCenterIds"])
                    this.fulfillmentCenterIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): StoreSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new StoreSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        if (Array.isArray(this.storeStates)) {
            data["storeStates"] = [];
            for (let item of this.storeStates)
                data["storeStates"].push(item);
        }
        if (Array.isArray(this.fulfillmentCenterIds)) {
            data["fulfillmentCenterIds"] = [];
            for (let item of this.fulfillmentCenterIds)
                data["fulfillmentCenterIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IStoreSearchCriteria {
    storeIds?: string[] | undefined;
    storeStates?: StoreState[] | undefined;
    fulfillmentCenterIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class Store implements IStore {
    name?: string | undefined;
    description?: string | undefined;
    storeState?: StoreState;
    timeZone?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    defaultLanguage?: string | undefined;
    defaultCurrency?: string | undefined;
    /** Catalog id used as primary store catalog */
    catalog?: string | undefined;
    creditCardSavePolicy?: boolean;
    /** Store storefront url */
    url?: string | undefined;
    /** Store storefront https url */
    secureUrl?: string | undefined;
    /** Primary store contact email can be used for store event notifications and for feed back */
    email?: string | undefined;
    adminEmail?: string | undefined;
    emailName?: string | undefined;
    adminEmailName?: string | undefined;
    displayOutOfStock?: boolean;
    outerId?: string | undefined;
    /** Primary (default) fulfillment center id */
    mainFulfillmentCenterId?: string | undefined;
    /** Alternate fulfillment centers ids */
    additionalFulfillmentCenterIds?: string[] | undefined;
    /** Primary (default) fulfillment center for order return */
    mainReturnsFulfillmentCenterId?: string | undefined;
    /** Alternate fulfillment centers for order return */
    returnsFulfillmentCenterIds?: string[] | undefined;
    /** All store supported languages */
    languages?: string[] | undefined;
    /** All store supported currencies */
    currencies?: string[] | undefined;
    /** All store trusted groups (group of stores that shared the user logins) */
    trustedGroups?: string[] | undefined;
    readonly seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    readonly typeName?: string | undefined;
    scopes?: string[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.storeState = _data["storeState"];
            this.timeZone = _data["timeZone"];
            this.country = _data["country"];
            this.region = _data["region"];
            this.defaultLanguage = _data["defaultLanguage"];
            this.defaultCurrency = _data["defaultCurrency"];
            this.catalog = _data["catalog"];
            this.creditCardSavePolicy = _data["creditCardSavePolicy"];
            this.url = _data["url"];
            this.secureUrl = _data["secureUrl"];
            this.email = _data["email"];
            this.adminEmail = _data["adminEmail"];
            this.emailName = _data["emailName"];
            this.adminEmailName = _data["adminEmailName"];
            this.displayOutOfStock = _data["displayOutOfStock"];
            this.outerId = _data["outerId"];
            this.mainFulfillmentCenterId = _data["mainFulfillmentCenterId"];
            if (Array.isArray(_data["additionalFulfillmentCenterIds"])) {
                this.additionalFulfillmentCenterIds = [] as any;
                for (let item of _data["additionalFulfillmentCenterIds"])
                    this.additionalFulfillmentCenterIds!.push(item);
            }
            this.mainReturnsFulfillmentCenterId = _data["mainReturnsFulfillmentCenterId"];
            if (Array.isArray(_data["returnsFulfillmentCenterIds"])) {
                this.returnsFulfillmentCenterIds = [] as any;
                for (let item of _data["returnsFulfillmentCenterIds"])
                    this.returnsFulfillmentCenterIds!.push(item);
            }
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(item);
            }
            if (Array.isArray(_data["currencies"])) {
                this.currencies = [] as any;
                for (let item of _data["currencies"])
                    this.currencies!.push(item);
            }
            if (Array.isArray(_data["trustedGroups"])) {
                this.trustedGroups = [] as any;
                for (let item of _data["trustedGroups"])
                    this.trustedGroups!.push(item);
            }
            (<any>this).seoObjectType = _data["seoObjectType"];
            if (Array.isArray(_data["seoInfos"])) {
                this.seoInfos = [] as any;
                for (let item of _data["seoInfos"])
                    this.seoInfos!.push(SeoInfo.fromJS(item));
            }
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            (<any>this).typeName = _data["typeName"];
            if (Array.isArray(_data["scopes"])) {
                this.scopes = [] as any;
                for (let item of _data["scopes"])
                    this.scopes!.push(item);
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Store {
        data = typeof data === 'object' ? data : {};
        let result = new Store();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["storeState"] = this.storeState;
        data["timeZone"] = this.timeZone;
        data["country"] = this.country;
        data["region"] = this.region;
        data["defaultLanguage"] = this.defaultLanguage;
        data["defaultCurrency"] = this.defaultCurrency;
        data["catalog"] = this.catalog;
        data["creditCardSavePolicy"] = this.creditCardSavePolicy;
        data["url"] = this.url;
        data["secureUrl"] = this.secureUrl;
        data["email"] = this.email;
        data["adminEmail"] = this.adminEmail;
        data["emailName"] = this.emailName;
        data["adminEmailName"] = this.adminEmailName;
        data["displayOutOfStock"] = this.displayOutOfStock;
        data["outerId"] = this.outerId;
        data["mainFulfillmentCenterId"] = this.mainFulfillmentCenterId;
        if (Array.isArray(this.additionalFulfillmentCenterIds)) {
            data["additionalFulfillmentCenterIds"] = [];
            for (let item of this.additionalFulfillmentCenterIds)
                data["additionalFulfillmentCenterIds"].push(item);
        }
        data["mainReturnsFulfillmentCenterId"] = this.mainReturnsFulfillmentCenterId;
        if (Array.isArray(this.returnsFulfillmentCenterIds)) {
            data["returnsFulfillmentCenterIds"] = [];
            for (let item of this.returnsFulfillmentCenterIds)
                data["returnsFulfillmentCenterIds"].push(item);
        }
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item);
        }
        if (Array.isArray(this.currencies)) {
            data["currencies"] = [];
            for (let item of this.currencies)
                data["currencies"].push(item);
        }
        if (Array.isArray(this.trustedGroups)) {
            data["trustedGroups"] = [];
            for (let item of this.trustedGroups)
                data["trustedGroups"].push(item);
        }
        data["seoObjectType"] = this.seoObjectType;
        if (Array.isArray(this.seoInfos)) {
            data["seoInfos"] = [];
            for (let item of this.seoInfos)
                data["seoInfos"].push(item.toJSON());
        }
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["typeName"] = this.typeName;
        if (Array.isArray(this.scopes)) {
            data["scopes"] = [];
            for (let item of this.scopes)
                data["scopes"].push(item);
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IStore {
    name?: string | undefined;
    description?: string | undefined;
    storeState?: StoreState;
    timeZone?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    defaultLanguage?: string | undefined;
    defaultCurrency?: string | undefined;
    /** Catalog id used as primary store catalog */
    catalog?: string | undefined;
    creditCardSavePolicy?: boolean;
    /** Store storefront url */
    url?: string | undefined;
    /** Store storefront https url */
    secureUrl?: string | undefined;
    /** Primary store contact email can be used for store event notifications and for feed back */
    email?: string | undefined;
    adminEmail?: string | undefined;
    emailName?: string | undefined;
    adminEmailName?: string | undefined;
    displayOutOfStock?: boolean;
    outerId?: string | undefined;
    /** Primary (default) fulfillment center id */
    mainFulfillmentCenterId?: string | undefined;
    /** Alternate fulfillment centers ids */
    additionalFulfillmentCenterIds?: string[] | undefined;
    /** Primary (default) fulfillment center for order return */
    mainReturnsFulfillmentCenterId?: string | undefined;
    /** Alternate fulfillment centers for order return */
    returnsFulfillmentCenterIds?: string[] | undefined;
    /** All store supported languages */
    languages?: string[] | undefined;
    /** All store supported currencies */
    currencies?: string[] | undefined;
    /** All store trusted groups (group of stores that shared the user logins) */
    trustedGroups?: string[] | undefined;
    seoObjectType?: string | undefined;
    seoInfos?: SeoInfo[] | undefined;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    typeName?: string | undefined;
    scopes?: string[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class StoreSearchResult implements IStoreSearchResult {
    readonly stores?: Store[] | undefined;
    totalCount?: number;
    results?: Store[] | undefined;

    constructor(data?: IStoreSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stores"])) {
                (<any>this).stores = [] as any;
                for (let item of _data["stores"])
                    (<any>this).stores!.push(Store.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Store.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoreSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new StoreSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stores)) {
            data["stores"] = [];
            for (let item of this.stores)
                data["stores"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStoreSearchResult {
    stores?: Store[] | undefined;
    totalCount?: number;
    results?: Store[] | undefined;
}

export class SendDynamicNotificationRequest implements ISendDynamicNotificationRequest {
    storeId?: string | undefined;
    type?: string | undefined;
    fields?: { [key: string]: string; } | undefined;
    language?: string | undefined;

    constructor(data?: ISendDynamicNotificationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.type = _data["type"];
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key];
                }
            }
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): SendDynamicNotificationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendDynamicNotificationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["type"] = this.type;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key];
            }
        }
        data["language"] = this.language;
        return data; 
    }
}

export interface ISendDynamicNotificationRequest {
    storeId?: string | undefined;
    type?: string | undefined;
    fields?: { [key: string]: string; } | undefined;
    language?: string | undefined;
}

/** Represent result for checking of possibility login on behalf request */
export class LoginOnBehalfInfo implements ILoginOnBehalfInfo {
    userName?: string | undefined;
    canLoginOnBehalf?: boolean;

    constructor(data?: ILoginOnBehalfInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.canLoginOnBehalf = _data["canLoginOnBehalf"];
        }
    }

    static fromJS(data: any): LoginOnBehalfInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LoginOnBehalfInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["canLoginOnBehalf"] = this.canLoginOnBehalf;
        return data; 
    }
}

/** Represent result for checking of possibility login on behalf request */
export interface ILoginOnBehalfInfo {
    userName?: string | undefined;
    canLoginOnBehalf?: boolean;
}

export class SubscriptionSearchCriteria implements ISubscriptionSearchCriteria {
    /** Search within specified store */
    storeId?: string | undefined;
    /** Search by subscription number */
    number?: string | undefined;
    /** Search subscription for related order id */
    customerOrderId?: string | undefined;
    /** Search subscription in StartDate and EndDate range inclusive */
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    modifiedSinceDate?: Date | undefined;
    customerId?: string | undefined;
    /** Search with specified statuses */
    statuses?: string[] | undefined;
    /** Search by external subscription system id */
    outerId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISubscriptionSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.number = _data["number"];
            this.customerOrderId = _data["customerOrderId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.modifiedSinceDate = _data["modifiedSinceDate"] ? new Date(_data["modifiedSinceDate"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(item);
            }
            this.outerId = _data["outerId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SubscriptionSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["number"] = this.number;
        data["customerOrderId"] = this.customerOrderId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["modifiedSinceDate"] = this.modifiedSinceDate ? this.modifiedSinceDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item);
        }
        data["outerId"] = this.outerId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ISubscriptionSearchCriteria {
    /** Search within specified store */
    storeId?: string | undefined;
    /** Search by subscription number */
    number?: string | undefined;
    /** Search subscription for related order id */
    customerOrderId?: string | undefined;
    /** Search subscription in StartDate and EndDate range inclusive */
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    modifiedSinceDate?: Date | undefined;
    customerId?: string | undefined;
    /** Search with specified statuses */
    statuses?: string[] | undefined;
    /** Search by external subscription system id */
    outerId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export enum PaymentInterval {
    Days = "Days",
    Weeks = "Weeks",
    Months = "Months",
    Years = "Years",
}

export enum SubscriptionStatus {
    Active = "Active",
    Trialing = "Trialing",
    PastDue = "PastDue",
    Cancelled = "Cancelled",
    Unpaid = "Unpaid",
}

export class Subscription implements ISubscription {
    storeId?: string | undefined;
    customerId?: string | undefined;
    customerName?: string | undefined;
    /** Subscription actual balance */
    balance?: number;
    /** Subscription number */
    number?: string | undefined;
    interval?: PaymentInterval;
    /** - to set more customized intervals (every 5 month) */
    intervalCount?: number;
    /** subscription trial period in days */
    trialPeriodDays?: number;
    subscriptionStatus?: SubscriptionStatus;
    customerOrderPrototypeId?: string | undefined;
    customerOrderPrototype?: CustomerOrder;
    /** List of all orders ids created on the basis of the subscription */
    customerOrdersIds?: string[] | undefined;
    /** List of all orders  created on the basis of the subscription */
    customerOrders?: CustomerOrder[] | undefined;
    /** Date the most recent update to this subscription started. */
    startDate?: Date | undefined;
    /** The date the subscription ended */
    endDate?: Date | undefined;
    trialSart?: Date | undefined;
    trialEnd?: Date | undefined;
    currentPeriodStart?: Date | undefined;
    currentPeriodEnd?: Date | undefined;
    /** External Subscrption entity system Id */
    outerId?: string | undefined;
    /** The subscription comment */
    comment?: string | undefined;
    operationsLog?: OperationLog[] | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ISubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.balance = _data["balance"];
            this.number = _data["number"];
            this.interval = _data["interval"];
            this.intervalCount = _data["intervalCount"];
            this.trialPeriodDays = _data["trialPeriodDays"];
            this.subscriptionStatus = _data["subscriptionStatus"];
            this.customerOrderPrototypeId = _data["customerOrderPrototypeId"];
            this.customerOrderPrototype = _data["customerOrderPrototype"] ? CustomerOrder.fromJS(_data["customerOrderPrototype"]) : <any>undefined;
            if (Array.isArray(_data["customerOrdersIds"])) {
                this.customerOrdersIds = [] as any;
                for (let item of _data["customerOrdersIds"])
                    this.customerOrdersIds!.push(item);
            }
            if (Array.isArray(_data["customerOrders"])) {
                this.customerOrders = [] as any;
                for (let item of _data["customerOrders"])
                    this.customerOrders!.push(CustomerOrder.fromJS(item));
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.trialSart = _data["trialSart"] ? new Date(_data["trialSart"].toString()) : <any>undefined;
            this.trialEnd = _data["trialEnd"] ? new Date(_data["trialEnd"].toString()) : <any>undefined;
            this.currentPeriodStart = _data["currentPeriodStart"] ? new Date(_data["currentPeriodStart"].toString()) : <any>undefined;
            this.currentPeriodEnd = _data["currentPeriodEnd"] ? new Date(_data["currentPeriodEnd"].toString()) : <any>undefined;
            this.outerId = _data["outerId"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["operationsLog"])) {
                this.operationsLog = [] as any;
                for (let item of _data["operationsLog"])
                    this.operationsLog!.push(OperationLog.fromJS(item));
            }
            this.isCancelled = _data["isCancelled"];
            this.cancelledDate = _data["cancelledDate"] ? new Date(_data["cancelledDate"].toString()) : <any>undefined;
            this.cancelReason = _data["cancelReason"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Subscription {
        data = typeof data === 'object' ? data : {};
        let result = new Subscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["balance"] = this.balance;
        data["number"] = this.number;
        data["interval"] = this.interval;
        data["intervalCount"] = this.intervalCount;
        data["trialPeriodDays"] = this.trialPeriodDays;
        data["subscriptionStatus"] = this.subscriptionStatus;
        data["customerOrderPrototypeId"] = this.customerOrderPrototypeId;
        data["customerOrderPrototype"] = this.customerOrderPrototype ? this.customerOrderPrototype.toJSON() : <any>undefined;
        if (Array.isArray(this.customerOrdersIds)) {
            data["customerOrdersIds"] = [];
            for (let item of this.customerOrdersIds)
                data["customerOrdersIds"].push(item);
        }
        if (Array.isArray(this.customerOrders)) {
            data["customerOrders"] = [];
            for (let item of this.customerOrders)
                data["customerOrders"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["trialSart"] = this.trialSart ? this.trialSart.toISOString() : <any>undefined;
        data["trialEnd"] = this.trialEnd ? this.trialEnd.toISOString() : <any>undefined;
        data["currentPeriodStart"] = this.currentPeriodStart ? this.currentPeriodStart.toISOString() : <any>undefined;
        data["currentPeriodEnd"] = this.currentPeriodEnd ? this.currentPeriodEnd.toISOString() : <any>undefined;
        data["outerId"] = this.outerId;
        data["comment"] = this.comment;
        if (Array.isArray(this.operationsLog)) {
            data["operationsLog"] = [];
            for (let item of this.operationsLog)
                data["operationsLog"].push(item.toJSON());
        }
        data["isCancelled"] = this.isCancelled;
        data["cancelledDate"] = this.cancelledDate ? this.cancelledDate.toISOString() : <any>undefined;
        data["cancelReason"] = this.cancelReason;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscription {
    storeId?: string | undefined;
    customerId?: string | undefined;
    customerName?: string | undefined;
    /** Subscription actual balance */
    balance?: number;
    /** Subscription number */
    number?: string | undefined;
    interval?: PaymentInterval;
    /** - to set more customized intervals (every 5 month) */
    intervalCount?: number;
    /** subscription trial period in days */
    trialPeriodDays?: number;
    subscriptionStatus?: SubscriptionStatus;
    customerOrderPrototypeId?: string | undefined;
    customerOrderPrototype?: CustomerOrder;
    /** List of all orders ids created on the basis of the subscription */
    customerOrdersIds?: string[] | undefined;
    /** List of all orders  created on the basis of the subscription */
    customerOrders?: CustomerOrder[] | undefined;
    /** Date the most recent update to this subscription started. */
    startDate?: Date | undefined;
    /** The date the subscription ended */
    endDate?: Date | undefined;
    trialSart?: Date | undefined;
    trialEnd?: Date | undefined;
    currentPeriodStart?: Date | undefined;
    currentPeriodEnd?: Date | undefined;
    /** External Subscrption entity system Id */
    outerId?: string | undefined;
    /** The subscription comment */
    comment?: string | undefined;
    operationsLog?: OperationLog[] | undefined;
    isCancelled?: boolean;
    cancelledDate?: Date | undefined;
    cancelReason?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class SubscriptionSearchResult implements ISubscriptionSearchResult {
    readonly subscriptions?: Subscription[] | undefined;
    totalCount?: number;
    results?: Subscription[] | undefined;

    constructor(data?: ISubscriptionSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["subscriptions"])) {
                (<any>this).subscriptions = [] as any;
                for (let item of _data["subscriptions"])
                    (<any>this).subscriptions!.push(Subscription.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Subscription.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SubscriptionSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subscriptions)) {
            data["subscriptions"] = [];
            for (let item of this.subscriptions)
                data["subscriptions"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISubscriptionSearchResult {
    subscriptions?: Subscription[] | undefined;
    totalCount?: number;
    results?: Subscription[] | undefined;
}

export class SubscriptionCancelRequest implements ISubscriptionCancelRequest {
    subscriptionId?: string | undefined;
    cancelReason?: string | undefined;

    constructor(data?: ISubscriptionCancelRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.cancelReason = _data["cancelReason"];
        }
    }

    static fromJS(data: any): SubscriptionCancelRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionCancelRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["cancelReason"] = this.cancelReason;
        return data; 
    }
}

export interface ISubscriptionCancelRequest {
    subscriptionId?: string | undefined;
    cancelReason?: string | undefined;
}

export class PaymentPlan implements IPaymentPlan {
    interval?: PaymentInterval;
    /** - to set more customized intervals (every 5 month) */
    intervalCount?: number;
    /** subscription trial period in days */
    trialPeriodDays?: number;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPaymentPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.interval = _data["interval"];
            this.intervalCount = _data["intervalCount"];
            this.trialPeriodDays = _data["trialPeriodDays"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): PaymentPlan {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interval"] = this.interval;
        data["intervalCount"] = this.intervalCount;
        data["trialPeriodDays"] = this.trialPeriodDays;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data; 
    }
}

export interface IPaymentPlan {
    interval?: PaymentInterval;
    /** - to set more customized intervals (every 5 month) */
    intervalCount?: number;
    /** subscription trial period in days */
    trialPeriodDays?: number;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class TaxProviderSearchCriteria implements ITaxProviderSearchCriteria {
    storeId?: string | undefined;
    storeIds?: string[] | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ITaxProviderSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.withoutTransient = _data["withoutTransient"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): TaxProviderSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new TaxProviderSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["withoutTransient"] = this.withoutTransient;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface ITaxProviderSearchCriteria {
    storeId?: string | undefined;
    storeIds?: string[] | undefined;
    withoutTransient?: boolean;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class TaxProvider implements ITaxProvider {
    storeId?: string | undefined;
    code?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    readonly typeName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    id?: string | undefined;

    constructor(data?: ITaxProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.code = _data["code"];
            this.logoUrl = _data["logoUrl"];
            this.isActive = _data["isActive"];
            this.priority = _data["priority"];
            (<any>this).typeName = _data["typeName"];
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaxProvider {
        data = typeof data === 'object' ? data : {};
        let result = new TaxProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["code"] = this.code;
        data["logoUrl"] = this.logoUrl;
        data["isActive"] = this.isActive;
        data["priority"] = this.priority;
        data["typeName"] = this.typeName;
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface ITaxProvider {
    storeId?: string | undefined;
    code?: string | undefined;
    logoUrl?: string | undefined;
    isActive?: boolean;
    priority?: number;
    typeName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    id?: string | undefined;
}

export class TaxProviderSearchResult implements ITaxProviderSearchResult {
    totalCount?: number;
    results?: TaxProvider[] | undefined;

    constructor(data?: ITaxProviderSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(TaxProvider.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaxProviderSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new TaxProviderSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITaxProviderSearchResult {
    totalCount?: number;
    results?: TaxProvider[] | undefined;
}

export class TaxStore implements ITaxStore {
    name?: string | undefined;
    outerId?: string | undefined;
    timeZone?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    defaultLanguage?: string | undefined;
    defaultCurrency?: string | undefined;
    id?: string | undefined;

    constructor(data?: ITaxStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.outerId = _data["outerId"];
            this.timeZone = _data["timeZone"];
            this.country = _data["country"];
            this.region = _data["region"];
            this.defaultLanguage = _data["defaultLanguage"];
            this.defaultCurrency = _data["defaultCurrency"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaxStore {
        data = typeof data === 'object' ? data : {};
        let result = new TaxStore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["outerId"] = this.outerId;
        data["timeZone"] = this.timeZone;
        data["country"] = this.country;
        data["region"] = this.region;
        data["defaultLanguage"] = this.defaultLanguage;
        data["defaultCurrency"] = this.defaultCurrency;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITaxStore {
    name?: string | undefined;
    outerId?: string | undefined;
    timeZone?: string | undefined;
    country?: string | undefined;
    region?: string | undefined;
    defaultLanguage?: string | undefined;
    defaultCurrency?: string | undefined;
    id?: string | undefined;
}

export class TaxAddress implements ITaxAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: ITaxAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressType = _data["addressType"];
            this.key = _data["key"];
            this.name = _data["name"];
            this.organization = _data["organization"];
            this.countryCode = _data["countryCode"];
            this.countryName = _data["countryName"];
            this.city = _data["city"];
            this.postalCode = _data["postalCode"];
            this.zip = _data["zip"];
            this.line1 = _data["line1"];
            this.line2 = _data["line2"];
            this.regionId = _data["regionId"];
            this.regionName = _data["regionName"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): TaxAddress {
        data = typeof data === 'object' ? data : {};
        let result = new TaxAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressType"] = this.addressType;
        data["key"] = this.key;
        data["name"] = this.name;
        data["organization"] = this.organization;
        data["countryCode"] = this.countryCode;
        data["countryName"] = this.countryName;
        data["city"] = this.city;
        data["postalCode"] = this.postalCode;
        data["zip"] = this.zip;
        data["line1"] = this.line1;
        data["line2"] = this.line2;
        data["regionId"] = this.regionId;
        data["regionName"] = this.regionName;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        return data; 
    }
}

export interface ITaxAddress {
    addressType?: AddressType;
    key?: string | undefined;
    name?: string | undefined;
    organization?: string | undefined;
    countryCode?: string | undefined;
    countryName?: string | undefined;
    city?: string | undefined;
    postalCode?: string | undefined;
    zip?: string | undefined;
    line1?: string | undefined;
    line2?: string | undefined;
    regionId?: string | undefined;
    regionName?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class TaxCustomer implements ITaxCustomer {
    name?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    outerId?: string | undefined;
    addresses?: TaxAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    groups?: string[] | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    taxPayerId?: string | undefined;
    id?: string | undefined;

    constructor(data?: ITaxCustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(TaxAddress.fromJS(item));
            }
            if (Array.isArray(_data["phones"])) {
                this.phones = [] as any;
                for (let item of _data["phones"])
                    this.phones!.push(item);
            }
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
            if (Array.isArray(_data["groups"])) {
                this.groups = [] as any;
                for (let item of _data["groups"])
                    this.groups!.push(item);
            }
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.defaultLanguage = _data["defaultLanguage"];
            this.timeZone = _data["timeZone"];
            if (Array.isArray(_data["organizations"])) {
                this.organizations = [] as any;
                for (let item of _data["organizations"])
                    this.organizations!.push(item);
            }
            this.taxPayerId = _data["taxPayerId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaxCustomer {
        data = typeof data === 'object' ? data : {};
        let result = new TaxCustomer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        if (Array.isArray(this.phones)) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item);
        }
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (Array.isArray(this.groups)) {
            data["groups"] = [];
            for (let item of this.groups)
                data["groups"].push(item);
        }
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["defaultLanguage"] = this.defaultLanguage;
        data["timeZone"] = this.timeZone;
        if (Array.isArray(this.organizations)) {
            data["organizations"] = [];
            for (let item of this.organizations)
                data["organizations"].push(item);
        }
        data["taxPayerId"] = this.taxPayerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITaxCustomer {
    name?: string | undefined;
    firstName?: string | undefined;
    middleName?: string | undefined;
    lastName?: string | undefined;
    outerId?: string | undefined;
    addresses?: TaxAddress[] | undefined;
    phones?: string[] | undefined;
    emails?: string[] | undefined;
    groups?: string[] | undefined;
    birthDate?: Date | undefined;
    defaultLanguage?: string | undefined;
    timeZone?: string | undefined;
    organizations?: string[] | undefined;
    taxPayerId?: string | undefined;
    id?: string | undefined;
}

export class TaxLine implements ITaxLine {
    code?: string | undefined;
    name?: string | undefined;
    typeName?: string | undefined;
    amount?: number;
    quantity?: number;
    price?: number;
    taxType?: string | undefined;
    id?: string | undefined;

    constructor(data?: ITaxLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.name = _data["name"];
            this.typeName = _data["typeName"];
            this.amount = _data["amount"];
            this.quantity = _data["quantity"];
            this.price = _data["price"];
            this.taxType = _data["taxType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaxLine {
        data = typeof data === 'object' ? data : {};
        let result = new TaxLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["typeName"] = this.typeName;
        data["amount"] = this.amount;
        data["quantity"] = this.quantity;
        data["price"] = this.price;
        data["taxType"] = this.taxType;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITaxLine {
    code?: string | undefined;
    name?: string | undefined;
    typeName?: string | undefined;
    amount?: number;
    quantity?: number;
    price?: number;
    taxType?: string | undefined;
    id?: string | undefined;
}

export class TaxEvaluationContext implements ITaxEvaluationContext {
    storeId?: string | undefined;
    store?: TaxStore;
    code?: string | undefined;
    type?: string | undefined;
    customerId?: string | undefined;
    customer?: TaxCustomer;
    organizationId?: string | undefined;
    address?: TaxAddress;
    currency?: string | undefined;
    lines?: TaxLine[] | undefined;
    id?: string | undefined;

    constructor(data?: ITaxEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.store = _data["store"] ? TaxStore.fromJS(_data["store"]) : <any>undefined;
            this.code = _data["code"];
            this.type = _data["type"];
            this.customerId = _data["customerId"];
            this.customer = _data["customer"] ? TaxCustomer.fromJS(_data["customer"]) : <any>undefined;
            this.organizationId = _data["organizationId"];
            this.address = _data["address"] ? TaxAddress.fromJS(_data["address"]) : <any>undefined;
            this.currency = _data["currency"];
            if (Array.isArray(_data["lines"])) {
                this.lines = [] as any;
                for (let item of _data["lines"])
                    this.lines!.push(TaxLine.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TaxEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new TaxEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["type"] = this.type;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["organizationId"] = this.organizationId;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["currency"] = this.currency;
        if (Array.isArray(this.lines)) {
            data["lines"] = [];
            for (let item of this.lines)
                data["lines"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface ITaxEvaluationContext {
    storeId?: string | undefined;
    store?: TaxStore;
    code?: string | undefined;
    type?: string | undefined;
    customerId?: string | undefined;
    customer?: TaxCustomer;
    organizationId?: string | undefined;
    address?: TaxAddress;
    currency?: string | undefined;
    lines?: TaxLine[] | undefined;
    id?: string | undefined;
}

export class TaxRate implements ITaxRate {
    rate?: number;
    percentRate?: number;
    currency?: string | undefined;
    line?: TaxLine;
    taxProviderCode?: string | undefined;
    taxDetails?: TaxDetail[] | undefined;

    constructor(data?: ITaxRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rate = _data["rate"];
            this.percentRate = _data["percentRate"];
            this.currency = _data["currency"];
            this.line = _data["line"] ? TaxLine.fromJS(_data["line"]) : <any>undefined;
            this.taxProviderCode = _data["taxProviderCode"];
            if (Array.isArray(_data["taxDetails"])) {
                this.taxDetails = [] as any;
                for (let item of _data["taxDetails"])
                    this.taxDetails!.push(TaxDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaxRate {
        data = typeof data === 'object' ? data : {};
        let result = new TaxRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rate"] = this.rate;
        data["percentRate"] = this.percentRate;
        data["currency"] = this.currency;
        data["line"] = this.line ? this.line.toJSON() : <any>undefined;
        data["taxProviderCode"] = this.taxProviderCode;
        if (Array.isArray(this.taxDetails)) {
            data["taxDetails"] = [];
            for (let item of this.taxDetails)
                data["taxDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITaxRate {
    rate?: number;
    percentRate?: number;
    currency?: string | undefined;
    line?: TaxLine;
    taxProviderCode?: string | undefined;
    taxDetails?: TaxDetail[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}