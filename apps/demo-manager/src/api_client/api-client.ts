/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AuthApiBase {
    authToken = "";
    protected constructor() {}
  
    setAuthToken(token: string) {
      this.authToken = token;
    }
  
    protected transformOptions(options: any): Promise<any> {
      options.headers['authorization'] =  `Bearer ${this.authToken}`;
      return Promise.resolve(options);
    }
  }
  
  export class VcmpOperatorCatalogClient extends AuthApiBase {
      private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
      private baseUrl: string;
      protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
  
      constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
          super();
          this.http = http ? http : <any>window;
          this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
      }
  
      /**
       * @return Success
       */
      approveRequest(id: string | null): Promise<void> {
          let url_ = this.baseUrl + "/api/vcmp/operator/requests/{id}/aprove";
          if (id === undefined || id === null)
              throw new Error("The parameter 'id' must be defined.");
          url_ = url_.replace("{id}", encodeURIComponent("" + id));
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "POST",
              headers: {
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processApproveRequest(_response);
          });
      }
  
      protected processApproveRequest(response: Response): Promise<void> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              return;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<void>(<any>null);
      }
  }
  
  export class VcmpSellerCatalogClient extends AuthApiBase {
      private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
      private baseUrl: string;
      protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
  
      constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
          super();
          this.http = http ? http : <any>window;
          this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      searchCategories(body: SearchCategoriesQuery | undefined): Promise<CategorySearchResult> {
          let url_ = this.baseUrl + "/api/vcmp/seller/categories/search";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processSearchCategories(_response);
          });
      }
  
      protected processSearchCategories(response: Response): Promise<CategorySearchResult> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = CategorySearchResult.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<CategorySearchResult>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      searchProducts(body: SearchProductsQuery | undefined): Promise<SearchProductsResult> {
          let url_ = this.baseUrl + "/api/vcmp/seller/products/search";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processSearchProducts(_response);
          });
      }
  
      protected processSearchProducts(response: Response): Promise<SearchProductsResult> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SearchProductsResult.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SearchProductsResult>(<any>null);
      }
  
      /**
       * @return Success
       */
      getProductById(productId: string | null): Promise<SellerProduct> {
          let url_ = this.baseUrl + "/api/vcmp/seller/products/{productId}";
          if (productId === undefined || productId === null)
              throw new Error("The parameter 'productId' must be defined.");
          url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "POST",
              headers: {
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processGetProductById(_response);
          });
      }
  
      protected processGetProductById(response: Response): Promise<SellerProduct> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SellerProduct.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SellerProduct>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      createNewProduct(body: CreateNewProductCommand | undefined): Promise<SellerProduct> {
          let url_ = this.baseUrl + "/api/vcmp/seller/products";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processCreateNewProduct(_response);
          });
      }
  
      protected processCreateNewProduct(response: Response): Promise<SellerProduct> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SellerProduct.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SellerProduct>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      updateProductDetails(body: UpdateProductDetailsCommand | undefined): Promise<SellerProduct> {
          let url_ = this.baseUrl + "/api/vcmp/seller/products";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "PUT",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processUpdateProductDetails(_response);
          });
      }
  
      protected processUpdateProductDetails(response: Response): Promise<SellerProduct> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SellerProduct.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SellerProduct>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      createNewPublicationRequest(body: CreateNewPublicationRequestCommand | undefined): Promise<ProductPublicationRequest> {
          let url_ = this.baseUrl + "/api/vcmp/seller/products/requests/new";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processCreateNewPublicationRequest(_response);
          });
      }
  
      protected processCreateNewPublicationRequest(response: Response): Promise<ProductPublicationRequest> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = ProductPublicationRequest.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<ProductPublicationRequest>(<any>null);
      }
  
      /**
       * @return Success
       */
      revertStagedChanges(productId: string | null): Promise<ProductPublicationRequest> {
          let url_ = this.baseUrl + "/api/vcmp/seller/product/{productId}/revert";
          if (productId === undefined || productId === null)
              throw new Error("The parameter 'productId' must be defined.");
          url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "POST",
              headers: {
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processRevertStagedChanges(_response);
          });
      }
  
      protected processRevertStagedChanges(response: Response): Promise<ProductPublicationRequest> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = ProductPublicationRequest.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<ProductPublicationRequest>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      searchOffres(body: SearchOffersQuery | undefined): Promise<SearchOffersResult> {
          let url_ = this.baseUrl + "/api/vcmp/seller/offers/search";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processSearchOffres(_response);
          });
      }
  
      protected processSearchOffres(response: Response): Promise<SearchOffersResult> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SearchOffersResult.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SearchOffersResult>(<any>null);
      }
  
      /**
       * @return Success
       */
      getOfferById(offerId: string | null): Promise<Offer> {
          let url_ = this.baseUrl + "/api/vcmp/seller/offers/{offerId}";
          if (offerId === undefined || offerId === null)
              throw new Error("The parameter 'offerId' must be defined.");
          url_ = url_.replace("{offerId}", encodeURIComponent("" + offerId));
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "POST",
              headers: {
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processGetOfferById(_response);
          });
      }
  
      protected processGetOfferById(response: Response): Promise<Offer> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = Offer.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<Offer>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      searchOfferProducts(body: SearchProductsForNewOfferQuery | undefined): Promise<SearchOfferProductsResult> {
          let url_ = this.baseUrl + "/api/vcmp/seller/offers/products/search";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processSearchOfferProducts(_response);
          });
      }
  
      protected processSearchOfferProducts(response: Response): Promise<SearchOfferProductsResult> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SearchOfferProductsResult.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SearchOfferProductsResult>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      createNewOffer(body: CreateNewOfferCommand | undefined): Promise<Offer> {
          let url_ = this.baseUrl + "/api/vcmp/seller/offers/new";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processCreateNewOffer(_response);
          });
      }
  
      protected processCreateNewOffer(response: Response): Promise<Offer> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = Offer.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<Offer>(<any>null);
      }
  
      /**
       * @return Success
       */
      changeProductStatus(productId: string | null, status: string | null): Promise<void> {
          let url_ = this.baseUrl + "/api/vcmp/seller/product/{productId}/status/new/{status}";
          if (productId === undefined || productId === null)
              throw new Error("The parameter 'productId' must be defined.");
          url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
          if (status === undefined || status === null)
              throw new Error("The parameter 'status' must be defined.");
          url_ = url_.replace("{status}", encodeURIComponent("" + status));
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "POST",
              headers: {
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processChangeProductStatus(_response);
          });
      }
  
      protected processChangeProductStatus(response: Response): Promise<void> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              return;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<void>(<any>null);
      }
  }
  
  export enum SortDirection {
      Ascending = "Ascending",
      Descending = "Descending",
  }
  
  export class SortInfo implements ISortInfo {
      sortColumn?: string | undefined;
      sortDirection?: SortDirection;
  
      constructor(data?: ISortInfo) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sortColumn = _data["sortColumn"];
              this.sortDirection = _data["sortDirection"];
          }
      }
  
      static fromJS(data: any): SortInfo {
          data = typeof data === 'object' ? data : {};
          let result = new SortInfo();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sortColumn"] = this.sortColumn;
          data["sortDirection"] = this.sortDirection;
          return data; 
      }
  }
  
  export interface ISortInfo {
      sortColumn?: string | undefined;
      sortDirection?: SortDirection;
  }
  
  export class SearchCategoriesQuery implements ISearchCategoriesQuery {
      storeId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      readonly sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  
      constructor(data?: ISearchCategoriesQuery) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.storeId = _data["storeId"];
              this.responseGroup = _data["responseGroup"];
              this.objectType = _data["objectType"];
              if (Array.isArray(_data["objectTypes"])) {
                  this.objectTypes = [] as any;
                  for (let item of _data["objectTypes"])
                      this.objectTypes!.push(item);
              }
              if (Array.isArray(_data["objectIds"])) {
                  this.objectIds = [] as any;
                  for (let item of _data["objectIds"])
                      this.objectIds!.push(item);
              }
              this.keyword = _data["keyword"];
              this.searchPhrase = _data["searchPhrase"];
              this.languageCode = _data["languageCode"];
              this.sort = _data["sort"];
              if (Array.isArray(_data["sortInfos"])) {
                  (<any>this).sortInfos = [] as any;
                  for (let item of _data["sortInfos"])
                      (<any>this).sortInfos!.push(SortInfo.fromJS(item));
              }
              this.skip = _data["skip"];
              this.take = _data["take"];
          }
      }
  
      static fromJS(data: any): SearchCategoriesQuery {
          data = typeof data === 'object' ? data : {};
          let result = new SearchCategoriesQuery();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["storeId"] = this.storeId;
          data["responseGroup"] = this.responseGroup;
          data["objectType"] = this.objectType;
          if (Array.isArray(this.objectTypes)) {
              data["objectTypes"] = [];
              for (let item of this.objectTypes)
                  data["objectTypes"].push(item);
          }
          if (Array.isArray(this.objectIds)) {
              data["objectIds"] = [];
              for (let item of this.objectIds)
                  data["objectIds"].push(item);
          }
          data["keyword"] = this.keyword;
          data["searchPhrase"] = this.searchPhrase;
          data["languageCode"] = this.languageCode;
          data["sort"] = this.sort;
          if (Array.isArray(this.sortInfos)) {
              data["sortInfos"] = [];
              for (let item of this.sortInfos)
                  data["sortInfos"].push(item.toJSON());
          }
          data["skip"] = this.skip;
          data["take"] = this.take;
          return data; 
      }
  }
  
  export interface ISearchCategoriesQuery {
      storeId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  }
  
  export enum PropertyValueType {
      ShortText = "ShortText",
      LongText = "LongText",
      Number = "Number",
      DateTime = "DateTime",
      Boolean = "Boolean",
      Integer = "Integer",
      GeoPoint = "GeoPoint",
  }
  
  export enum PropertyType {
      Product = "Product",
      Variation = "Variation",
      Category = "Category",
      Catalog = "Catalog",
  }
  
  export class PropertyValue implements IPropertyValue {
      propertyName?: string | undefined;
      propertyId?: string | undefined;
      languageCode?: string | undefined;
      alias?: string | undefined;
      valueType?: PropertyValueType;
      valueId?: string | undefined;
      value?: any | undefined;
      readonly propertyMultivalue?: boolean;
      outerId?: string | undefined;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IPropertyValue) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.propertyName = _data["propertyName"];
              this.propertyId = _data["propertyId"];
              this.languageCode = _data["languageCode"];
              this.alias = _data["alias"];
              this.valueType = _data["valueType"];
              this.valueId = _data["valueId"];
              this.value = _data["value"];
              (<any>this).propertyMultivalue = _data["propertyMultivalue"];
              this.outerId = _data["outerId"];
              this.isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): PropertyValue {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyValue();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["propertyName"] = this.propertyName;
          data["propertyId"] = this.propertyId;
          data["languageCode"] = this.languageCode;
          data["alias"] = this.alias;
          data["valueType"] = this.valueType;
          data["valueId"] = this.valueId;
          data["value"] = this.value;
          data["propertyMultivalue"] = this.propertyMultivalue;
          data["outerId"] = this.outerId;
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IPropertyValue {
      propertyName?: string | undefined;
      propertyId?: string | undefined;
      languageCode?: string | undefined;
      alias?: string | undefined;
      valueType?: PropertyValueType;
      valueId?: string | undefined;
      value?: any | undefined;
      propertyMultivalue?: boolean;
      outerId?: string | undefined;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class PropertyAttribute implements IPropertyAttribute {
      propertyId?: string | undefined;
      value?: string | undefined;
      name?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IPropertyAttribute) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.propertyId = _data["propertyId"];
              this.value = _data["value"];
              this.name = _data["name"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): PropertyAttribute {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyAttribute();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["propertyId"] = this.propertyId;
          data["value"] = this.value;
          data["name"] = this.name;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IPropertyAttribute {
      propertyId?: string | undefined;
      value?: string | undefined;
      name?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class PropertyDisplayName implements IPropertyDisplayName {
      name?: string | undefined;
      languageCode?: string | undefined;
  
      constructor(data?: IPropertyDisplayName) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.name = _data["name"];
              this.languageCode = _data["languageCode"];
          }
      }
  
      static fromJS(data: any): PropertyDisplayName {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyDisplayName();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["name"] = this.name;
          data["languageCode"] = this.languageCode;
          return data; 
      }
  }
  
  export interface IPropertyDisplayName {
      name?: string | undefined;
      languageCode?: string | undefined;
  }
  
  /** Represents property validation rules definition */
  export class PropertyValidationRule implements IPropertyValidationRule {
      /** Uniquie value flag constrain */
      isUnique?: boolean;
      /** Down chars count border or null if no defined */
      charCountMin?: number | undefined;
      /** Upper chars count border or null if no defined */
      charCountMax?: number | undefined;
      /** Custom regular expression */
      regExp?: string | undefined;
      propertyId?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IPropertyValidationRule) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.isUnique = _data["isUnique"];
              this.charCountMin = _data["charCountMin"];
              this.charCountMax = _data["charCountMax"];
              this.regExp = _data["regExp"];
              this.propertyId = _data["propertyId"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): PropertyValidationRule {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyValidationRule();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["isUnique"] = this.isUnique;
          data["charCountMin"] = this.charCountMin;
          data["charCountMax"] = this.charCountMax;
          data["regExp"] = this.regExp;
          data["propertyId"] = this.propertyId;
          data["id"] = this.id;
          return data; 
      }
  }
  
  /** Represents property validation rules definition */
  export interface IPropertyValidationRule {
      /** Uniquie value flag constrain */
      isUnique?: boolean;
      /** Down chars count border or null if no defined */
      charCountMin?: number | undefined;
      /** Upper chars count border or null if no defined */
      charCountMax?: number | undefined;
      /** Custom regular expression */
      regExp?: string | undefined;
      propertyId?: string | undefined;
      id?: string | undefined;
  }
  
  export class Property implements IProperty {
      /** Gets or sets a value indicating whether user can change property value. */
      isReadOnly?: boolean;
      /** Gets or sets a value indicating whether user can change property metadata or remove this property. */
      readonly isManageable?: boolean;
      /** Gets or sets a value indicating whether this instance is new. A new property should be created on server site instead of trying to update it. */
      isNew?: boolean;
      /** Gets or sets the catalog id that this product belongs to. */
      catalogId?: string | undefined;
      /** Gets or sets the category id that this product belongs to. */
      categoryId?: string | undefined;
      name?: string | undefined;
      required?: boolean;
      dictionary?: boolean;
      multivalue?: boolean;
      multilanguage?: boolean;
      /** Gets or sets a value indicating whether this VirtoCommerce.CatalogModule.Core.Model.Property is hidden. */
      hidden?: boolean;
      valueType?: PropertyValueType;
      type?: PropertyType;
      outerId?: string | undefined;
      ownerName?: string | undefined;
      values?: PropertyValue[] | undefined;
      attributes?: PropertyAttribute[] | undefined;
      displayNames?: PropertyDisplayName[] | undefined;
      validationRules?: PropertyValidationRule[] | undefined;
      validationRule?: PropertyValidationRule;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IProperty) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.isReadOnly = _data["isReadOnly"];
              (<any>this).isManageable = _data["isManageable"];
              this.isNew = _data["isNew"];
              this.catalogId = _data["catalogId"];
              this.categoryId = _data["categoryId"];
              this.name = _data["name"];
              this.required = _data["required"];
              this.dictionary = _data["dictionary"];
              this.multivalue = _data["multivalue"];
              this.multilanguage = _data["multilanguage"];
              this.hidden = _data["hidden"];
              this.valueType = _data["valueType"];
              this.type = _data["type"];
              this.outerId = _data["outerId"];
              this.ownerName = _data["ownerName"];
              if (Array.isArray(_data["values"])) {
                  this.values = [] as any;
                  for (let item of _data["values"])
                      this.values!.push(PropertyValue.fromJS(item));
              }
              if (Array.isArray(_data["attributes"])) {
                  this.attributes = [] as any;
                  for (let item of _data["attributes"])
                      this.attributes!.push(PropertyAttribute.fromJS(item));
              }
              if (Array.isArray(_data["displayNames"])) {
                  this.displayNames = [] as any;
                  for (let item of _data["displayNames"])
                      this.displayNames!.push(PropertyDisplayName.fromJS(item));
              }
              if (Array.isArray(_data["validationRules"])) {
                  this.validationRules = [] as any;
                  for (let item of _data["validationRules"])
                      this.validationRules!.push(PropertyValidationRule.fromJS(item));
              }
              this.validationRule = _data["validationRule"] ? PropertyValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
              this.isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Property {
          data = typeof data === 'object' ? data : {};
          let result = new Property();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["isReadOnly"] = this.isReadOnly;
          data["isManageable"] = this.isManageable;
          data["isNew"] = this.isNew;
          data["catalogId"] = this.catalogId;
          data["categoryId"] = this.categoryId;
          data["name"] = this.name;
          data["required"] = this.required;
          data["dictionary"] = this.dictionary;
          data["multivalue"] = this.multivalue;
          data["multilanguage"] = this.multilanguage;
          data["hidden"] = this.hidden;
          data["valueType"] = this.valueType;
          data["type"] = this.type;
          data["outerId"] = this.outerId;
          data["ownerName"] = this.ownerName;
          if (Array.isArray(this.values)) {
              data["values"] = [];
              for (let item of this.values)
                  data["values"].push(item.toJSON());
          }
          if (Array.isArray(this.attributes)) {
              data["attributes"] = [];
              for (let item of this.attributes)
                  data["attributes"].push(item.toJSON());
          }
          if (Array.isArray(this.displayNames)) {
              data["displayNames"] = [];
              for (let item of this.displayNames)
                  data["displayNames"].push(item.toJSON());
          }
          if (Array.isArray(this.validationRules)) {
              data["validationRules"] = [];
              for (let item of this.validationRules)
                  data["validationRules"].push(item.toJSON());
          }
          data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IProperty {
      /** Gets or sets a value indicating whether user can change property value. */
      isReadOnly?: boolean;
      /** Gets or sets a value indicating whether user can change property metadata or remove this property. */
      isManageable?: boolean;
      /** Gets or sets a value indicating whether this instance is new. A new property should be created on server site instead of trying to update it. */
      isNew?: boolean;
      /** Gets or sets the catalog id that this product belongs to. */
      catalogId?: string | undefined;
      /** Gets or sets the category id that this product belongs to. */
      categoryId?: string | undefined;
      name?: string | undefined;
      required?: boolean;
      dictionary?: boolean;
      multivalue?: boolean;
      multilanguage?: boolean;
      /** Gets or sets a value indicating whether this VirtoCommerce.CatalogModule.Core.Model.Property is hidden. */
      hidden?: boolean;
      valueType?: PropertyValueType;
      type?: PropertyType;
      outerId?: string | undefined;
      ownerName?: string | undefined;
      values?: PropertyValue[] | undefined;
      attributes?: PropertyAttribute[] | undefined;
      displayNames?: PropertyDisplayName[] | undefined;
      validationRules?: PropertyValidationRule[] | undefined;
      validationRule?: PropertyValidationRule;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class ExcludedProperty implements IExcludedProperty {
      name?: string | undefined;
      isInherited?: boolean;
  
      constructor(data?: IExcludedProperty) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.name = _data["name"];
              this.isInherited = _data["isInherited"];
          }
      }
  
      static fromJS(data: any): ExcludedProperty {
          data = typeof data === 'object' ? data : {};
          let result = new ExcludedProperty();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["name"] = this.name;
          data["isInherited"] = this.isInherited;
          return data; 
      }
  }
  
  export interface IExcludedProperty {
      name?: string | undefined;
      isInherited?: boolean;
  }
  
  export class CategoryLink implements ICategoryLink {
      /** Entry identifier which this link belongs to */
      readonly entryId?: string | undefined;
      listEntryId?: string | undefined;
      /** Gets or sets the type of the list entry. E.g. "product", "category" */
      listEntryType?: string | undefined;
      /** Product order position in virtual catalog */
      priority?: number;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      category?: Category;
  
      constructor(data?: ICategoryLink) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              (<any>this).entryId = _data["entryId"];
              this.listEntryId = _data["listEntryId"];
              this.listEntryType = _data["listEntryType"];
              this.priority = _data["priority"];
              this.catalogId = _data["catalogId"];
              this.categoryId = _data["categoryId"];
              this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
          }
      }
  
      static fromJS(data: any): CategoryLink {
          data = typeof data === 'object' ? data : {};
          let result = new CategoryLink();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["entryId"] = this.entryId;
          data["listEntryId"] = this.listEntryId;
          data["listEntryType"] = this.listEntryType;
          data["priority"] = this.priority;
          data["catalogId"] = this.catalogId;
          data["categoryId"] = this.categoryId;
          data["category"] = this.category ? this.category.toJSON() : <any>undefined;
          return data; 
      }
  }
  
  export interface ICategoryLink {
      /** Entry identifier which this link belongs to */
      entryId?: string | undefined;
      listEntryId?: string | undefined;
      /** Gets or sets the type of the list entry. E.g. "product", "category" */
      listEntryType?: string | undefined;
      /** Product order position in virtual catalog */
      priority?: number;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      category?: Category;
  }
  
  export class SeoInfo implements ISeoInfo {
      name?: string | undefined;
      /** Slug */
      semanticUrl?: string | undefined;
      /** head title tag content */
      pageTitle?: string | undefined;
      /** <meta name="description" /> */
      metaDescription?: string | undefined;
      imageAltDescription?: string | undefined;
      /** <meta name="keywords" /> */
      metaKeywords?: string | undefined;
      /** Tenant StoreId which SEO defined */
      storeId?: string | undefined;
      /** SEO related object id */
      objectId?: string | undefined;
      /** SEO related object type name */
      objectType?: string | undefined;
      /** Active/Inactive */
      isActive?: boolean;
      languageCode?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: ISeoInfo) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.name = _data["name"];
              this.semanticUrl = _data["semanticUrl"];
              this.pageTitle = _data["pageTitle"];
              this.metaDescription = _data["metaDescription"];
              this.imageAltDescription = _data["imageAltDescription"];
              this.metaKeywords = _data["metaKeywords"];
              this.storeId = _data["storeId"];
              this.objectId = _data["objectId"];
              this.objectType = _data["objectType"];
              this.isActive = _data["isActive"];
              this.languageCode = _data["languageCode"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): SeoInfo {
          data = typeof data === 'object' ? data : {};
          let result = new SeoInfo();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["name"] = this.name;
          data["semanticUrl"] = this.semanticUrl;
          data["pageTitle"] = this.pageTitle;
          data["metaDescription"] = this.metaDescription;
          data["imageAltDescription"] = this.imageAltDescription;
          data["metaKeywords"] = this.metaKeywords;
          data["storeId"] = this.storeId;
          data["objectId"] = this.objectId;
          data["objectType"] = this.objectType;
          data["isActive"] = this.isActive;
          data["languageCode"] = this.languageCode;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface ISeoInfo {
      name?: string | undefined;
      /** Slug */
      semanticUrl?: string | undefined;
      /** head title tag content */
      pageTitle?: string | undefined;
      /** <meta name="description" /> */
      metaDescription?: string | undefined;
      imageAltDescription?: string | undefined;
      /** <meta name="keywords" /> */
      metaKeywords?: string | undefined;
      /** Tenant StoreId which SEO defined */
      storeId?: string | undefined;
      /** SEO related object id */
      objectId?: string | undefined;
      /** SEO related object type name */
      objectType?: string | undefined;
      /** Active/Inactive */
      isActive?: boolean;
      languageCode?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class Image implements IImage {
      binaryData?: string | undefined;
      altText?: string | undefined;
      relativeUrl?: string | undefined;
      url?: string | undefined;
      description?: string | undefined;
      sortOrder?: number;
      /** Gets or sets the asset type identifier. */
      typeId?: string | undefined;
      /** Gets or sets the asset group name. */
      group?: string | undefined;
      /** Gets or sets the asset name. */
      name?: string | undefined;
      outerId?: string | undefined;
      /** Gets or sets the asset language. */
      languageCode?: string | undefined;
      /** System flag used to mark that object was inherited from other */
      readonly isInherited?: boolean;
      readonly seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IImage) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.binaryData = _data["binaryData"];
              this.altText = _data["altText"];
              this.relativeUrl = _data["relativeUrl"];
              this.url = _data["url"];
              this.description = _data["description"];
              this.sortOrder = _data["sortOrder"];
              this.typeId = _data["typeId"];
              this.group = _data["group"];
              this.name = _data["name"];
              this.outerId = _data["outerId"];
              this.languageCode = _data["languageCode"];
              (<any>this).isInherited = _data["isInherited"];
              (<any>this).seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Image {
          data = typeof data === 'object' ? data : {};
          let result = new Image();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["binaryData"] = this.binaryData;
          data["altText"] = this.altText;
          data["relativeUrl"] = this.relativeUrl;
          data["url"] = this.url;
          data["description"] = this.description;
          data["sortOrder"] = this.sortOrder;
          data["typeId"] = this.typeId;
          data["group"] = this.group;
          data["name"] = this.name;
          data["outerId"] = this.outerId;
          data["languageCode"] = this.languageCode;
          data["isInherited"] = this.isInherited;
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IImage {
      binaryData?: string | undefined;
      altText?: string | undefined;
      relativeUrl?: string | undefined;
      url?: string | undefined;
      description?: string | undefined;
      sortOrder?: number;
      /** Gets or sets the asset type identifier. */
      typeId?: string | undefined;
      /** Gets or sets the asset group name. */
      group?: string | undefined;
      /** Gets or sets the asset name. */
      name?: string | undefined;
      outerId?: string | undefined;
      /** Gets or sets the asset language. */
      languageCode?: string | undefined;
      /** System flag used to mark that object was inherited from other */
      isInherited?: boolean;
      seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  /** Represents one outline element: catalog, category or product. */
  export class OutlineItem implements IOutlineItem {
      /** Object id */
      id?: string | undefined;
      /** Object type */
      seoObjectType?: string | undefined;
      /** All SEO records for the object */
      seoInfos?: SeoInfo[] | undefined;
      /** The name of current item */
      name?: string | undefined;
      /** True when this object is linked to the virtual parent. */
      hasVirtualParent?: boolean;
  
      constructor(data?: IOutlineItem) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.id = _data["id"];
              this.seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              this.name = _data["name"];
              this.hasVirtualParent = _data["hasVirtualParent"];
          }
      }
  
      static fromJS(data: any): OutlineItem {
          data = typeof data === 'object' ? data : {};
          let result = new OutlineItem();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["id"] = this.id;
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          data["name"] = this.name;
          data["hasVirtualParent"] = this.hasVirtualParent;
          return data; 
      }
  }
  
  /** Represents one outline element: catalog, category or product. */
  export interface IOutlineItem {
      /** Object id */
      id?: string | undefined;
      /** Object type */
      seoObjectType?: string | undefined;
      /** All SEO records for the object */
      seoInfos?: SeoInfo[] | undefined;
      /** The name of current item */
      name?: string | undefined;
      /** True when this object is linked to the virtual parent. */
      hasVirtualParent?: boolean;
  }
  
  /** Represents the path from the catalog to one of the child objects (product or category): catalog/parent-category1/.../parent-categoryN/object */
  export class Outline implements IOutline {
      /** Outline parts */
      items?: OutlineItem[] | undefined;
  
      constructor(data?: IOutline) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              if (Array.isArray(_data["items"])) {
                  this.items = [] as any;
                  for (let item of _data["items"])
                      this.items!.push(OutlineItem.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): Outline {
          data = typeof data === 'object' ? data : {};
          let result = new Outline();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          if (Array.isArray(this.items)) {
              data["items"] = [];
              for (let item of this.items)
                  data["items"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  /** Represents the path from the catalog to one of the child objects (product or category): catalog/parent-category1/.../parent-categoryN/object */
  export interface IOutline {
      /** Outline parts */
      items?: OutlineItem[] | undefined;
  }
  
  export class Category implements ICategory {
      catalogId?: string | undefined;
      parentId?: string | undefined;
      code?: string | undefined;
      name?: string | undefined;
      /** Category outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      readonly outline?: string | undefined;
      /** Category path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      path?: string | undefined;
      isVirtual?: boolean;
      level?: number;
      packageType?: string | undefined;
      priority?: number;
      isActive?: boolean | undefined;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      links?: CategoryLink[] | undefined;
      taxType?: string | undefined;
      readonly seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      /** Gets the default image */
      readonly imgSrc?: string | undefined;
      images?: Image[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      readonly isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: ICategory) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.catalogId = _data["catalogId"];
              this.parentId = _data["parentId"];
              this.code = _data["code"];
              this.name = _data["name"];
              (<any>this).outline = _data["outline"];
              this.path = _data["path"];
              this.isVirtual = _data["isVirtual"];
              this.level = _data["level"];
              this.packageType = _data["packageType"];
              this.priority = _data["priority"];
              this.isActive = _data["isActive"];
              this.outerId = _data["outerId"];
              if (Array.isArray(_data["properties"])) {
                  this.properties = [] as any;
                  for (let item of _data["properties"])
                      this.properties!.push(Property.fromJS(item));
              }
              if (Array.isArray(_data["excludedProperties"])) {
                  this.excludedProperties = [] as any;
                  for (let item of _data["excludedProperties"])
                      this.excludedProperties!.push(ExcludedProperty.fromJS(item));
              }
              if (Array.isArray(_data["links"])) {
                  this.links = [] as any;
                  for (let item of _data["links"])
                      this.links!.push(CategoryLink.fromJS(item));
              }
              this.taxType = _data["taxType"];
              (<any>this).seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              (<any>this).imgSrc = _data["imgSrc"];
              if (Array.isArray(_data["images"])) {
                  this.images = [] as any;
                  for (let item of _data["images"])
                      this.images!.push(Image.fromJS(item));
              }
              if (Array.isArray(_data["outlines"])) {
                  this.outlines = [] as any;
                  for (let item of _data["outlines"])
                      this.outlines!.push(Outline.fromJS(item));
              }
              (<any>this).isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Category {
          data = typeof data === 'object' ? data : {};
          let result = new Category();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["catalogId"] = this.catalogId;
          data["parentId"] = this.parentId;
          data["code"] = this.code;
          data["name"] = this.name;
          data["outline"] = this.outline;
          data["path"] = this.path;
          data["isVirtual"] = this.isVirtual;
          data["level"] = this.level;
          data["packageType"] = this.packageType;
          data["priority"] = this.priority;
          data["isActive"] = this.isActive;
          data["outerId"] = this.outerId;
          if (Array.isArray(this.properties)) {
              data["properties"] = [];
              for (let item of this.properties)
                  data["properties"].push(item.toJSON());
          }
          if (Array.isArray(this.excludedProperties)) {
              data["excludedProperties"] = [];
              for (let item of this.excludedProperties)
                  data["excludedProperties"].push(item.toJSON());
          }
          if (Array.isArray(this.links)) {
              data["links"] = [];
              for (let item of this.links)
                  data["links"].push(item.toJSON());
          }
          data["taxType"] = this.taxType;
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          data["imgSrc"] = this.imgSrc;
          if (Array.isArray(this.images)) {
              data["images"] = [];
              for (let item of this.images)
                  data["images"].push(item.toJSON());
          }
          if (Array.isArray(this.outlines)) {
              data["outlines"] = [];
              for (let item of this.outlines)
                  data["outlines"].push(item.toJSON());
          }
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface ICategory {
      catalogId?: string | undefined;
      parentId?: string | undefined;
      code?: string | undefined;
      name?: string | undefined;
      /** Category outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      outline?: string | undefined;
      /** Category path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      path?: string | undefined;
      isVirtual?: boolean;
      level?: number;
      packageType?: string | undefined;
      priority?: number;
      isActive?: boolean | undefined;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      links?: CategoryLink[] | undefined;
      taxType?: string | undefined;
      seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      /** Gets the default image */
      imgSrc?: string | undefined;
      images?: Image[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class CategorySearchResult implements ICategorySearchResult {
      totalCount?: number;
      results?: Category[] | undefined;
  
      constructor(data?: ICategorySearchResult) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.totalCount = _data["totalCount"];
              if (Array.isArray(_data["results"])) {
                  this.results = [] as any;
                  for (let item of _data["results"])
                      this.results!.push(Category.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): CategorySearchResult {
          data = typeof data === 'object' ? data : {};
          let result = new CategorySearchResult();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["totalCount"] = this.totalCount;
          if (Array.isArray(this.results)) {
              data["results"] = [];
              for (let item of this.results)
                  data["results"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface ICategorySearchResult {
      totalCount?: number;
      results?: Category[] | undefined;
  }
  
  export class SearchProductsQuery implements ISearchProductsQuery {
      categoryId?: string | undefined;
      storesIds?: string[] | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      readonly sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  
      constructor(data?: ISearchProductsQuery) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.categoryId = _data["categoryId"];
              if (Array.isArray(_data["storesIds"])) {
                  this.storesIds = [] as any;
                  for (let item of _data["storesIds"])
                      this.storesIds!.push(item);
              }
              this.responseGroup = _data["responseGroup"];
              this.objectType = _data["objectType"];
              if (Array.isArray(_data["objectTypes"])) {
                  this.objectTypes = [] as any;
                  for (let item of _data["objectTypes"])
                      this.objectTypes!.push(item);
              }
              if (Array.isArray(_data["objectIds"])) {
                  this.objectIds = [] as any;
                  for (let item of _data["objectIds"])
                      this.objectIds!.push(item);
              }
              this.keyword = _data["keyword"];
              this.searchPhrase = _data["searchPhrase"];
              this.languageCode = _data["languageCode"];
              this.sort = _data["sort"];
              if (Array.isArray(_data["sortInfos"])) {
                  (<any>this).sortInfos = [] as any;
                  for (let item of _data["sortInfos"])
                      (<any>this).sortInfos!.push(SortInfo.fromJS(item));
              }
              this.skip = _data["skip"];
              this.take = _data["take"];
          }
      }
  
      static fromJS(data: any): SearchProductsQuery {
          data = typeof data === 'object' ? data : {};
          let result = new SearchProductsQuery();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["categoryId"] = this.categoryId;
          if (Array.isArray(this.storesIds)) {
              data["storesIds"] = [];
              for (let item of this.storesIds)
                  data["storesIds"].push(item);
          }
          data["responseGroup"] = this.responseGroup;
          data["objectType"] = this.objectType;
          if (Array.isArray(this.objectTypes)) {
              data["objectTypes"] = [];
              for (let item of this.objectTypes)
                  data["objectTypes"].push(item);
          }
          if (Array.isArray(this.objectIds)) {
              data["objectIds"] = [];
              for (let item of this.objectIds)
                  data["objectIds"].push(item);
          }
          data["keyword"] = this.keyword;
          data["searchPhrase"] = this.searchPhrase;
          data["languageCode"] = this.languageCode;
          data["sort"] = this.sort;
          if (Array.isArray(this.sortInfos)) {
              data["sortInfos"] = [];
              for (let item of this.sortInfos)
                  data["sortInfos"].push(item.toJSON());
          }
          data["skip"] = this.skip;
          data["take"] = this.take;
          return data; 
      }
  }
  
  export interface ISearchProductsQuery {
      categoryId?: string | undefined;
      storesIds?: string[] | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  }
  
  export enum SellerProductStatus {
      None = "None",
      Published = "Published",
      HasStagedChanges = "HasStagedChanges",
      WaitForApproval = "WaitForApproval",
      RequiresChanges = "RequiresChanges",
      Rejected = "Rejected",
      Approved = "Approved",
  }
  
  export class Comment implements IComment {
      text?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IComment) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.text = _data["text"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Comment {
          data = typeof data === 'object' ? data : {};
          let result = new Comment();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["text"] = this.text;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IComment {
      text?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export enum PublicationRequestStatus {
      None = "None",
      WaitForApproval = "WaitForApproval",
      RequestChanges = "RequestChanges",
      Rejected = "Rejected",
      Approved = "Approved",
  }
  
  export class INotification implements IINotification {
  
      constructor(data?: IINotification) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
      }
  
      static fromJS(data: any): INotification {
          data = typeof data === 'object' ? data : {};
          let result = new INotification();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          return data; 
      }
  }
  
  export interface IINotification {
  }
  
  export class ProductPublicationRequest implements IProductPublicationRequest {
      storeId?: string | undefined;
      storeName?: string | undefined;
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      operatorId?: string | undefined;
      operatorName?: string | undefined;
      sellerProductId?: string | undefined;
      sellerProduct?: SellerProduct;
      comments?: Comment[] | undefined;
      prevStatus?: PublicationRequestStatus;
      status?: PublicationRequestStatus;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IProductPublicationRequest) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.storeId = _data["storeId"];
              this.storeName = _data["storeName"];
              this.sellerId = _data["sellerId"];
              this.sellerName = _data["sellerName"];
              this.operatorId = _data["operatorId"];
              this.operatorName = _data["operatorName"];
              this.sellerProductId = _data["sellerProductId"];
              this.sellerProduct = _data["sellerProduct"] ? SellerProduct.fromJS(_data["sellerProduct"]) : <any>undefined;
              if (Array.isArray(_data["comments"])) {
                  this.comments = [] as any;
                  for (let item of _data["comments"])
                      this.comments!.push(Comment.fromJS(item));
              }
              this.prevStatus = _data["prevStatus"];
              this.status = _data["status"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): ProductPublicationRequest {
          data = typeof data === 'object' ? data : {};
          let result = new ProductPublicationRequest();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["storeId"] = this.storeId;
          data["storeName"] = this.storeName;
          data["sellerId"] = this.sellerId;
          data["sellerName"] = this.sellerName;
          data["operatorId"] = this.operatorId;
          data["operatorName"] = this.operatorName;
          data["sellerProductId"] = this.sellerProductId;
          data["sellerProduct"] = this.sellerProduct ? this.sellerProduct.toJSON() : <any>undefined;
          if (Array.isArray(this.comments)) {
              data["comments"] = [];
              for (let item of this.comments)
                  data["comments"].push(item.toJSON());
          }
          data["prevStatus"] = this.prevStatus;
          data["status"] = this.status;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IProductPublicationRequest {
      storeId?: string | undefined;
      storeName?: string | undefined;
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      operatorId?: string | undefined;
      operatorName?: string | undefined;
      sellerProductId?: string | undefined;
      sellerProduct?: SellerProduct;
      comments?: Comment[] | undefined;
      prevStatus?: PublicationRequestStatus;
      status?: PublicationRequestStatus;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class ProductPublication implements IProductPublication {
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      storeId?: string | undefined;
      storeName?: string | undefined;
      publicationRequestId?: string | undefined;
      publicationRequest?: ProductPublicationRequest;
      isActive?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IProductPublication) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerId = _data["sellerId"];
              this.sellerName = _data["sellerName"];
              this.storeId = _data["storeId"];
              this.storeName = _data["storeName"];
              this.publicationRequestId = _data["publicationRequestId"];
              this.publicationRequest = _data["publicationRequest"] ? ProductPublicationRequest.fromJS(_data["publicationRequest"]) : <any>undefined;
              this.isActive = _data["isActive"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): ProductPublication {
          data = typeof data === 'object' ? data : {};
          let result = new ProductPublication();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerId"] = this.sellerId;
          data["sellerName"] = this.sellerName;
          data["storeId"] = this.storeId;
          data["storeName"] = this.storeName;
          data["publicationRequestId"] = this.publicationRequestId;
          data["publicationRequest"] = this.publicationRequest ? this.publicationRequest.toJSON() : <any>undefined;
          data["isActive"] = this.isActive;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IProductPublication {
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      storeId?: string | undefined;
      storeName?: string | undefined;
      publicationRequestId?: string | undefined;
      publicationRequest?: ProductPublicationRequest;
      isActive?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class Asset implements IAsset {
      mimeType?: string | undefined;
      size?: number;
      readonly readableSize?: string | undefined;
      binaryData?: string | undefined;
      relativeUrl?: string | undefined;
      url?: string | undefined;
      description?: string | undefined;
      sortOrder?: number;
      /** Gets or sets the asset type identifier. */
      typeId?: string | undefined;
      /** Gets or sets the asset group name. */
      group?: string | undefined;
      /** Gets or sets the asset name. */
      name?: string | undefined;
      outerId?: string | undefined;
      /** Gets or sets the asset language. */
      languageCode?: string | undefined;
      /** System flag used to mark that object was inherited from other */
      readonly isInherited?: boolean;
      readonly seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IAsset) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.mimeType = _data["mimeType"];
              this.size = _data["size"];
              (<any>this).readableSize = _data["readableSize"];
              this.binaryData = _data["binaryData"];
              this.relativeUrl = _data["relativeUrl"];
              this.url = _data["url"];
              this.description = _data["description"];
              this.sortOrder = _data["sortOrder"];
              this.typeId = _data["typeId"];
              this.group = _data["group"];
              this.name = _data["name"];
              this.outerId = _data["outerId"];
              this.languageCode = _data["languageCode"];
              (<any>this).isInherited = _data["isInherited"];
              (<any>this).seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Asset {
          data = typeof data === 'object' ? data : {};
          let result = new Asset();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["mimeType"] = this.mimeType;
          data["size"] = this.size;
          data["readableSize"] = this.readableSize;
          data["binaryData"] = this.binaryData;
          data["relativeUrl"] = this.relativeUrl;
          data["url"] = this.url;
          data["description"] = this.description;
          data["sortOrder"] = this.sortOrder;
          data["typeId"] = this.typeId;
          data["group"] = this.group;
          data["name"] = this.name;
          data["outerId"] = this.outerId;
          data["languageCode"] = this.languageCode;
          data["isInherited"] = this.isInherited;
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IAsset {
      mimeType?: string | undefined;
      size?: number;
      readableSize?: string | undefined;
      binaryData?: string | undefined;
      relativeUrl?: string | undefined;
      url?: string | undefined;
      description?: string | undefined;
      sortOrder?: number;
      /** Gets or sets the asset type identifier. */
      typeId?: string | undefined;
      /** Gets or sets the asset group name. */
      group?: string | undefined;
      /** Gets or sets the asset name. */
      name?: string | undefined;
      outerId?: string | undefined;
      /** Gets or sets the asset language. */
      languageCode?: string | undefined;
      /** System flag used to mark that object was inherited from other */
      isInherited?: boolean;
      seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class EditorialReview implements IEditorialReview {
      content?: string | undefined;
      reviewType?: string | undefined;
      languageCode?: string | undefined;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IEditorialReview) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.content = _data["content"];
              this.reviewType = _data["reviewType"];
              this.languageCode = _data["languageCode"];
              this.isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): EditorialReview {
          data = typeof data === 'object' ? data : {};
          let result = new EditorialReview();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["content"] = this.content;
          data["reviewType"] = this.reviewType;
          data["languageCode"] = this.languageCode;
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IEditorialReview {
      content?: string | undefined;
      reviewType?: string | undefined;
      languageCode?: string | undefined;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class ProductAssociation implements IProductAssociation {
      /** Association type (Accessories, Up-Sales, Cross-Sales, Related etc) */
      type?: string | undefined;
      priority?: number;
      quantity?: number | undefined;
      /** Is a primary key of associating object */
      itemId?: string | undefined;
      /** Each link element can have an associated object like Product, Category, etc.
  Is a primary key of associated object */
      associatedObjectId?: string | undefined;
      /** Associated object type : 'product', 'category' etc */
      associatedObjectType?: string | undefined;
      outerId?: string | undefined;
      /** Display name for associated object */
      readonly associatedObjectName?: string | undefined;
      /** Associated object image URL */
      readonly associatedObjectImg?: string | undefined;
      tags?: string[] | undefined;
      readonly imgSrc?: string | undefined;
      images?: Image[] | undefined;
      id?: string | undefined;
  
      constructor(data?: IProductAssociation) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.type = _data["type"];
              this.priority = _data["priority"];
              this.quantity = _data["quantity"];
              this.itemId = _data["itemId"];
              this.associatedObjectId = _data["associatedObjectId"];
              this.associatedObjectType = _data["associatedObjectType"];
              this.outerId = _data["outerId"];
              (<any>this).associatedObjectName = _data["associatedObjectName"];
              (<any>this).associatedObjectImg = _data["associatedObjectImg"];
              if (Array.isArray(_data["tags"])) {
                  this.tags = [] as any;
                  for (let item of _data["tags"])
                      this.tags!.push(item);
              }
              (<any>this).imgSrc = _data["imgSrc"];
              if (Array.isArray(_data["images"])) {
                  this.images = [] as any;
                  for (let item of _data["images"])
                      this.images!.push(Image.fromJS(item));
              }
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): ProductAssociation {
          data = typeof data === 'object' ? data : {};
          let result = new ProductAssociation();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["type"] = this.type;
          data["priority"] = this.priority;
          data["quantity"] = this.quantity;
          data["itemId"] = this.itemId;
          data["associatedObjectId"] = this.associatedObjectId;
          data["associatedObjectType"] = this.associatedObjectType;
          data["outerId"] = this.outerId;
          data["associatedObjectName"] = this.associatedObjectName;
          data["associatedObjectImg"] = this.associatedObjectImg;
          if (Array.isArray(this.tags)) {
              data["tags"] = [];
              for (let item of this.tags)
                  data["tags"].push(item);
          }
          data["imgSrc"] = this.imgSrc;
          if (Array.isArray(this.images)) {
              data["images"] = [];
              for (let item of this.images)
                  data["images"].push(item.toJSON());
          }
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IProductAssociation {
      /** Association type (Accessories, Up-Sales, Cross-Sales, Related etc) */
      type?: string | undefined;
      priority?: number;
      quantity?: number | undefined;
      /** Is a primary key of associating object */
      itemId?: string | undefined;
      /** Each link element can have an associated object like Product, Category, etc.
  Is a primary key of associated object */
      associatedObjectId?: string | undefined;
      /** Associated object type : 'product', 'category' etc */
      associatedObjectType?: string | undefined;
      outerId?: string | undefined;
      /** Display name for associated object */
      associatedObjectName?: string | undefined;
      /** Associated object image URL */
      associatedObjectImg?: string | undefined;
      tags?: string[] | undefined;
      imgSrc?: string | undefined;
      images?: Image[] | undefined;
      id?: string | undefined;
  }
  
  export class Variation implements IVariation {
      /** SKU code */
      code?: string | undefined;
      manufacturerPartNumber?: string | undefined;
      /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
      gtin?: string | undefined;
      name?: string | undefined;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      readonly outline?: string | undefined;
      /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      readonly path?: string | undefined;
      readonly titularItemId?: string | undefined;
      mainProductId?: string | undefined;
      isBuyable?: boolean | undefined;
      isActive?: boolean | undefined;
      trackInventory?: boolean | undefined;
      indexingDate?: Date | undefined;
      maxQuantity?: number | undefined;
      minQuantity?: number | undefined;
      /** Can be Physical, Digital or Subscription. */
      productType?: string | undefined;
      packageType?: string | undefined;
      weightUnit?: string | undefined;
      weight?: number | undefined;
      measureUnit?: string | undefined;
      height?: number | undefined;
      length?: number | undefined;
      width?: number | undefined;
      enableReview?: boolean | undefined;
      /** re-downloads limit */
      maxNumberOfDownload?: number | undefined;
      downloadExpiration?: Date | undefined;
      /** DownloadType: {Standard Product, Software, Music} */
      downloadType?: string | undefined;
      hasUserAgreement?: boolean | undefined;
      shippingType?: string | undefined;
      taxType?: string | undefined;
      vendor?: string | undefined;
      startDate?: Date;
      endDate?: Date | undefined;
      /** Product order position in catalog */
      priority?: number;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      propertyValues?: PropertyValue[] | undefined;
      /** Gets the default image for the product. */
      readonly imgSrc?: string | undefined;
      images?: Image[] | undefined;
      assets?: Asset[] | undefined;
      links?: CategoryLink[] | undefined;
      variations?: Variation[] | undefined;
      /** Each descendant type should override this property to use other object type for seo records */
      readonly seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      reviews?: EditorialReview[] | undefined;
      associations?: ProductAssociation[] | undefined;
      referencedAssociations?: ProductAssociation[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      readonly isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IVariation) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.code = _data["code"];
              this.manufacturerPartNumber = _data["manufacturerPartNumber"];
              this.gtin = _data["gtin"];
              this.name = _data["name"];
              this.catalogId = _data["catalogId"];
              this.categoryId = _data["categoryId"];
              (<any>this).outline = _data["outline"];
              (<any>this).path = _data["path"];
              (<any>this).titularItemId = _data["titularItemId"];
              this.mainProductId = _data["mainProductId"];
              this.isBuyable = _data["isBuyable"];
              this.isActive = _data["isActive"];
              this.trackInventory = _data["trackInventory"];
              this.indexingDate = _data["indexingDate"] ? new Date(_data["indexingDate"].toString()) : <any>undefined;
              this.maxQuantity = _data["maxQuantity"];
              this.minQuantity = _data["minQuantity"];
              this.productType = _data["productType"];
              this.packageType = _data["packageType"];
              this.weightUnit = _data["weightUnit"];
              this.weight = _data["weight"];
              this.measureUnit = _data["measureUnit"];
              this.height = _data["height"];
              this.length = _data["length"];
              this.width = _data["width"];
              this.enableReview = _data["enableReview"];
              this.maxNumberOfDownload = _data["maxNumberOfDownload"];
              this.downloadExpiration = _data["downloadExpiration"] ? new Date(_data["downloadExpiration"].toString()) : <any>undefined;
              this.downloadType = _data["downloadType"];
              this.hasUserAgreement = _data["hasUserAgreement"];
              this.shippingType = _data["shippingType"];
              this.taxType = _data["taxType"];
              this.vendor = _data["vendor"];
              this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
              this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
              this.priority = _data["priority"];
              this.outerId = _data["outerId"];
              if (Array.isArray(_data["properties"])) {
                  this.properties = [] as any;
                  for (let item of _data["properties"])
                      this.properties!.push(Property.fromJS(item));
              }
              if (Array.isArray(_data["excludedProperties"])) {
                  this.excludedProperties = [] as any;
                  for (let item of _data["excludedProperties"])
                      this.excludedProperties!.push(ExcludedProperty.fromJS(item));
              }
              if (Array.isArray(_data["propertyValues"])) {
                  this.propertyValues = [] as any;
                  for (let item of _data["propertyValues"])
                      this.propertyValues!.push(PropertyValue.fromJS(item));
              }
              (<any>this).imgSrc = _data["imgSrc"];
              if (Array.isArray(_data["images"])) {
                  this.images = [] as any;
                  for (let item of _data["images"])
                      this.images!.push(Image.fromJS(item));
              }
              if (Array.isArray(_data["assets"])) {
                  this.assets = [] as any;
                  for (let item of _data["assets"])
                      this.assets!.push(Asset.fromJS(item));
              }
              if (Array.isArray(_data["links"])) {
                  this.links = [] as any;
                  for (let item of _data["links"])
                      this.links!.push(CategoryLink.fromJS(item));
              }
              if (Array.isArray(_data["variations"])) {
                  this.variations = [] as any;
                  for (let item of _data["variations"])
                      this.variations!.push(Variation.fromJS(item));
              }
              (<any>this).seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              if (Array.isArray(_data["reviews"])) {
                  this.reviews = [] as any;
                  for (let item of _data["reviews"])
                      this.reviews!.push(EditorialReview.fromJS(item));
              }
              if (Array.isArray(_data["associations"])) {
                  this.associations = [] as any;
                  for (let item of _data["associations"])
                      this.associations!.push(ProductAssociation.fromJS(item));
              }
              if (Array.isArray(_data["referencedAssociations"])) {
                  this.referencedAssociations = [] as any;
                  for (let item of _data["referencedAssociations"])
                      this.referencedAssociations!.push(ProductAssociation.fromJS(item));
              }
              if (Array.isArray(_data["outlines"])) {
                  this.outlines = [] as any;
                  for (let item of _data["outlines"])
                      this.outlines!.push(Outline.fromJS(item));
              }
              (<any>this).isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Variation {
          data = typeof data === 'object' ? data : {};
          let result = new Variation();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["code"] = this.code;
          data["manufacturerPartNumber"] = this.manufacturerPartNumber;
          data["gtin"] = this.gtin;
          data["name"] = this.name;
          data["catalogId"] = this.catalogId;
          data["categoryId"] = this.categoryId;
          data["outline"] = this.outline;
          data["path"] = this.path;
          data["titularItemId"] = this.titularItemId;
          data["mainProductId"] = this.mainProductId;
          data["isBuyable"] = this.isBuyable;
          data["isActive"] = this.isActive;
          data["trackInventory"] = this.trackInventory;
          data["indexingDate"] = this.indexingDate ? this.indexingDate.toISOString() : <any>undefined;
          data["maxQuantity"] = this.maxQuantity;
          data["minQuantity"] = this.minQuantity;
          data["productType"] = this.productType;
          data["packageType"] = this.packageType;
          data["weightUnit"] = this.weightUnit;
          data["weight"] = this.weight;
          data["measureUnit"] = this.measureUnit;
          data["height"] = this.height;
          data["length"] = this.length;
          data["width"] = this.width;
          data["enableReview"] = this.enableReview;
          data["maxNumberOfDownload"] = this.maxNumberOfDownload;
          data["downloadExpiration"] = this.downloadExpiration ? this.downloadExpiration.toISOString() : <any>undefined;
          data["downloadType"] = this.downloadType;
          data["hasUserAgreement"] = this.hasUserAgreement;
          data["shippingType"] = this.shippingType;
          data["taxType"] = this.taxType;
          data["vendor"] = this.vendor;
          data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
          data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
          data["priority"] = this.priority;
          data["outerId"] = this.outerId;
          if (Array.isArray(this.properties)) {
              data["properties"] = [];
              for (let item of this.properties)
                  data["properties"].push(item.toJSON());
          }
          if (Array.isArray(this.excludedProperties)) {
              data["excludedProperties"] = [];
              for (let item of this.excludedProperties)
                  data["excludedProperties"].push(item.toJSON());
          }
          if (Array.isArray(this.propertyValues)) {
              data["propertyValues"] = [];
              for (let item of this.propertyValues)
                  data["propertyValues"].push(item.toJSON());
          }
          data["imgSrc"] = this.imgSrc;
          if (Array.isArray(this.images)) {
              data["images"] = [];
              for (let item of this.images)
                  data["images"].push(item.toJSON());
          }
          if (Array.isArray(this.assets)) {
              data["assets"] = [];
              for (let item of this.assets)
                  data["assets"].push(item.toJSON());
          }
          if (Array.isArray(this.links)) {
              data["links"] = [];
              for (let item of this.links)
                  data["links"].push(item.toJSON());
          }
          if (Array.isArray(this.variations)) {
              data["variations"] = [];
              for (let item of this.variations)
                  data["variations"].push(item.toJSON());
          }
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          if (Array.isArray(this.reviews)) {
              data["reviews"] = [];
              for (let item of this.reviews)
                  data["reviews"].push(item.toJSON());
          }
          if (Array.isArray(this.associations)) {
              data["associations"] = [];
              for (let item of this.associations)
                  data["associations"].push(item.toJSON());
          }
          if (Array.isArray(this.referencedAssociations)) {
              data["referencedAssociations"] = [];
              for (let item of this.referencedAssociations)
                  data["referencedAssociations"].push(item.toJSON());
          }
          if (Array.isArray(this.outlines)) {
              data["outlines"] = [];
              for (let item of this.outlines)
                  data["outlines"].push(item.toJSON());
          }
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IVariation {
      /** SKU code */
      code?: string | undefined;
      manufacturerPartNumber?: string | undefined;
      /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
      gtin?: string | undefined;
      name?: string | undefined;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      outline?: string | undefined;
      /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      path?: string | undefined;
      titularItemId?: string | undefined;
      mainProductId?: string | undefined;
      isBuyable?: boolean | undefined;
      isActive?: boolean | undefined;
      trackInventory?: boolean | undefined;
      indexingDate?: Date | undefined;
      maxQuantity?: number | undefined;
      minQuantity?: number | undefined;
      /** Can be Physical, Digital or Subscription. */
      productType?: string | undefined;
      packageType?: string | undefined;
      weightUnit?: string | undefined;
      weight?: number | undefined;
      measureUnit?: string | undefined;
      height?: number | undefined;
      length?: number | undefined;
      width?: number | undefined;
      enableReview?: boolean | undefined;
      /** re-downloads limit */
      maxNumberOfDownload?: number | undefined;
      downloadExpiration?: Date | undefined;
      /** DownloadType: {Standard Product, Software, Music} */
      downloadType?: string | undefined;
      hasUserAgreement?: boolean | undefined;
      shippingType?: string | undefined;
      taxType?: string | undefined;
      vendor?: string | undefined;
      startDate?: Date;
      endDate?: Date | undefined;
      /** Product order position in catalog */
      priority?: number;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      propertyValues?: PropertyValue[] | undefined;
      /** Gets the default image for the product. */
      imgSrc?: string | undefined;
      images?: Image[] | undefined;
      assets?: Asset[] | undefined;
      links?: CategoryLink[] | undefined;
      variations?: Variation[] | undefined;
      /** Each descendant type should override this property to use other object type for seo records */
      seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      reviews?: EditorialReview[] | undefined;
      associations?: ProductAssociation[] | undefined;
      referencedAssociations?: ProductAssociation[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class CatalogProduct implements ICatalogProduct {
      /** SKU code */
      code?: string | undefined;
      manufacturerPartNumber?: string | undefined;
      /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
      gtin?: string | undefined;
      name?: string | undefined;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      readonly outline?: string | undefined;
      /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      readonly path?: string | undefined;
      readonly titularItemId?: string | undefined;
      mainProductId?: string | undefined;
      isBuyable?: boolean | undefined;
      isActive?: boolean | undefined;
      trackInventory?: boolean | undefined;
      indexingDate?: Date | undefined;
      maxQuantity?: number | undefined;
      minQuantity?: number | undefined;
      /** Can be Physical, Digital or Subscription. */
      productType?: string | undefined;
      packageType?: string | undefined;
      weightUnit?: string | undefined;
      weight?: number | undefined;
      measureUnit?: string | undefined;
      height?: number | undefined;
      length?: number | undefined;
      width?: number | undefined;
      enableReview?: boolean | undefined;
      /** re-downloads limit */
      maxNumberOfDownload?: number | undefined;
      downloadExpiration?: Date | undefined;
      /** DownloadType: {Standard Product, Software, Music} */
      downloadType?: string | undefined;
      hasUserAgreement?: boolean | undefined;
      shippingType?: string | undefined;
      taxType?: string | undefined;
      vendor?: string | undefined;
      startDate?: Date;
      endDate?: Date | undefined;
      /** Product order position in catalog */
      priority?: number;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      propertyValues?: PropertyValue[] | undefined;
      /** Gets the default image for the product. */
      readonly imgSrc?: string | undefined;
      images?: Image[] | undefined;
      assets?: Asset[] | undefined;
      links?: CategoryLink[] | undefined;
      variations?: Variation[] | undefined;
      /** Each descendant type should override this property to use other object type for seo records */
      readonly seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      reviews?: EditorialReview[] | undefined;
      associations?: ProductAssociation[] | undefined;
      referencedAssociations?: ProductAssociation[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      readonly isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: ICatalogProduct) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.code = _data["code"];
              this.manufacturerPartNumber = _data["manufacturerPartNumber"];
              this.gtin = _data["gtin"];
              this.name = _data["name"];
              this.catalogId = _data["catalogId"];
              this.categoryId = _data["categoryId"];
              (<any>this).outline = _data["outline"];
              (<any>this).path = _data["path"];
              (<any>this).titularItemId = _data["titularItemId"];
              this.mainProductId = _data["mainProductId"];
              this.isBuyable = _data["isBuyable"];
              this.isActive = _data["isActive"];
              this.trackInventory = _data["trackInventory"];
              this.indexingDate = _data["indexingDate"] ? new Date(_data["indexingDate"].toString()) : <any>undefined;
              this.maxQuantity = _data["maxQuantity"];
              this.minQuantity = _data["minQuantity"];
              this.productType = _data["productType"];
              this.packageType = _data["packageType"];
              this.weightUnit = _data["weightUnit"];
              this.weight = _data["weight"];
              this.measureUnit = _data["measureUnit"];
              this.height = _data["height"];
              this.length = _data["length"];
              this.width = _data["width"];
              this.enableReview = _data["enableReview"];
              this.maxNumberOfDownload = _data["maxNumberOfDownload"];
              this.downloadExpiration = _data["downloadExpiration"] ? new Date(_data["downloadExpiration"].toString()) : <any>undefined;
              this.downloadType = _data["downloadType"];
              this.hasUserAgreement = _data["hasUserAgreement"];
              this.shippingType = _data["shippingType"];
              this.taxType = _data["taxType"];
              this.vendor = _data["vendor"];
              this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
              this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
              this.priority = _data["priority"];
              this.outerId = _data["outerId"];
              if (Array.isArray(_data["properties"])) {
                  this.properties = [] as any;
                  for (let item of _data["properties"])
                      this.properties!.push(Property.fromJS(item));
              }
              if (Array.isArray(_data["excludedProperties"])) {
                  this.excludedProperties = [] as any;
                  for (let item of _data["excludedProperties"])
                      this.excludedProperties!.push(ExcludedProperty.fromJS(item));
              }
              if (Array.isArray(_data["propertyValues"])) {
                  this.propertyValues = [] as any;
                  for (let item of _data["propertyValues"])
                      this.propertyValues!.push(PropertyValue.fromJS(item));
              }
              (<any>this).imgSrc = _data["imgSrc"];
              if (Array.isArray(_data["images"])) {
                  this.images = [] as any;
                  for (let item of _data["images"])
                      this.images!.push(Image.fromJS(item));
              }
              if (Array.isArray(_data["assets"])) {
                  this.assets = [] as any;
                  for (let item of _data["assets"])
                      this.assets!.push(Asset.fromJS(item));
              }
              if (Array.isArray(_data["links"])) {
                  this.links = [] as any;
                  for (let item of _data["links"])
                      this.links!.push(CategoryLink.fromJS(item));
              }
              if (Array.isArray(_data["variations"])) {
                  this.variations = [] as any;
                  for (let item of _data["variations"])
                      this.variations!.push(Variation.fromJS(item));
              }
              (<any>this).seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              if (Array.isArray(_data["reviews"])) {
                  this.reviews = [] as any;
                  for (let item of _data["reviews"])
                      this.reviews!.push(EditorialReview.fromJS(item));
              }
              if (Array.isArray(_data["associations"])) {
                  this.associations = [] as any;
                  for (let item of _data["associations"])
                      this.associations!.push(ProductAssociation.fromJS(item));
              }
              if (Array.isArray(_data["referencedAssociations"])) {
                  this.referencedAssociations = [] as any;
                  for (let item of _data["referencedAssociations"])
                      this.referencedAssociations!.push(ProductAssociation.fromJS(item));
              }
              if (Array.isArray(_data["outlines"])) {
                  this.outlines = [] as any;
                  for (let item of _data["outlines"])
                      this.outlines!.push(Outline.fromJS(item));
              }
              (<any>this).isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): CatalogProduct {
          data = typeof data === 'object' ? data : {};
          let result = new CatalogProduct();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["code"] = this.code;
          data["manufacturerPartNumber"] = this.manufacturerPartNumber;
          data["gtin"] = this.gtin;
          data["name"] = this.name;
          data["catalogId"] = this.catalogId;
          data["categoryId"] = this.categoryId;
          data["outline"] = this.outline;
          data["path"] = this.path;
          data["titularItemId"] = this.titularItemId;
          data["mainProductId"] = this.mainProductId;
          data["isBuyable"] = this.isBuyable;
          data["isActive"] = this.isActive;
          data["trackInventory"] = this.trackInventory;
          data["indexingDate"] = this.indexingDate ? this.indexingDate.toISOString() : <any>undefined;
          data["maxQuantity"] = this.maxQuantity;
          data["minQuantity"] = this.minQuantity;
          data["productType"] = this.productType;
          data["packageType"] = this.packageType;
          data["weightUnit"] = this.weightUnit;
          data["weight"] = this.weight;
          data["measureUnit"] = this.measureUnit;
          data["height"] = this.height;
          data["length"] = this.length;
          data["width"] = this.width;
          data["enableReview"] = this.enableReview;
          data["maxNumberOfDownload"] = this.maxNumberOfDownload;
          data["downloadExpiration"] = this.downloadExpiration ? this.downloadExpiration.toISOString() : <any>undefined;
          data["downloadType"] = this.downloadType;
          data["hasUserAgreement"] = this.hasUserAgreement;
          data["shippingType"] = this.shippingType;
          data["taxType"] = this.taxType;
          data["vendor"] = this.vendor;
          data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
          data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
          data["priority"] = this.priority;
          data["outerId"] = this.outerId;
          if (Array.isArray(this.properties)) {
              data["properties"] = [];
              for (let item of this.properties)
                  data["properties"].push(item.toJSON());
          }
          if (Array.isArray(this.excludedProperties)) {
              data["excludedProperties"] = [];
              for (let item of this.excludedProperties)
                  data["excludedProperties"].push(item.toJSON());
          }
          if (Array.isArray(this.propertyValues)) {
              data["propertyValues"] = [];
              for (let item of this.propertyValues)
                  data["propertyValues"].push(item.toJSON());
          }
          data["imgSrc"] = this.imgSrc;
          if (Array.isArray(this.images)) {
              data["images"] = [];
              for (let item of this.images)
                  data["images"].push(item.toJSON());
          }
          if (Array.isArray(this.assets)) {
              data["assets"] = [];
              for (let item of this.assets)
                  data["assets"].push(item.toJSON());
          }
          if (Array.isArray(this.links)) {
              data["links"] = [];
              for (let item of this.links)
                  data["links"].push(item.toJSON());
          }
          if (Array.isArray(this.variations)) {
              data["variations"] = [];
              for (let item of this.variations)
                  data["variations"].push(item.toJSON());
          }
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          if (Array.isArray(this.reviews)) {
              data["reviews"] = [];
              for (let item of this.reviews)
                  data["reviews"].push(item.toJSON());
          }
          if (Array.isArray(this.associations)) {
              data["associations"] = [];
              for (let item of this.associations)
                  data["associations"].push(item.toJSON());
          }
          if (Array.isArray(this.referencedAssociations)) {
              data["referencedAssociations"] = [];
              for (let item of this.referencedAssociations)
                  data["referencedAssociations"].push(item.toJSON());
          }
          if (Array.isArray(this.outlines)) {
              data["outlines"] = [];
              for (let item of this.outlines)
                  data["outlines"].push(item.toJSON());
          }
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface ICatalogProduct {
      /** SKU code */
      code?: string | undefined;
      manufacturerPartNumber?: string | undefined;
      /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
      gtin?: string | undefined;
      name?: string | undefined;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      outline?: string | undefined;
      /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      path?: string | undefined;
      titularItemId?: string | undefined;
      mainProductId?: string | undefined;
      isBuyable?: boolean | undefined;
      isActive?: boolean | undefined;
      trackInventory?: boolean | undefined;
      indexingDate?: Date | undefined;
      maxQuantity?: number | undefined;
      minQuantity?: number | undefined;
      /** Can be Physical, Digital or Subscription. */
      productType?: string | undefined;
      packageType?: string | undefined;
      weightUnit?: string | undefined;
      weight?: number | undefined;
      measureUnit?: string | undefined;
      height?: number | undefined;
      length?: number | undefined;
      width?: number | undefined;
      enableReview?: boolean | undefined;
      /** re-downloads limit */
      maxNumberOfDownload?: number | undefined;
      downloadExpiration?: Date | undefined;
      /** DownloadType: {Standard Product, Software, Music} */
      downloadType?: string | undefined;
      hasUserAgreement?: boolean | undefined;
      shippingType?: string | undefined;
      taxType?: string | undefined;
      vendor?: string | undefined;
      startDate?: Date;
      endDate?: Date | undefined;
      /** Product order position in catalog */
      priority?: number;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      propertyValues?: PropertyValue[] | undefined;
      /** Gets the default image for the product. */
      imgSrc?: string | undefined;
      images?: Image[] | undefined;
      assets?: Asset[] | undefined;
      links?: CategoryLink[] | undefined;
      variations?: Variation[] | undefined;
      /** Each descendant type should override this property to use other object type for seo records */
      seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      reviews?: EditorialReview[] | undefined;
      associations?: ProductAssociation[] | undefined;
      referencedAssociations?: ProductAssociation[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class SellerProduct implements ISellerProduct {
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      name?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      readonly outline?: string | undefined;
      readonly description?: string | undefined;
      hasStagedChanges?: boolean;
      isPublished?: boolean;
      status?: SellerProductStatus;
      readonly canBeModified?: boolean;
      publications?: ProductPublication[] | undefined;
      outerId?: string | undefined;
      productData?: CatalogProduct;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: ISellerProduct) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerId = _data["sellerId"];
              this.sellerName = _data["sellerName"];
              this.name = _data["name"];
              this.imgSrc = _data["imgSrc"];
              this.categoryId = _data["categoryId"];
              this.path = _data["path"];
              (<any>this).outline = _data["outline"];
              (<any>this).description = _data["description"];
              this.hasStagedChanges = _data["hasStagedChanges"];
              this.isPublished = _data["isPublished"];
              this.status = _data["status"];
              (<any>this).canBeModified = _data["canBeModified"];
              if (Array.isArray(_data["publications"])) {
                  this.publications = [] as any;
                  for (let item of _data["publications"])
                      this.publications!.push(ProductPublication.fromJS(item));
              }
              this.outerId = _data["outerId"];
              this.productData = _data["productData"] ? CatalogProduct.fromJS(_data["productData"]) : <any>undefined;
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): SellerProduct {
          data = typeof data === 'object' ? data : {};
          let result = new SellerProduct();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerId"] = this.sellerId;
          data["sellerName"] = this.sellerName;
          data["name"] = this.name;
          data["imgSrc"] = this.imgSrc;
          data["categoryId"] = this.categoryId;
          data["path"] = this.path;
          data["outline"] = this.outline;
          data["description"] = this.description;
          data["hasStagedChanges"] = this.hasStagedChanges;
          data["isPublished"] = this.isPublished;
          data["status"] = this.status;
          data["canBeModified"] = this.canBeModified;
          if (Array.isArray(this.publications)) {
              data["publications"] = [];
              for (let item of this.publications)
                  data["publications"].push(item.toJSON());
          }
          data["outerId"] = this.outerId;
          data["productData"] = this.productData ? this.productData.toJSON() : <any>undefined;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface ISellerProduct {
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      name?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      outline?: string | undefined;
      description?: string | undefined;
      hasStagedChanges?: boolean;
      isPublished?: boolean;
      status?: SellerProductStatus;
      canBeModified?: boolean;
      publications?: ProductPublication[] | undefined;
      outerId?: string | undefined;
      productData?: CatalogProduct;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class SearchProductsResult implements ISearchProductsResult {
      totalCount?: number;
      results?: SellerProduct[] | undefined;
  
      constructor(data?: ISearchProductsResult) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.totalCount = _data["totalCount"];
              if (Array.isArray(_data["results"])) {
                  this.results = [] as any;
                  for (let item of _data["results"])
                      this.results!.push(SellerProduct.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): SearchProductsResult {
          data = typeof data === 'object' ? data : {};
          let result = new SearchProductsResult();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["totalCount"] = this.totalCount;
          if (Array.isArray(this.results)) {
              data["results"] = [];
              for (let item of this.results)
                  data["results"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface ISearchProductsResult {
      totalCount?: number;
      results?: SellerProduct[] | undefined;
  }
  
  export class ProductDetails implements IProductDetails {
      name?: string | undefined;
      description?: string | undefined;
      gtin?: string | undefined;
      categoryId?: string | undefined;
      images?: Image[] | undefined;
  
      constructor(data?: IProductDetails) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.name = _data["name"];
              this.description = _data["description"];
              this.gtin = _data["gtin"];
              this.categoryId = _data["categoryId"];
              if (Array.isArray(_data["images"])) {
                  this.images = [] as any;
                  for (let item of _data["images"])
                      this.images!.push(Image.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): ProductDetails {
          data = typeof data === 'object' ? data : {};
          let result = new ProductDetails();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["name"] = this.name;
          data["description"] = this.description;
          data["gtin"] = this.gtin;
          data["categoryId"] = this.categoryId;
          if (Array.isArray(this.images)) {
              data["images"] = [];
              for (let item of this.images)
                  data["images"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface IProductDetails {
      name?: string | undefined;
      description?: string | undefined;
      gtin?: string | undefined;
      categoryId?: string | undefined;
      images?: Image[] | undefined;
  }
  
  export class CreateNewProductCommand implements ICreateNewProductCommand {
      sellerName?: string | undefined;
      productDetails?: ProductDetails;
  
      constructor(data?: ICreateNewProductCommand) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerName = _data["sellerName"];
              this.productDetails = _data["productDetails"] ? ProductDetails.fromJS(_data["productDetails"]) : <any>undefined;
          }
      }
  
      static fromJS(data: any): CreateNewProductCommand {
          data = typeof data === 'object' ? data : {};
          let result = new CreateNewProductCommand();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerName"] = this.sellerName;
          data["productDetails"] = this.productDetails ? this.productDetails.toJSON() : <any>undefined;
          return data; 
      }
  }
  
  export interface ICreateNewProductCommand {
      sellerName?: string | undefined;
      productDetails?: ProductDetails;
  }
  
  export class UpdateProductDetailsCommand implements IUpdateProductDetailsCommand {
      sellerProductId?: string | undefined;
      productDetails?: ProductDetails;
  
      constructor(data?: IUpdateProductDetailsCommand) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerProductId = _data["sellerProductId"];
              this.productDetails = _data["productDetails"] ? ProductDetails.fromJS(_data["productDetails"]) : <any>undefined;
          }
      }
  
      static fromJS(data: any): UpdateProductDetailsCommand {
          data = typeof data === 'object' ? data : {};
          let result = new UpdateProductDetailsCommand();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerProductId"] = this.sellerProductId;
          data["productDetails"] = this.productDetails ? this.productDetails.toJSON() : <any>undefined;
          return data; 
      }
  }
  
  export interface IUpdateProductDetailsCommand {
      sellerProductId?: string | undefined;
      productDetails?: ProductDetails;
  }
  
  export class CreateNewPublicationRequestCommand implements ICreateNewPublicationRequestCommand {
      storeId?: string | undefined;
      productId!: string;
      comment?: string | undefined;
  
      constructor(data?: ICreateNewPublicationRequestCommand) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.storeId = _data["storeId"];
              this.productId = _data["productId"];
              this.comment = _data["comment"];
          }
      }
  
      static fromJS(data: any): CreateNewPublicationRequestCommand {
          data = typeof data === 'object' ? data : {};
          let result = new CreateNewPublicationRequestCommand();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["storeId"] = this.storeId;
          data["productId"] = this.productId;
          data["comment"] = this.comment;
          return data; 
      }
  }
  
  export interface ICreateNewPublicationRequestCommand {
      storeId?: string | undefined;
      productId: string;
      comment?: string | undefined;
  }
  
  export class SearchOffersQuery implements ISearchOffersQuery {
      productId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      readonly sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  
      constructor(data?: ISearchOffersQuery) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.productId = _data["productId"];
              this.responseGroup = _data["responseGroup"];
              this.objectType = _data["objectType"];
              if (Array.isArray(_data["objectTypes"])) {
                  this.objectTypes = [] as any;
                  for (let item of _data["objectTypes"])
                      this.objectTypes!.push(item);
              }
              if (Array.isArray(_data["objectIds"])) {
                  this.objectIds = [] as any;
                  for (let item of _data["objectIds"])
                      this.objectIds!.push(item);
              }
              this.keyword = _data["keyword"];
              this.searchPhrase = _data["searchPhrase"];
              this.languageCode = _data["languageCode"];
              this.sort = _data["sort"];
              if (Array.isArray(_data["sortInfos"])) {
                  (<any>this).sortInfos = [] as any;
                  for (let item of _data["sortInfos"])
                      (<any>this).sortInfos!.push(SortInfo.fromJS(item));
              }
              this.skip = _data["skip"];
              this.take = _data["take"];
          }
      }
  
      static fromJS(data: any): SearchOffersQuery {
          data = typeof data === 'object' ? data : {};
          let result = new SearchOffersQuery();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["productId"] = this.productId;
          data["responseGroup"] = this.responseGroup;
          data["objectType"] = this.objectType;
          if (Array.isArray(this.objectTypes)) {
              data["objectTypes"] = [];
              for (let item of this.objectTypes)
                  data["objectTypes"].push(item);
          }
          if (Array.isArray(this.objectIds)) {
              data["objectIds"] = [];
              for (let item of this.objectIds)
                  data["objectIds"].push(item);
          }
          data["keyword"] = this.keyword;
          data["searchPhrase"] = this.searchPhrase;
          data["languageCode"] = this.languageCode;
          data["sort"] = this.sort;
          if (Array.isArray(this.sortInfos)) {
              data["sortInfos"] = [];
              for (let item of this.sortInfos)
                  data["sortInfos"].push(item.toJSON());
          }
          data["skip"] = this.skip;
          data["take"] = this.take;
          return data; 
      }
  }
  
  export interface ISearchOffersQuery {
      productId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  }
  
  export class Offer implements IOffer {
      isActive?: boolean;
      outerId?: string | undefined;
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      storeId?: string | undefined;
      storeName?: string | undefined;
      name?: string | undefined;
      sku?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      currency?: string | undefined;
      listPrice?: number;
      salePrice?: number | undefined;
      minQuantity?: number;
      inStockQuantity?: number;
      startDate?: Date | undefined;
      endDate?: Date | undefined;
      estimatedDeliveryDate?: string | undefined;
      productId?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IOffer) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.isActive = _data["isActive"];
              this.outerId = _data["outerId"];
              this.sellerId = _data["sellerId"];
              this.sellerName = _data["sellerName"];
              this.storeId = _data["storeId"];
              this.storeName = _data["storeName"];
              this.name = _data["name"];
              this.sku = _data["sku"];
              this.imgSrc = _data["imgSrc"];
              this.categoryId = _data["categoryId"];
              this.path = _data["path"];
              this.currency = _data["currency"];
              this.listPrice = _data["listPrice"];
              this.salePrice = _data["salePrice"];
              this.minQuantity = _data["minQuantity"];
              this.inStockQuantity = _data["inStockQuantity"];
              this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
              this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
              this.estimatedDeliveryDate = _data["estimatedDeliveryDate"];
              this.productId = _data["productId"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Offer {
          data = typeof data === 'object' ? data : {};
          let result = new Offer();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["isActive"] = this.isActive;
          data["outerId"] = this.outerId;
          data["sellerId"] = this.sellerId;
          data["sellerName"] = this.sellerName;
          data["storeId"] = this.storeId;
          data["storeName"] = this.storeName;
          data["name"] = this.name;
          data["sku"] = this.sku;
          data["imgSrc"] = this.imgSrc;
          data["categoryId"] = this.categoryId;
          data["path"] = this.path;
          data["currency"] = this.currency;
          data["listPrice"] = this.listPrice;
          data["salePrice"] = this.salePrice;
          data["minQuantity"] = this.minQuantity;
          data["inStockQuantity"] = this.inStockQuantity;
          data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
          data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
          data["estimatedDeliveryDate"] = this.estimatedDeliveryDate;
          data["productId"] = this.productId;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IOffer {
      isActive?: boolean;
      outerId?: string | undefined;
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      storeId?: string | undefined;
      storeName?: string | undefined;
      name?: string | undefined;
      sku?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      currency?: string | undefined;
      listPrice?: number;
      salePrice?: number | undefined;
      minQuantity?: number;
      inStockQuantity?: number;
      startDate?: Date | undefined;
      endDate?: Date | undefined;
      estimatedDeliveryDate?: string | undefined;
      productId?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class SearchOffersResult implements ISearchOffersResult {
      totalCount?: number;
      results?: Offer[] | undefined;
  
      constructor(data?: ISearchOffersResult) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.totalCount = _data["totalCount"];
              if (Array.isArray(_data["results"])) {
                  this.results = [] as any;
                  for (let item of _data["results"])
                      this.results!.push(Offer.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): SearchOffersResult {
          data = typeof data === 'object' ? data : {};
          let result = new SearchOffersResult();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["totalCount"] = this.totalCount;
          if (Array.isArray(this.results)) {
              data["results"] = [];
              for (let item of this.results)
                  data["results"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface ISearchOffersResult {
      totalCount?: number;
      results?: Offer[] | undefined;
  }
  
  export class SearchProductsForNewOfferQuery implements ISearchProductsForNewOfferQuery {
      sellerId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      readonly sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  
      constructor(data?: ISearchProductsForNewOfferQuery) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerId = _data["sellerId"];
              this.responseGroup = _data["responseGroup"];
              this.objectType = _data["objectType"];
              if (Array.isArray(_data["objectTypes"])) {
                  this.objectTypes = [] as any;
                  for (let item of _data["objectTypes"])
                      this.objectTypes!.push(item);
              }
              if (Array.isArray(_data["objectIds"])) {
                  this.objectIds = [] as any;
                  for (let item of _data["objectIds"])
                      this.objectIds!.push(item);
              }
              this.keyword = _data["keyword"];
              this.searchPhrase = _data["searchPhrase"];
              this.languageCode = _data["languageCode"];
              this.sort = _data["sort"];
              if (Array.isArray(_data["sortInfos"])) {
                  (<any>this).sortInfos = [] as any;
                  for (let item of _data["sortInfos"])
                      (<any>this).sortInfos!.push(SortInfo.fromJS(item));
              }
              this.skip = _data["skip"];
              this.take = _data["take"];
          }
      }
  
      static fromJS(data: any): SearchProductsForNewOfferQuery {
          data = typeof data === 'object' ? data : {};
          let result = new SearchProductsForNewOfferQuery();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerId"] = this.sellerId;
          data["responseGroup"] = this.responseGroup;
          data["objectType"] = this.objectType;
          if (Array.isArray(this.objectTypes)) {
              data["objectTypes"] = [];
              for (let item of this.objectTypes)
                  data["objectTypes"].push(item);
          }
          if (Array.isArray(this.objectIds)) {
              data["objectIds"] = [];
              for (let item of this.objectIds)
                  data["objectIds"].push(item);
          }
          data["keyword"] = this.keyword;
          data["searchPhrase"] = this.searchPhrase;
          data["languageCode"] = this.languageCode;
          data["sort"] = this.sort;
          if (Array.isArray(this.sortInfos)) {
              data["sortInfos"] = [];
              for (let item of this.sortInfos)
                  data["sortInfos"].push(item.toJSON());
          }
          data["skip"] = this.skip;
          data["take"] = this.take;
          return data; 
      }
  }
  
  export interface ISearchProductsForNewOfferQuery {
      sellerId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  }
  
  export class OfferProduct implements IOfferProduct {
      name?: string | undefined;
      sku?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IOfferProduct) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.name = _data["name"];
              this.sku = _data["sku"];
              this.imgSrc = _data["imgSrc"];
              this.categoryId = _data["categoryId"];
              this.path = _data["path"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): OfferProduct {
          data = typeof data === 'object' ? data : {};
          let result = new OfferProduct();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["name"] = this.name;
          data["sku"] = this.sku;
          data["imgSrc"] = this.imgSrc;
          data["categoryId"] = this.categoryId;
          data["path"] = this.path;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IOfferProduct {
      name?: string | undefined;
      sku?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class SearchOfferProductsResult implements ISearchOfferProductsResult {
      totalCount?: number;
      results?: OfferProduct[] | undefined;
  
      constructor(data?: ISearchOfferProductsResult) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.totalCount = _data["totalCount"];
              if (Array.isArray(_data["results"])) {
                  this.results = [] as any;
                  for (let item of _data["results"])
                      this.results!.push(OfferProduct.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): SearchOfferProductsResult {
          data = typeof data === 'object' ? data : {};
          let result = new SearchOfferProductsResult();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["totalCount"] = this.totalCount;
          if (Array.isArray(this.results)) {
              data["results"] = [];
              for (let item of this.results)
                  data["results"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface ISearchOfferProductsResult {
      totalCount?: number;
      results?: OfferProduct[] | undefined;
  }
  
  export class OfferDetails implements IOfferDetails {
      productId?: string | undefined;
      isActive?: boolean;
      outerId?: string | undefined;
      name?: string | undefined;
      sku!: string;
      currency!: string;
      listPrice!: number;
      salePrice?: number | undefined;
      minQuantity?: number;
      inStockQuantity?: number;
      startDate?: Date | undefined;
      endDate?: Date | undefined;
      estimatedDeliveryDate?: string | undefined;
  
      constructor(data?: IOfferDetails) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.productId = _data["productId"];
              this.isActive = _data["isActive"];
              this.outerId = _data["outerId"];
              this.name = _data["name"];
              this.sku = _data["sku"];
              this.currency = _data["currency"];
              this.listPrice = _data["listPrice"];
              this.salePrice = _data["salePrice"];
              this.minQuantity = _data["minQuantity"];
              this.inStockQuantity = _data["inStockQuantity"];
              this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
              this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
              this.estimatedDeliveryDate = _data["estimatedDeliveryDate"];
          }
      }
  
      static fromJS(data: any): OfferDetails {
          data = typeof data === 'object' ? data : {};
          let result = new OfferDetails();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["productId"] = this.productId;
          data["isActive"] = this.isActive;
          data["outerId"] = this.outerId;
          data["name"] = this.name;
          data["sku"] = this.sku;
          data["currency"] = this.currency;
          data["listPrice"] = this.listPrice;
          data["salePrice"] = this.salePrice;
          data["minQuantity"] = this.minQuantity;
          data["inStockQuantity"] = this.inStockQuantity;
          data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
          data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
          data["estimatedDeliveryDate"] = this.estimatedDeliveryDate;
          return data; 
      }
  }
  
  export interface IOfferDetails {
      productId?: string | undefined;
      isActive?: boolean;
      outerId?: string | undefined;
      name?: string | undefined;
      sku: string;
      currency: string;
      listPrice: number;
      salePrice?: number | undefined;
      minQuantity?: number;
      inStockQuantity?: number;
      startDate?: Date | undefined;
      endDate?: Date | undefined;
      estimatedDeliveryDate?: string | undefined;
  }
  
  export class CreateNewOfferCommand implements ICreateNewOfferCommand {
      outerId?: string | undefined;
      sellerName!: string;
      storeId?: string | undefined;
      storeName?: string | undefined;
      details!: OfferDetails;
      productId!: string;
  
      constructor(data?: ICreateNewOfferCommand) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
          if (!data) {
              this.details = new OfferDetails();
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.outerId = _data["outerId"];
              this.sellerName = _data["sellerName"];
              this.storeId = _data["storeId"];
              this.storeName = _data["storeName"];
              this.details = _data["details"] ? OfferDetails.fromJS(_data["details"]) : new OfferDetails();
              this.productId = _data["productId"];
          }
      }
  
      static fromJS(data: any): CreateNewOfferCommand {
          data = typeof data === 'object' ? data : {};
          let result = new CreateNewOfferCommand();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["outerId"] = this.outerId;
          data["sellerName"] = this.sellerName;
          data["storeId"] = this.storeId;
          data["storeName"] = this.storeName;
          data["details"] = this.details ? this.details.toJSON() : <any>undefined;
          data["productId"] = this.productId;
          return data; 
      }
  }
  
  export interface ICreateNewOfferCommand {
      outerId?: string | undefined;
      sellerName: string;
      storeId?: string | undefined;
      storeName?: string | undefined;
      details: OfferDetails;
      productId: string;
  }
  
  export class ApiException extends Error {
      message: string;
      status: number;
      response: string;
      headers: { [key: string]: any; };
      result: any;
  
      constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
          super();
  
          this.message = message;
          this.status = status;
          this.response = response;
          this.headers = headers;
          this.result = result;
      }
  
      protected isApiException = true;
  
      static isApiException(obj: any): obj is ApiException {
          return obj.isApiException === true;
      }
  }
  
  function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
      if (result !== null && result !== undefined)
          throw result;
      else
          throw new ApiException(message, status, response, headers, null);
  }
  
  /* eslint-disable */