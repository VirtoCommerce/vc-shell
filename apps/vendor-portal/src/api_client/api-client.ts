/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.3.0 (NJsonSchema v10.4.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AuthApiBase {
    authToken = "";
    protected constructor() {}
  
    setAuthToken(token: string) {
      this.authToken = token;
    }
  
    protected transformOptions(options: any): Promise<any> {
      options.headers['authorization'] =  `Bearer ${this.authToken}`;
      return Promise.resolve(options);
    }
  }
  
  export class VcmpSellerCatalogClient extends AuthApiBase {
      private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
      private baseUrl: string;
      protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
  
      constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
          super();
          this.http = http ? http : <any>window;
          this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      searchCategories(body: SearchCategoriesQuery | undefined): Promise<CategorySearchResult> {
          let url_ = this.baseUrl + "/api/vcmp/seller/categories/search";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processSearchCategories(_response);
          });
      }
  
      protected processSearchCategories(response: Response): Promise<CategorySearchResult> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = CategorySearchResult.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<CategorySearchResult>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      searchProducts(body: SearchProductsQuery | undefined): Promise<SearchProductsResult> {
          let url_ = this.baseUrl + "/api/vcmp/seller/products/search";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processSearchProducts(_response);
          });
      }
  
      protected processSearchProducts(response: Response): Promise<SearchProductsResult> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SearchProductsResult.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SearchProductsResult>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      searchPropertyDictionaryItems(body: PropertyDictionaryItemSearchCriteria | undefined): Promise<PropertyDictionaryItemSearchResult> {
          let url_ = this.baseUrl + "/api/vcmp/seller/dictionaryitems/search";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processSearchPropertyDictionaryItems(_response);
          });
      }
  
      protected processSearchPropertyDictionaryItems(response: Response): Promise<PropertyDictionaryItemSearchResult> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = PropertyDictionaryItemSearchResult.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<PropertyDictionaryItemSearchResult>(<any>null);
      }
  
      /**
       * @return Success
       */
      getProductById(productId: string | null): Promise<SellerProduct> {
          let url_ = this.baseUrl + "/api/vcmp/seller/products/{productId}";
          if (productId === undefined || productId === null)
              throw new Error("The parameter 'productId' must be defined.");
          url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "GET",
              headers: {
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processGetProductById(_response);
          });
      }
  
      protected processGetProductById(response: Response): Promise<SellerProduct> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SellerProduct.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SellerProduct>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      createNewProduct(body: CreateNewProductCommand | undefined): Promise<SellerProduct> {
          let url_ = this.baseUrl + "/api/vcmp/seller/products";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processCreateNewProduct(_response);
          });
      }
  
      protected processCreateNewProduct(response: Response): Promise<SellerProduct> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SellerProduct.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SellerProduct>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      updateProductDetails(body: UpdateProductDetailsCommand | undefined): Promise<SellerProduct> {
          let url_ = this.baseUrl + "/api/vcmp/seller/products";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "PUT",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processUpdateProductDetails(_response);
          });
      }
  
      protected processUpdateProductDetails(response: Response): Promise<SellerProduct> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SellerProduct.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SellerProduct>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      createNewPublicationRequest(body: CreateNewPublicationRequestCommand | undefined): Promise<ProductPublicationRequest> {
          let url_ = this.baseUrl + "/api/vcmp/seller/products/requests/new";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processCreateNewPublicationRequest(_response);
          });
      }
  
      protected processCreateNewPublicationRequest(response: Response): Promise<ProductPublicationRequest> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = ProductPublicationRequest.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<ProductPublicationRequest>(<any>null);
      }
  
      /**
       * @return Success
       */
      revertStagedChanges(productId: string | null): Promise<ProductPublicationRequest> {
          let url_ = this.baseUrl + "/api/vcmp/seller/product/{productId}/revert";
          if (productId === undefined || productId === null)
              throw new Error("The parameter 'productId' must be defined.");
          url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "POST",
              headers: {
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processRevertStagedChanges(_response);
          });
      }
  
      protected processRevertStagedChanges(response: Response): Promise<ProductPublicationRequest> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = ProductPublicationRequest.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<ProductPublicationRequest>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      searchOffers(body: SearchOffersQuery | undefined): Promise<SearchOffersResult> {
          let url_ = this.baseUrl + "/api/vcmp/seller/offers/search";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processSearchOffers(_response);
          });
      }
  
      protected processSearchOffers(response: Response): Promise<SearchOffersResult> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SearchOffersResult.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SearchOffersResult>(<any>null);
      }
  
      /**
       * @return Success
       */
      getOfferById(offerId: string | null): Promise<Offer> {
          let url_ = this.baseUrl + "/api/vcmp/seller/offers/{offerId}";
          if (offerId === undefined || offerId === null)
              throw new Error("The parameter 'offerId' must be defined.");
          url_ = url_.replace("{offerId}", encodeURIComponent("" + offerId));
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "POST",
              headers: {
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processGetOfferById(_response);
          });
      }
  
      protected processGetOfferById(response: Response): Promise<Offer> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = Offer.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<Offer>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      searchOfferProducts(body: SearchProductsForNewOfferQuery | undefined): Promise<SearchOfferProductsResult> {
          let url_ = this.baseUrl + "/api/vcmp/seller/offers/products/search";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processSearchOfferProducts(_response);
          });
      }
  
      protected processSearchOfferProducts(response: Response): Promise<SearchOfferProductsResult> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = SearchOfferProductsResult.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<SearchOfferProductsResult>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      createNewOffer(body: CreateNewOfferCommand | undefined): Promise<Offer> {
          let url_ = this.baseUrl + "/api/vcmp/seller/offers/new";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processCreateNewOffer(_response);
          });
      }
  
      protected processCreateNewOffer(response: Response): Promise<Offer> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = Offer.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<Offer>(<any>null);
      }
  
      /**
       * @param ids (optional) 
       * @return Success
       */
      deleteOffers(ids: string[] | null | undefined): Promise<void> {
          let url_ = this.baseUrl + "/api/vcmp/seller/offers?";
          if (ids !== undefined && ids !== null)
              ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "DELETE",
              headers: {
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processDeleteOffers(_response);
          });
      }
  
      protected processDeleteOffers(response: Response): Promise<void> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              return;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<void>(<any>null);
      }
  
      /**
       * @return Success
       */
      changeProductStatus(productId: string | null, status: string | null): Promise<void> {
          let url_ = this.baseUrl + "/api/vcmp/seller/product/{productId}/status/new/{status}";
          if (productId === undefined || productId === null)
              throw new Error("The parameter 'productId' must be defined.");
          url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
          if (status === undefined || status === null)
              throw new Error("The parameter 'status' must be defined.");
          url_ = url_.replace("{status}", encodeURIComponent("" + status));
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "POST",
              headers: {
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processChangeProductStatus(_response);
          });
      }
  
      protected processChangeProductStatus(response: Response): Promise<void> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              return;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<void>(<any>null);
      }
  }
  
  export class VcmpSellerImportClient extends AuthApiBase {
      private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
      private baseUrl: string;
      protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
  
      constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
          super();
          this.http = http ? http : <any>window;
          this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      runImport(body: ImportDataCommand | undefined): Promise<ImportPushNotification> {
          let url_ = this.baseUrl + "/api/vcmp/import/run";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processRunImport(_response);
          });
      }
  
      protected processRunImport(response: Response): Promise<ImportPushNotification> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = ImportPushNotification.fromJS(resultData200);
              return result200;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<ImportPushNotification>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      cancelJob(body: ImportCancellationRequest | undefined): Promise<void> {
          let url_ = this.baseUrl + "/api/vcmp/import/task/cancel";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processCancelJob(_response);
          });
      }
  
      protected processCancelJob(response: Response): Promise<void> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              return;
              });
          } else if (status === 401) {
              return response.text().then((_responseText) => {
              return throwException("Unauthorized", status, _responseText, _headers);
              });
          } else if (status === 403) {
              return response.text().then((_responseText) => {
              return throwException("Forbidden", status, _responseText, _headers);
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<void>(<any>null);
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      preview(body: PreviewDataQuery | undefined): Promise<ImportDataPreview> {
          let url_ = this.baseUrl + "/api/vcmp/import/preview";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processPreview(_response);
          });
      }
  
      protected processPreview(response: Response): Promise<ImportDataPreview> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              result200 = ImportDataPreview.fromJS(resultData200);
              return result200;
              });
          } else if (status === 401) {
              return response.text().then((_responseText) => {
              return throwException("Unauthorized", status, _responseText, _headers);
              });
          } else if (status === 403) {
              return response.text().then((_responseText) => {
              return throwException("Forbidden", status, _responseText, _headers);
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<ImportDataPreview>(<any>null);
      }
  
      /**
       * @return Success
       */
      getImporters(): Promise<ImporterMetadata[]> {
          let url_ = this.baseUrl + "/api/vcmp/import/importers";
          url_ = url_.replace(/[?&]$/, "");
  
          let options_ = <RequestInit>{
              method: "GET",
              headers: {
                  "Accept": "text/plain"
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processGetImporters(_response);
          });
      }
  
      protected processGetImporters(response: Response): Promise<ImporterMetadata[]> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              let result200: any = null;
              let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
              if (Array.isArray(resultData200)) {
                  result200 = [] as any;
                  for (let item of resultData200)
                      result200!.push(ImporterMetadata.fromJS(item));
              }
              else {
                  result200 = <any>null;
              }
              return result200;
              });
          } else if (status === 401) {
              return response.text().then((_responseText) => {
              return throwException("Unauthorized", status, _responseText, _headers);
              });
          } else if (status === 403) {
              return response.text().then((_responseText) => {
              return throwException("Forbidden", status, _responseText, _headers);
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<ImporterMetadata[]>(<any>null);
      }
  }
  
  export class VcmpSellerSecurityClient extends AuthApiBase {
      private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
      private baseUrl: string;
      protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
  
      constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
          super();
          this.http = http ? http : <any>window;
          this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
      }
  
      /**
       * @param body (optional) 
       * @return Success
       */
      forgotPassword(body: ForgotPasswordCommand | undefined): Promise<void> {
          let url_ = this.baseUrl + "/api/vcmp/security/forgotpassword";
          url_ = url_.replace(/[?&]$/, "");
  
          const content_ = JSON.stringify(body);
  
          let options_ = <RequestInit>{
              body: content_,
              method: "POST",
              headers: {
                  "Content-Type": "application/json-patch+json",
              }
          };
  
          return this.transformOptions(options_).then(transformedOptions_ => {
              return this.http.fetch(url_, transformedOptions_);
          }).then((_response: Response) => {
              return this.processForgotPassword(_response);
          });
      }
  
      protected processForgotPassword(response: Response): Promise<void> {
          const status = response.status;
          let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
          if (status === 200) {
              return response.text().then((_responseText) => {
              return;
              });
          } else if (status !== 200 && status !== 204) {
              return response.text().then((_responseText) => {
              return throwException("An unexpected server error occurred.", status, _responseText, _headers);
              });
          }
          return Promise.resolve<void>(<any>null);
      }
  }
  
  export enum SortDirection {
      Ascending = "Ascending",
      Descending = "Descending",
  }
  
  export class SortInfo implements ISortInfo {
      sortColumn?: string | undefined;
      sortDirection?: SortDirection;
  
      constructor(data?: ISortInfo) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sortColumn = _data["sortColumn"];
              this.sortDirection = _data["sortDirection"];
          }
      }
  
      static fromJS(data: any): SortInfo {
          data = typeof data === 'object' ? data : {};
          let result = new SortInfo();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sortColumn"] = this.sortColumn;
          data["sortDirection"] = this.sortDirection;
          return data; 
      }
  }
  
  export interface ISortInfo {
      sortColumn?: string | undefined;
      sortDirection?: SortDirection;
  }
  
  export class SearchCategoriesQuery implements ISearchCategoriesQuery {
      storeId?: string | undefined;
      sellerId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      readonly sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  
      constructor(data?: ISearchCategoriesQuery) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.storeId = _data["storeId"];
              this.sellerId = _data["sellerId"];
              this.responseGroup = _data["responseGroup"];
              this.objectType = _data["objectType"];
              if (Array.isArray(_data["objectTypes"])) {
                  this.objectTypes = [] as any;
                  for (let item of _data["objectTypes"])
                      this.objectTypes!.push(item);
              }
              if (Array.isArray(_data["objectIds"])) {
                  this.objectIds = [] as any;
                  for (let item of _data["objectIds"])
                      this.objectIds!.push(item);
              }
              this.keyword = _data["keyword"];
              this.searchPhrase = _data["searchPhrase"];
              this.languageCode = _data["languageCode"];
              this.sort = _data["sort"];
              if (Array.isArray(_data["sortInfos"])) {
                  (<any>this).sortInfos = [] as any;
                  for (let item of _data["sortInfos"])
                      (<any>this).sortInfos!.push(SortInfo.fromJS(item));
              }
              this.skip = _data["skip"];
              this.take = _data["take"];
          }
      }
  
      static fromJS(data: any): SearchCategoriesQuery {
          data = typeof data === 'object' ? data : {};
          let result = new SearchCategoriesQuery();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["storeId"] = this.storeId;
          data["sellerId"] = this.sellerId;
          data["responseGroup"] = this.responseGroup;
          data["objectType"] = this.objectType;
          if (Array.isArray(this.objectTypes)) {
              data["objectTypes"] = [];
              for (let item of this.objectTypes)
                  data["objectTypes"].push(item);
          }
          if (Array.isArray(this.objectIds)) {
              data["objectIds"] = [];
              for (let item of this.objectIds)
                  data["objectIds"].push(item);
          }
          data["keyword"] = this.keyword;
          data["searchPhrase"] = this.searchPhrase;
          data["languageCode"] = this.languageCode;
          data["sort"] = this.sort;
          if (Array.isArray(this.sortInfos)) {
              data["sortInfos"] = [];
              for (let item of this.sortInfos)
                  data["sortInfos"].push(item.toJSON());
          }
          data["skip"] = this.skip;
          data["take"] = this.take;
          return data; 
      }
  }
  
  export interface ISearchCategoriesQuery {
      storeId?: string | undefined;
      sellerId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  }
  
  export enum PropertyValueType {
      ShortText = "ShortText",
      LongText = "LongText",
      Number = "Number",
      DateTime = "DateTime",
      Boolean = "Boolean",
      Integer = "Integer",
      GeoPoint = "GeoPoint",
  }
  
  export enum PropertyType {
      Product = "Product",
      Variation = "Variation",
      Category = "Category",
      Catalog = "Catalog",
  }
  
  export class PropertyValue implements IPropertyValue {
      propertyName?: string | undefined;
      propertyId?: string | undefined;
      languageCode?: string | undefined;
      alias?: string | undefined;
      valueType?: PropertyValueType;
      valueId?: string | undefined;
      value?: any | undefined;
      readonly propertyMultivalue?: boolean;
      outerId?: string | undefined;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IPropertyValue) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.propertyName = _data["propertyName"];
              this.propertyId = _data["propertyId"];
              this.languageCode = _data["languageCode"];
              this.alias = _data["alias"];
              this.valueType = _data["valueType"];
              this.valueId = _data["valueId"];
              this.value = _data["value"];
              (<any>this).propertyMultivalue = _data["propertyMultivalue"];
              this.outerId = _data["outerId"];
              this.isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): PropertyValue {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyValue();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["propertyName"] = this.propertyName;
          data["propertyId"] = this.propertyId;
          data["languageCode"] = this.languageCode;
          data["alias"] = this.alias;
          data["valueType"] = this.valueType;
          data["valueId"] = this.valueId;
          data["value"] = this.value;
          data["propertyMultivalue"] = this.propertyMultivalue;
          data["outerId"] = this.outerId;
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IPropertyValue {
      propertyName?: string | undefined;
      propertyId?: string | undefined;
      languageCode?: string | undefined;
      alias?: string | undefined;
      valueType?: PropertyValueType;
      valueId?: string | undefined;
      value?: any | undefined;
      propertyMultivalue?: boolean;
      outerId?: string | undefined;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class PropertyAttribute implements IPropertyAttribute {
      propertyId?: string | undefined;
      value?: string | undefined;
      name?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IPropertyAttribute) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.propertyId = _data["propertyId"];
              this.value = _data["value"];
              this.name = _data["name"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): PropertyAttribute {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyAttribute();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["propertyId"] = this.propertyId;
          data["value"] = this.value;
          data["name"] = this.name;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IPropertyAttribute {
      propertyId?: string | undefined;
      value?: string | undefined;
      name?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class PropertyDisplayName implements IPropertyDisplayName {
      name?: string | undefined;
      languageCode?: string | undefined;
  
      constructor(data?: IPropertyDisplayName) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.name = _data["name"];
              this.languageCode = _data["languageCode"];
          }
      }
  
      static fromJS(data: any): PropertyDisplayName {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyDisplayName();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["name"] = this.name;
          data["languageCode"] = this.languageCode;
          return data; 
      }
  }
  
  export interface IPropertyDisplayName {
      name?: string | undefined;
      languageCode?: string | undefined;
  }
  
  /** Represents property validation rules definition */
  export class PropertyValidationRule implements IPropertyValidationRule {
      /** Uniquie value flag constrain */
      isUnique?: boolean;
      /** Down chars count border or null if no defined */
      charCountMin?: number | undefined;
      /** Upper chars count border or null if no defined */
      charCountMax?: number | undefined;
      /** Custom regular expression */
      regExp?: string | undefined;
      propertyId?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IPropertyValidationRule) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.isUnique = _data["isUnique"];
              this.charCountMin = _data["charCountMin"];
              this.charCountMax = _data["charCountMax"];
              this.regExp = _data["regExp"];
              this.propertyId = _data["propertyId"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): PropertyValidationRule {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyValidationRule();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["isUnique"] = this.isUnique;
          data["charCountMin"] = this.charCountMin;
          data["charCountMax"] = this.charCountMax;
          data["regExp"] = this.regExp;
          data["propertyId"] = this.propertyId;
          data["id"] = this.id;
          return data; 
      }
  }
  
  /** Represents property validation rules definition */
  export interface IPropertyValidationRule {
      /** Uniquie value flag constrain */
      isUnique?: boolean;
      /** Down chars count border or null if no defined */
      charCountMin?: number | undefined;
      /** Upper chars count border or null if no defined */
      charCountMax?: number | undefined;
      /** Custom regular expression */
      regExp?: string | undefined;
      propertyId?: string | undefined;
      id?: string | undefined;
  }
  
  export class Property implements IProperty {
      /** Gets or sets a value indicating whether user can change property value. */
      isReadOnly?: boolean;
      /** Gets or sets a value indicating whether user can change property metadata or remove this property. */
      readonly isManageable?: boolean;
      /** Gets or sets a value indicating whether this instance is new. A new property should be created on server site instead of trying to update it. */
      isNew?: boolean;
      /** Gets or sets the catalog id that this product belongs to. */
      catalogId?: string | undefined;
      /** Gets or sets the category id that this product belongs to. */
      categoryId?: string | undefined;
      name?: string | undefined;
      required?: boolean;
      dictionary?: boolean;
      multivalue?: boolean;
      multilanguage?: boolean;
      /** Gets or sets a value indicating whether this VirtoCommerce.CatalogModule.Core.Model.Property is hidden. */
      hidden?: boolean;
      valueType?: PropertyValueType;
      type?: PropertyType;
      outerId?: string | undefined;
      ownerName?: string | undefined;
      values?: PropertyValue[] | undefined;
      attributes?: PropertyAttribute[] | undefined;
      displayNames?: PropertyDisplayName[] | undefined;
      validationRules?: PropertyValidationRule[] | undefined;
      validationRule?: PropertyValidationRule;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IProperty) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.isReadOnly = _data["isReadOnly"];
              (<any>this).isManageable = _data["isManageable"];
              this.isNew = _data["isNew"];
              this.catalogId = _data["catalogId"];
              this.categoryId = _data["categoryId"];
              this.name = _data["name"];
              this.required = _data["required"];
              this.dictionary = _data["dictionary"];
              this.multivalue = _data["multivalue"];
              this.multilanguage = _data["multilanguage"];
              this.hidden = _data["hidden"];
              this.valueType = _data["valueType"];
              this.type = _data["type"];
              this.outerId = _data["outerId"];
              this.ownerName = _data["ownerName"];
              if (Array.isArray(_data["values"])) {
                  this.values = [] as any;
                  for (let item of _data["values"])
                      this.values!.push(PropertyValue.fromJS(item));
              }
              if (Array.isArray(_data["attributes"])) {
                  this.attributes = [] as any;
                  for (let item of _data["attributes"])
                      this.attributes!.push(PropertyAttribute.fromJS(item));
              }
              if (Array.isArray(_data["displayNames"])) {
                  this.displayNames = [] as any;
                  for (let item of _data["displayNames"])
                      this.displayNames!.push(PropertyDisplayName.fromJS(item));
              }
              if (Array.isArray(_data["validationRules"])) {
                  this.validationRules = [] as any;
                  for (let item of _data["validationRules"])
                      this.validationRules!.push(PropertyValidationRule.fromJS(item));
              }
              this.validationRule = _data["validationRule"] ? PropertyValidationRule.fromJS(_data["validationRule"]) : <any>undefined;
              this.isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Property {
          data = typeof data === 'object' ? data : {};
          let result = new Property();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["isReadOnly"] = this.isReadOnly;
          data["isManageable"] = this.isManageable;
          data["isNew"] = this.isNew;
          data["catalogId"] = this.catalogId;
          data["categoryId"] = this.categoryId;
          data["name"] = this.name;
          data["required"] = this.required;
          data["dictionary"] = this.dictionary;
          data["multivalue"] = this.multivalue;
          data["multilanguage"] = this.multilanguage;
          data["hidden"] = this.hidden;
          data["valueType"] = this.valueType;
          data["type"] = this.type;
          data["outerId"] = this.outerId;
          data["ownerName"] = this.ownerName;
          if (Array.isArray(this.values)) {
              data["values"] = [];
              for (let item of this.values)
                  data["values"].push(item.toJSON());
          }
          if (Array.isArray(this.attributes)) {
              data["attributes"] = [];
              for (let item of this.attributes)
                  data["attributes"].push(item.toJSON());
          }
          if (Array.isArray(this.displayNames)) {
              data["displayNames"] = [];
              for (let item of this.displayNames)
                  data["displayNames"].push(item.toJSON());
          }
          if (Array.isArray(this.validationRules)) {
              data["validationRules"] = [];
              for (let item of this.validationRules)
                  data["validationRules"].push(item.toJSON());
          }
          data["validationRule"] = this.validationRule ? this.validationRule.toJSON() : <any>undefined;
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IProperty {
      /** Gets or sets a value indicating whether user can change property value. */
      isReadOnly?: boolean;
      /** Gets or sets a value indicating whether user can change property metadata or remove this property. */
      isManageable?: boolean;
      /** Gets or sets a value indicating whether this instance is new. A new property should be created on server site instead of trying to update it. */
      isNew?: boolean;
      /** Gets or sets the catalog id that this product belongs to. */
      catalogId?: string | undefined;
      /** Gets or sets the category id that this product belongs to. */
      categoryId?: string | undefined;
      name?: string | undefined;
      required?: boolean;
      dictionary?: boolean;
      multivalue?: boolean;
      multilanguage?: boolean;
      /** Gets or sets a value indicating whether this VirtoCommerce.CatalogModule.Core.Model.Property is hidden. */
      hidden?: boolean;
      valueType?: PropertyValueType;
      type?: PropertyType;
      outerId?: string | undefined;
      ownerName?: string | undefined;
      values?: PropertyValue[] | undefined;
      attributes?: PropertyAttribute[] | undefined;
      displayNames?: PropertyDisplayName[] | undefined;
      validationRules?: PropertyValidationRule[] | undefined;
      validationRule?: PropertyValidationRule;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class ExcludedProperty implements IExcludedProperty {
      name?: string | undefined;
      isInherited?: boolean;
  
      constructor(data?: IExcludedProperty) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.name = _data["name"];
              this.isInherited = _data["isInherited"];
          }
      }
  
      static fromJS(data: any): ExcludedProperty {
          data = typeof data === 'object' ? data : {};
          let result = new ExcludedProperty();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["name"] = this.name;
          data["isInherited"] = this.isInherited;
          return data; 
      }
  }
  
  export interface IExcludedProperty {
      name?: string | undefined;
      isInherited?: boolean;
  }
  
  export class CategoryLink implements ICategoryLink {
      /** Entry identifier which this link belongs to */
      readonly entryId?: string | undefined;
      listEntryId?: string | undefined;
      /** Gets or sets the type of the list entry. E.g. "product", "category" */
      listEntryType?: string | undefined;
      /** Product order position in virtual catalog */
      priority?: number;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      category?: Category;
  
      constructor(data?: ICategoryLink) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              (<any>this).entryId = _data["entryId"];
              this.listEntryId = _data["listEntryId"];
              this.listEntryType = _data["listEntryType"];
              this.priority = _data["priority"];
              this.catalogId = _data["catalogId"];
              this.categoryId = _data["categoryId"];
              this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
          }
      }
  
      static fromJS(data: any): CategoryLink {
          data = typeof data === 'object' ? data : {};
          let result = new CategoryLink();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["entryId"] = this.entryId;
          data["listEntryId"] = this.listEntryId;
          data["listEntryType"] = this.listEntryType;
          data["priority"] = this.priority;
          data["catalogId"] = this.catalogId;
          data["categoryId"] = this.categoryId;
          data["category"] = this.category ? this.category.toJSON() : <any>undefined;
          return data; 
      }
  }
  
  export interface ICategoryLink {
      /** Entry identifier which this link belongs to */
      entryId?: string | undefined;
      listEntryId?: string | undefined;
      /** Gets or sets the type of the list entry. E.g. "product", "category" */
      listEntryType?: string | undefined;
      /** Product order position in virtual catalog */
      priority?: number;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      category?: Category;
  }
  
  export class SeoInfo implements ISeoInfo {
      name?: string | undefined;
      /** Slug */
      semanticUrl?: string | undefined;
      /** head title tag content */
      pageTitle?: string | undefined;
      /** <meta name="description" /> */
      metaDescription?: string | undefined;
      imageAltDescription?: string | undefined;
      /** <meta name="keywords" /> */
      metaKeywords?: string | undefined;
      /** Tenant StoreId which SEO defined */
      storeId?: string | undefined;
      /** SEO related object id */
      objectId?: string | undefined;
      /** SEO related object type name */
      objectType?: string | undefined;
      /** Active/Inactive */
      isActive?: boolean;
      languageCode?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: ISeoInfo) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.name = _data["name"];
              this.semanticUrl = _data["semanticUrl"];
              this.pageTitle = _data["pageTitle"];
              this.metaDescription = _data["metaDescription"];
              this.imageAltDescription = _data["imageAltDescription"];
              this.metaKeywords = _data["metaKeywords"];
              this.storeId = _data["storeId"];
              this.objectId = _data["objectId"];
              this.objectType = _data["objectType"];
              this.isActive = _data["isActive"];
              this.languageCode = _data["languageCode"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): SeoInfo {
          data = typeof data === 'object' ? data : {};
          let result = new SeoInfo();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["name"] = this.name;
          data["semanticUrl"] = this.semanticUrl;
          data["pageTitle"] = this.pageTitle;
          data["metaDescription"] = this.metaDescription;
          data["imageAltDescription"] = this.imageAltDescription;
          data["metaKeywords"] = this.metaKeywords;
          data["storeId"] = this.storeId;
          data["objectId"] = this.objectId;
          data["objectType"] = this.objectType;
          data["isActive"] = this.isActive;
          data["languageCode"] = this.languageCode;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface ISeoInfo {
      name?: string | undefined;
      /** Slug */
      semanticUrl?: string | undefined;
      /** head title tag content */
      pageTitle?: string | undefined;
      /** <meta name="description" /> */
      metaDescription?: string | undefined;
      imageAltDescription?: string | undefined;
      /** <meta name="keywords" /> */
      metaKeywords?: string | undefined;
      /** Tenant StoreId which SEO defined */
      storeId?: string | undefined;
      /** SEO related object id */
      objectId?: string | undefined;
      /** SEO related object type name */
      objectType?: string | undefined;
      /** Active/Inactive */
      isActive?: boolean;
      languageCode?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class CategoryDescription implements ICategoryDescription {
      content?: string | undefined;
      descriptionType?: string | undefined;
      languageCode?: string | undefined;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: ICategoryDescription) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.content = _data["content"];
              this.descriptionType = _data["descriptionType"];
              this.languageCode = _data["languageCode"];
              this.isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): CategoryDescription {
          data = typeof data === 'object' ? data : {};
          let result = new CategoryDescription();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["content"] = this.content;
          data["descriptionType"] = this.descriptionType;
          data["languageCode"] = this.languageCode;
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface ICategoryDescription {
      content?: string | undefined;
      descriptionType?: string | undefined;
      languageCode?: string | undefined;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class Image implements IImage {
      binaryData?: string | undefined;
      altText?: string | undefined;
      relativeUrl?: string | undefined;
      url?: string | undefined;
      description?: string | undefined;
      sortOrder?: number;
      /** Gets or sets the asset type identifier. */
      typeId?: string | undefined;
      /** Gets or sets the asset group name. */
      group?: string | undefined;
      /** Gets or sets the asset name. */
      name?: string | undefined;
      outerId?: string | undefined;
      /** Gets or sets the asset language. */
      languageCode?: string | undefined;
      /** System flag used to mark that object was inherited from other */
      readonly isInherited?: boolean;
      readonly seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IImage) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.binaryData = _data["binaryData"];
              this.altText = _data["altText"];
              this.relativeUrl = _data["relativeUrl"];
              this.url = _data["url"];
              this.description = _data["description"];
              this.sortOrder = _data["sortOrder"];
              this.typeId = _data["typeId"];
              this.group = _data["group"];
              this.name = _data["name"];
              this.outerId = _data["outerId"];
              this.languageCode = _data["languageCode"];
              (<any>this).isInherited = _data["isInherited"];
              (<any>this).seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Image {
          data = typeof data === 'object' ? data : {};
          let result = new Image();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["binaryData"] = this.binaryData;
          data["altText"] = this.altText;
          data["relativeUrl"] = this.relativeUrl;
          data["url"] = this.url;
          data["description"] = this.description;
          data["sortOrder"] = this.sortOrder;
          data["typeId"] = this.typeId;
          data["group"] = this.group;
          data["name"] = this.name;
          data["outerId"] = this.outerId;
          data["languageCode"] = this.languageCode;
          data["isInherited"] = this.isInherited;
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IImage {
      binaryData?: string | undefined;
      altText?: string | undefined;
      relativeUrl?: string | undefined;
      url?: string | undefined;
      description?: string | undefined;
      sortOrder?: number;
      /** Gets or sets the asset type identifier. */
      typeId?: string | undefined;
      /** Gets or sets the asset group name. */
      group?: string | undefined;
      /** Gets or sets the asset name. */
      name?: string | undefined;
      outerId?: string | undefined;
      /** Gets or sets the asset language. */
      languageCode?: string | undefined;
      /** System flag used to mark that object was inherited from other */
      isInherited?: boolean;
      seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  /** Represents one outline element: catalog, category or product. */
  export class OutlineItem implements IOutlineItem {
      /** Object id */
      id?: string | undefined;
      /** Object type */
      seoObjectType?: string | undefined;
      /** All SEO records for the object */
      seoInfos?: SeoInfo[] | undefined;
      /** The name of current item */
      name?: string | undefined;
      /** True when this object is linked to the virtual parent. */
      hasVirtualParent?: boolean;
  
      constructor(data?: IOutlineItem) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.id = _data["id"];
              this.seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              this.name = _data["name"];
              this.hasVirtualParent = _data["hasVirtualParent"];
          }
      }
  
      static fromJS(data: any): OutlineItem {
          data = typeof data === 'object' ? data : {};
          let result = new OutlineItem();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["id"] = this.id;
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          data["name"] = this.name;
          data["hasVirtualParent"] = this.hasVirtualParent;
          return data; 
      }
  }
  
  /** Represents one outline element: catalog, category or product. */
  export interface IOutlineItem {
      /** Object id */
      id?: string | undefined;
      /** Object type */
      seoObjectType?: string | undefined;
      /** All SEO records for the object */
      seoInfos?: SeoInfo[] | undefined;
      /** The name of current item */
      name?: string | undefined;
      /** True when this object is linked to the virtual parent. */
      hasVirtualParent?: boolean;
  }
  
  /** Represents the path from the catalog to one of the child objects (product or category): catalog/parent-category1/.../parent-categoryN/object */
  export class Outline implements IOutline {
      /** Outline parts */
      items?: OutlineItem[] | undefined;
  
      constructor(data?: IOutline) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              if (Array.isArray(_data["items"])) {
                  this.items = [] as any;
                  for (let item of _data["items"])
                      this.items!.push(OutlineItem.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): Outline {
          data = typeof data === 'object' ? data : {};
          let result = new Outline();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          if (Array.isArray(this.items)) {
              data["items"] = [];
              for (let item of this.items)
                  data["items"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  /** Represents the path from the catalog to one of the child objects (product or category): catalog/parent-category1/.../parent-categoryN/object */
  export interface IOutline {
      /** Outline parts */
      items?: OutlineItem[] | undefined;
  }
  
  export class Category implements ICategory {
      catalogId?: string | undefined;
      parentId?: string | undefined;
      code?: string | undefined;
      name?: string | undefined;
      /** Category outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      readonly outline?: string | undefined;
      /** Category path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      path?: string | undefined;
      isVirtual?: boolean;
      level?: number;
      packageType?: string | undefined;
      priority?: number;
      isActive?: boolean | undefined;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      links?: CategoryLink[] | undefined;
      taxType?: string | undefined;
      readonly seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      enableDescription?: boolean | undefined;
      descriptions?: CategoryDescription[] | undefined;
      /** Gets the default image */
      readonly imgSrc?: string | undefined;
      images?: Image[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      readonly isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: ICategory) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.catalogId = _data["catalogId"];
              this.parentId = _data["parentId"];
              this.code = _data["code"];
              this.name = _data["name"];
              (<any>this).outline = _data["outline"];
              this.path = _data["path"];
              this.isVirtual = _data["isVirtual"];
              this.level = _data["level"];
              this.packageType = _data["packageType"];
              this.priority = _data["priority"];
              this.isActive = _data["isActive"];
              this.outerId = _data["outerId"];
              if (Array.isArray(_data["properties"])) {
                  this.properties = [] as any;
                  for (let item of _data["properties"])
                      this.properties!.push(Property.fromJS(item));
              }
              if (Array.isArray(_data["excludedProperties"])) {
                  this.excludedProperties = [] as any;
                  for (let item of _data["excludedProperties"])
                      this.excludedProperties!.push(ExcludedProperty.fromJS(item));
              }
              if (Array.isArray(_data["links"])) {
                  this.links = [] as any;
                  for (let item of _data["links"])
                      this.links!.push(CategoryLink.fromJS(item));
              }
              this.taxType = _data["taxType"];
              (<any>this).seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              this.enableDescription = _data["enableDescription"];
              if (Array.isArray(_data["descriptions"])) {
                  this.descriptions = [] as any;
                  for (let item of _data["descriptions"])
                      this.descriptions!.push(CategoryDescription.fromJS(item));
              }
              (<any>this).imgSrc = _data["imgSrc"];
              if (Array.isArray(_data["images"])) {
                  this.images = [] as any;
                  for (let item of _data["images"])
                      this.images!.push(Image.fromJS(item));
              }
              if (Array.isArray(_data["outlines"])) {
                  this.outlines = [] as any;
                  for (let item of _data["outlines"])
                      this.outlines!.push(Outline.fromJS(item));
              }
              (<any>this).isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Category {
          data = typeof data === 'object' ? data : {};
          let result = new Category();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["catalogId"] = this.catalogId;
          data["parentId"] = this.parentId;
          data["code"] = this.code;
          data["name"] = this.name;
          data["outline"] = this.outline;
          data["path"] = this.path;
          data["isVirtual"] = this.isVirtual;
          data["level"] = this.level;
          data["packageType"] = this.packageType;
          data["priority"] = this.priority;
          data["isActive"] = this.isActive;
          data["outerId"] = this.outerId;
          if (Array.isArray(this.properties)) {
              data["properties"] = [];
              for (let item of this.properties)
                  data["properties"].push(item.toJSON());
          }
          if (Array.isArray(this.excludedProperties)) {
              data["excludedProperties"] = [];
              for (let item of this.excludedProperties)
                  data["excludedProperties"].push(item.toJSON());
          }
          if (Array.isArray(this.links)) {
              data["links"] = [];
              for (let item of this.links)
                  data["links"].push(item.toJSON());
          }
          data["taxType"] = this.taxType;
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          data["enableDescription"] = this.enableDescription;
          if (Array.isArray(this.descriptions)) {
              data["descriptions"] = [];
              for (let item of this.descriptions)
                  data["descriptions"].push(item.toJSON());
          }
          data["imgSrc"] = this.imgSrc;
          if (Array.isArray(this.images)) {
              data["images"] = [];
              for (let item of this.images)
                  data["images"].push(item.toJSON());
          }
          if (Array.isArray(this.outlines)) {
              data["outlines"] = [];
              for (let item of this.outlines)
                  data["outlines"].push(item.toJSON());
          }
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface ICategory {
      catalogId?: string | undefined;
      parentId?: string | undefined;
      code?: string | undefined;
      name?: string | undefined;
      /** Category outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      outline?: string | undefined;
      /** Category path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      path?: string | undefined;
      isVirtual?: boolean;
      level?: number;
      packageType?: string | undefined;
      priority?: number;
      isActive?: boolean | undefined;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      links?: CategoryLink[] | undefined;
      taxType?: string | undefined;
      seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      enableDescription?: boolean | undefined;
      descriptions?: CategoryDescription[] | undefined;
      /** Gets the default image */
      imgSrc?: string | undefined;
      images?: Image[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class CategorySearchResult implements ICategorySearchResult {
      totalCount?: number;
      results?: Category[] | undefined;
  
      constructor(data?: ICategorySearchResult) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.totalCount = _data["totalCount"];
              if (Array.isArray(_data["results"])) {
                  this.results = [] as any;
                  for (let item of _data["results"])
                      this.results!.push(Category.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): CategorySearchResult {
          data = typeof data === 'object' ? data : {};
          let result = new CategorySearchResult();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["totalCount"] = this.totalCount;
          if (Array.isArray(this.results)) {
              data["results"] = [];
              for (let item of this.results)
                  data["results"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface ICategorySearchResult {
      totalCount?: number;
      results?: Category[] | undefined;
  }
  
  export class SearchProductsQuery implements ISearchProductsQuery {
      sellerId?: string | undefined;
      categoryId?: string | undefined;
      storesIds?: string[] | undefined;
      status?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      readonly sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  
      constructor(data?: ISearchProductsQuery) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerId = _data["sellerId"];
              this.categoryId = _data["categoryId"];
              if (Array.isArray(_data["storesIds"])) {
                  this.storesIds = [] as any;
                  for (let item of _data["storesIds"])
                      this.storesIds!.push(item);
              }
              this.status = _data["status"];
              this.responseGroup = _data["responseGroup"];
              this.objectType = _data["objectType"];
              if (Array.isArray(_data["objectTypes"])) {
                  this.objectTypes = [] as any;
                  for (let item of _data["objectTypes"])
                      this.objectTypes!.push(item);
              }
              if (Array.isArray(_data["objectIds"])) {
                  this.objectIds = [] as any;
                  for (let item of _data["objectIds"])
                      this.objectIds!.push(item);
              }
              this.keyword = _data["keyword"];
              this.searchPhrase = _data["searchPhrase"];
              this.languageCode = _data["languageCode"];
              this.sort = _data["sort"];
              if (Array.isArray(_data["sortInfos"])) {
                  (<any>this).sortInfos = [] as any;
                  for (let item of _data["sortInfos"])
                      (<any>this).sortInfos!.push(SortInfo.fromJS(item));
              }
              this.skip = _data["skip"];
              this.take = _data["take"];
          }
      }
  
      static fromJS(data: any): SearchProductsQuery {
          data = typeof data === 'object' ? data : {};
          let result = new SearchProductsQuery();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerId"] = this.sellerId;
          data["categoryId"] = this.categoryId;
          if (Array.isArray(this.storesIds)) {
              data["storesIds"] = [];
              for (let item of this.storesIds)
                  data["storesIds"].push(item);
          }
          data["status"] = this.status;
          data["responseGroup"] = this.responseGroup;
          data["objectType"] = this.objectType;
          if (Array.isArray(this.objectTypes)) {
              data["objectTypes"] = [];
              for (let item of this.objectTypes)
                  data["objectTypes"].push(item);
          }
          if (Array.isArray(this.objectIds)) {
              data["objectIds"] = [];
              for (let item of this.objectIds)
                  data["objectIds"].push(item);
          }
          data["keyword"] = this.keyword;
          data["searchPhrase"] = this.searchPhrase;
          data["languageCode"] = this.languageCode;
          data["sort"] = this.sort;
          if (Array.isArray(this.sortInfos)) {
              data["sortInfos"] = [];
              for (let item of this.sortInfos)
                  data["sortInfos"].push(item.toJSON());
          }
          data["skip"] = this.skip;
          data["take"] = this.take;
          return data; 
      }
  }
  
  export interface ISearchProductsQuery {
      sellerId?: string | undefined;
      categoryId?: string | undefined;
      storesIds?: string[] | undefined;
      status?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  }
  
  export enum SellerProductStatus {
      None = "None",
      Published = "Published",
      HasStagedChanges = "HasStagedChanges",
      WaitForApproval = "WaitForApproval",
      RequiresChanges = "RequiresChanges",
      Rejected = "Rejected",
      Approved = "Approved",
  }
  
  export class Comment implements IComment {
      text?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IComment) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.text = _data["text"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Comment {
          data = typeof data === 'object' ? data : {};
          let result = new Comment();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["text"] = this.text;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IComment {
      text?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export enum PublicationRequestStatus {
      None = "None",
      WaitForApproval = "WaitForApproval",
      RequestChanges = "RequestChanges",
      Rejected = "Rejected",
      Approved = "Approved",
  }
  
  export class ProductPublicationRequest implements IProductPublicationRequest {
      storeId?: string | undefined;
      storeName?: string | undefined;
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      operatorId?: string | undefined;
      operatorName?: string | undefined;
      sellerProductId?: string | undefined;
      sellerProduct?: SellerProduct;
      comments?: Comment[] | undefined;
      prevStatus?: PublicationRequestStatus;
      status?: PublicationRequestStatus;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IProductPublicationRequest) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.storeId = _data["storeId"];
              this.storeName = _data["storeName"];
              this.sellerId = _data["sellerId"];
              this.sellerName = _data["sellerName"];
              this.operatorId = _data["operatorId"];
              this.operatorName = _data["operatorName"];
              this.sellerProductId = _data["sellerProductId"];
              this.sellerProduct = _data["sellerProduct"] ? SellerProduct.fromJS(_data["sellerProduct"]) : <any>undefined;
              if (Array.isArray(_data["comments"])) {
                  this.comments = [] as any;
                  for (let item of _data["comments"])
                      this.comments!.push(Comment.fromJS(item));
              }
              this.prevStatus = _data["prevStatus"];
              this.status = _data["status"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): ProductPublicationRequest {
          data = typeof data === 'object' ? data : {};
          let result = new ProductPublicationRequest();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["storeId"] = this.storeId;
          data["storeName"] = this.storeName;
          data["sellerId"] = this.sellerId;
          data["sellerName"] = this.sellerName;
          data["operatorId"] = this.operatorId;
          data["operatorName"] = this.operatorName;
          data["sellerProductId"] = this.sellerProductId;
          data["sellerProduct"] = this.sellerProduct ? this.sellerProduct.toJSON() : <any>undefined;
          if (Array.isArray(this.comments)) {
              data["comments"] = [];
              for (let item of this.comments)
                  data["comments"].push(item.toJSON());
          }
          data["prevStatus"] = this.prevStatus;
          data["status"] = this.status;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IProductPublicationRequest {
      storeId?: string | undefined;
      storeName?: string | undefined;
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      operatorId?: string | undefined;
      operatorName?: string | undefined;
      sellerProductId?: string | undefined;
      sellerProduct?: SellerProduct;
      comments?: Comment[] | undefined;
      prevStatus?: PublicationRequestStatus;
      status?: PublicationRequestStatus;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class ProductPublication implements IProductPublication {
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      storeId?: string | undefined;
      storeName?: string | undefined;
      publicationRequestId?: string | undefined;
      publicationRequest?: ProductPublicationRequest;
      isActive?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IProductPublication) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerId = _data["sellerId"];
              this.sellerName = _data["sellerName"];
              this.storeId = _data["storeId"];
              this.storeName = _data["storeName"];
              this.publicationRequestId = _data["publicationRequestId"];
              this.publicationRequest = _data["publicationRequest"] ? ProductPublicationRequest.fromJS(_data["publicationRequest"]) : <any>undefined;
              this.isActive = _data["isActive"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): ProductPublication {
          data = typeof data === 'object' ? data : {};
          let result = new ProductPublication();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerId"] = this.sellerId;
          data["sellerName"] = this.sellerName;
          data["storeId"] = this.storeId;
          data["storeName"] = this.storeName;
          data["publicationRequestId"] = this.publicationRequestId;
          data["publicationRequest"] = this.publicationRequest ? this.publicationRequest.toJSON() : <any>undefined;
          data["isActive"] = this.isActive;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IProductPublication {
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      storeId?: string | undefined;
      storeName?: string | undefined;
      publicationRequestId?: string | undefined;
      publicationRequest?: ProductPublicationRequest;
      isActive?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class ProductPartItemInfo implements IProductPartItemInfo {
      itemId?: string | undefined;
      priority?: number;
  
      constructor(data?: IProductPartItemInfo) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.itemId = _data["itemId"];
              this.priority = _data["priority"];
          }
      }
  
      static fromJS(data: any): ProductPartItemInfo {
          data = typeof data === 'object' ? data : {};
          let result = new ProductPartItemInfo();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["itemId"] = this.itemId;
          data["priority"] = this.priority;
          return data; 
      }
  }
  
  export interface IProductPartItemInfo {
      itemId?: string | undefined;
      priority?: number;
  }
  
  export class DemoProductPart implements IDemoProductPart {
      configuredProductId?: string | undefined;
      name?: string | undefined;
      description?: string | undefined;
      isRequired?: boolean;
      imgSrc?: string | undefined;
      priority?: number;
      minQuantity?: number;
      maxQuantity?: number;
      defaultItemId?: string | undefined;
      partItems?: ProductPartItemInfo[] | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IDemoProductPart) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.configuredProductId = _data["configuredProductId"];
              this.name = _data["name"];
              this.description = _data["description"];
              this.isRequired = _data["isRequired"];
              this.imgSrc = _data["imgSrc"];
              this.priority = _data["priority"];
              this.minQuantity = _data["minQuantity"];
              this.maxQuantity = _data["maxQuantity"];
              this.defaultItemId = _data["defaultItemId"];
              if (Array.isArray(_data["partItems"])) {
                  this.partItems = [] as any;
                  for (let item of _data["partItems"])
                      this.partItems!.push(ProductPartItemInfo.fromJS(item));
              }
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): DemoProductPart {
          data = typeof data === 'object' ? data : {};
          let result = new DemoProductPart();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["configuredProductId"] = this.configuredProductId;
          data["name"] = this.name;
          data["description"] = this.description;
          data["isRequired"] = this.isRequired;
          data["imgSrc"] = this.imgSrc;
          data["priority"] = this.priority;
          data["minQuantity"] = this.minQuantity;
          data["maxQuantity"] = this.maxQuantity;
          data["defaultItemId"] = this.defaultItemId;
          if (Array.isArray(this.partItems)) {
              data["partItems"] = [];
              for (let item of this.partItems)
                  data["partItems"].push(item.toJSON());
          }
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IDemoProductPart {
      configuredProductId?: string | undefined;
      name?: string | undefined;
      description?: string | undefined;
      isRequired?: boolean;
      imgSrc?: string | undefined;
      priority?: number;
      minQuantity?: number;
      maxQuantity?: number;
      defaultItemId?: string | undefined;
      partItems?: ProductPartItemInfo[] | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class Asset implements IAsset {
      mimeType?: string | undefined;
      size?: number;
      readonly readableSize?: string | undefined;
      binaryData?: string | undefined;
      relativeUrl?: string | undefined;
      url?: string | undefined;
      description?: string | undefined;
      sortOrder?: number;
      /** Gets or sets the asset type identifier. */
      typeId?: string | undefined;
      /** Gets or sets the asset group name. */
      group?: string | undefined;
      /** Gets or sets the asset name. */
      name?: string | undefined;
      outerId?: string | undefined;
      /** Gets or sets the asset language. */
      languageCode?: string | undefined;
      /** System flag used to mark that object was inherited from other */
      readonly isInherited?: boolean;
      readonly seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IAsset) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.mimeType = _data["mimeType"];
              this.size = _data["size"];
              (<any>this).readableSize = _data["readableSize"];
              this.binaryData = _data["binaryData"];
              this.relativeUrl = _data["relativeUrl"];
              this.url = _data["url"];
              this.description = _data["description"];
              this.sortOrder = _data["sortOrder"];
              this.typeId = _data["typeId"];
              this.group = _data["group"];
              this.name = _data["name"];
              this.outerId = _data["outerId"];
              this.languageCode = _data["languageCode"];
              (<any>this).isInherited = _data["isInherited"];
              (<any>this).seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Asset {
          data = typeof data === 'object' ? data : {};
          let result = new Asset();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["mimeType"] = this.mimeType;
          data["size"] = this.size;
          data["readableSize"] = this.readableSize;
          data["binaryData"] = this.binaryData;
          data["relativeUrl"] = this.relativeUrl;
          data["url"] = this.url;
          data["description"] = this.description;
          data["sortOrder"] = this.sortOrder;
          data["typeId"] = this.typeId;
          data["group"] = this.group;
          data["name"] = this.name;
          data["outerId"] = this.outerId;
          data["languageCode"] = this.languageCode;
          data["isInherited"] = this.isInherited;
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IAsset {
      mimeType?: string | undefined;
      size?: number;
      readableSize?: string | undefined;
      binaryData?: string | undefined;
      relativeUrl?: string | undefined;
      url?: string | undefined;
      description?: string | undefined;
      sortOrder?: number;
      /** Gets or sets the asset type identifier. */
      typeId?: string | undefined;
      /** Gets or sets the asset group name. */
      group?: string | undefined;
      /** Gets or sets the asset name. */
      name?: string | undefined;
      outerId?: string | undefined;
      /** Gets or sets the asset language. */
      languageCode?: string | undefined;
      /** System flag used to mark that object was inherited from other */
      isInherited?: boolean;
      seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class EditorialReview implements IEditorialReview {
      content?: string | undefined;
      reviewType?: string | undefined;
      languageCode?: string | undefined;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IEditorialReview) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.content = _data["content"];
              this.reviewType = _data["reviewType"];
              this.languageCode = _data["languageCode"];
              this.isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): EditorialReview {
          data = typeof data === 'object' ? data : {};
          let result = new EditorialReview();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["content"] = this.content;
          data["reviewType"] = this.reviewType;
          data["languageCode"] = this.languageCode;
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IEditorialReview {
      content?: string | undefined;
      reviewType?: string | undefined;
      languageCode?: string | undefined;
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class ProductAssociation implements IProductAssociation {
      /** Association type (Accessories, Up-Sales, Cross-Sales, Related etc) */
      type?: string | undefined;
      priority?: number;
      quantity?: number | undefined;
      /** Is a primary key of associating object */
      itemId?: string | undefined;
      /** Each link element can have an associated object like Product, Category, etc.
  Is a primary key of associated object */
      associatedObjectId?: string | undefined;
      /** Associated object type : 'product', 'category' etc */
      associatedObjectType?: string | undefined;
      outerId?: string | undefined;
      /** Display name for associated object */
      readonly associatedObjectName?: string | undefined;
      /** Associated object image URL */
      readonly associatedObjectImg?: string | undefined;
      tags?: string[] | undefined;
      readonly imgSrc?: string | undefined;
      images?: Image[] | undefined;
      id?: string | undefined;
  
      constructor(data?: IProductAssociation) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.type = _data["type"];
              this.priority = _data["priority"];
              this.quantity = _data["quantity"];
              this.itemId = _data["itemId"];
              this.associatedObjectId = _data["associatedObjectId"];
              this.associatedObjectType = _data["associatedObjectType"];
              this.outerId = _data["outerId"];
              (<any>this).associatedObjectName = _data["associatedObjectName"];
              (<any>this).associatedObjectImg = _data["associatedObjectImg"];
              if (Array.isArray(_data["tags"])) {
                  this.tags = [] as any;
                  for (let item of _data["tags"])
                      this.tags!.push(item);
              }
              (<any>this).imgSrc = _data["imgSrc"];
              if (Array.isArray(_data["images"])) {
                  this.images = [] as any;
                  for (let item of _data["images"])
                      this.images!.push(Image.fromJS(item));
              }
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): ProductAssociation {
          data = typeof data === 'object' ? data : {};
          let result = new ProductAssociation();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["type"] = this.type;
          data["priority"] = this.priority;
          data["quantity"] = this.quantity;
          data["itemId"] = this.itemId;
          data["associatedObjectId"] = this.associatedObjectId;
          data["associatedObjectType"] = this.associatedObjectType;
          data["outerId"] = this.outerId;
          data["associatedObjectName"] = this.associatedObjectName;
          data["associatedObjectImg"] = this.associatedObjectImg;
          if (Array.isArray(this.tags)) {
              data["tags"] = [];
              for (let item of this.tags)
                  data["tags"].push(item);
          }
          data["imgSrc"] = this.imgSrc;
          if (Array.isArray(this.images)) {
              data["images"] = [];
              for (let item of this.images)
                  data["images"].push(item.toJSON());
          }
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IProductAssociation {
      /** Association type (Accessories, Up-Sales, Cross-Sales, Related etc) */
      type?: string | undefined;
      priority?: number;
      quantity?: number | undefined;
      /** Is a primary key of associating object */
      itemId?: string | undefined;
      /** Each link element can have an associated object like Product, Category, etc.
  Is a primary key of associated object */
      associatedObjectId?: string | undefined;
      /** Associated object type : 'product', 'category' etc */
      associatedObjectType?: string | undefined;
      outerId?: string | undefined;
      /** Display name for associated object */
      associatedObjectName?: string | undefined;
      /** Associated object image URL */
      associatedObjectImg?: string | undefined;
      tags?: string[] | undefined;
      imgSrc?: string | undefined;
      images?: Image[] | undefined;
      id?: string | undefined;
  }
  
  export class Variation implements IVariation {
      /** SKU code */
      code?: string | undefined;
      manufacturerPartNumber?: string | undefined;
      /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
      gtin?: string | undefined;
      name?: string | undefined;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      readonly outline?: string | undefined;
      /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      readonly path?: string | undefined;
      readonly titularItemId?: string | undefined;
      mainProductId?: string | undefined;
      isBuyable?: boolean | undefined;
      isActive?: boolean | undefined;
      trackInventory?: boolean | undefined;
      indexingDate?: Date | undefined;
      maxQuantity?: number | undefined;
      minQuantity?: number | undefined;
      /** Can be Physical, Digital or Subscription. */
      productType?: string | undefined;
      packageType?: string | undefined;
      weightUnit?: string | undefined;
      weight?: number | undefined;
      measureUnit?: string | undefined;
      height?: number | undefined;
      length?: number | undefined;
      width?: number | undefined;
      enableReview?: boolean | undefined;
      /** re-downloads limit */
      maxNumberOfDownload?: number | undefined;
      downloadExpiration?: Date | undefined;
      /** DownloadType: {Standard Product, Software, Music} */
      downloadType?: string | undefined;
      hasUserAgreement?: boolean | undefined;
      shippingType?: string | undefined;
      taxType?: string | undefined;
      vendor?: string | undefined;
      startDate?: Date;
      endDate?: Date | undefined;
      /** Product order position in catalog */
      priority?: number;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      propertyValues?: PropertyValue[] | undefined;
      /** Gets the default image for the product. */
      readonly imgSrc?: string | undefined;
      images?: Image[] | undefined;
      assets?: Asset[] | undefined;
      links?: CategoryLink[] | undefined;
      variations?: Variation[] | undefined;
      /** Each descendant type should override this property to use other object type for seo records */
      readonly seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      reviews?: EditorialReview[] | undefined;
      associations?: ProductAssociation[] | undefined;
      referencedAssociations?: ProductAssociation[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      readonly isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IVariation) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.code = _data["code"];
              this.manufacturerPartNumber = _data["manufacturerPartNumber"];
              this.gtin = _data["gtin"];
              this.name = _data["name"];
              this.catalogId = _data["catalogId"];
              this.categoryId = _data["categoryId"];
              (<any>this).outline = _data["outline"];
              (<any>this).path = _data["path"];
              (<any>this).titularItemId = _data["titularItemId"];
              this.mainProductId = _data["mainProductId"];
              this.isBuyable = _data["isBuyable"];
              this.isActive = _data["isActive"];
              this.trackInventory = _data["trackInventory"];
              this.indexingDate = _data["indexingDate"] ? new Date(_data["indexingDate"].toString()) : <any>undefined;
              this.maxQuantity = _data["maxQuantity"];
              this.minQuantity = _data["minQuantity"];
              this.productType = _data["productType"];
              this.packageType = _data["packageType"];
              this.weightUnit = _data["weightUnit"];
              this.weight = _data["weight"];
              this.measureUnit = _data["measureUnit"];
              this.height = _data["height"];
              this.length = _data["length"];
              this.width = _data["width"];
              this.enableReview = _data["enableReview"];
              this.maxNumberOfDownload = _data["maxNumberOfDownload"];
              this.downloadExpiration = _data["downloadExpiration"] ? new Date(_data["downloadExpiration"].toString()) : <any>undefined;
              this.downloadType = _data["downloadType"];
              this.hasUserAgreement = _data["hasUserAgreement"];
              this.shippingType = _data["shippingType"];
              this.taxType = _data["taxType"];
              this.vendor = _data["vendor"];
              this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
              this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
              this.priority = _data["priority"];
              this.outerId = _data["outerId"];
              if (Array.isArray(_data["properties"])) {
                  this.properties = [] as any;
                  for (let item of _data["properties"])
                      this.properties!.push(Property.fromJS(item));
              }
              if (Array.isArray(_data["excludedProperties"])) {
                  this.excludedProperties = [] as any;
                  for (let item of _data["excludedProperties"])
                      this.excludedProperties!.push(ExcludedProperty.fromJS(item));
              }
              if (Array.isArray(_data["propertyValues"])) {
                  this.propertyValues = [] as any;
                  for (let item of _data["propertyValues"])
                      this.propertyValues!.push(PropertyValue.fromJS(item));
              }
              (<any>this).imgSrc = _data["imgSrc"];
              if (Array.isArray(_data["images"])) {
                  this.images = [] as any;
                  for (let item of _data["images"])
                      this.images!.push(Image.fromJS(item));
              }
              if (Array.isArray(_data["assets"])) {
                  this.assets = [] as any;
                  for (let item of _data["assets"])
                      this.assets!.push(Asset.fromJS(item));
              }
              if (Array.isArray(_data["links"])) {
                  this.links = [] as any;
                  for (let item of _data["links"])
                      this.links!.push(CategoryLink.fromJS(item));
              }
              if (Array.isArray(_data["variations"])) {
                  this.variations = [] as any;
                  for (let item of _data["variations"])
                      this.variations!.push(Variation.fromJS(item));
              }
              (<any>this).seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              if (Array.isArray(_data["reviews"])) {
                  this.reviews = [] as any;
                  for (let item of _data["reviews"])
                      this.reviews!.push(EditorialReview.fromJS(item));
              }
              if (Array.isArray(_data["associations"])) {
                  this.associations = [] as any;
                  for (let item of _data["associations"])
                      this.associations!.push(ProductAssociation.fromJS(item));
              }
              if (Array.isArray(_data["referencedAssociations"])) {
                  this.referencedAssociations = [] as any;
                  for (let item of _data["referencedAssociations"])
                      this.referencedAssociations!.push(ProductAssociation.fromJS(item));
              }
              if (Array.isArray(_data["outlines"])) {
                  this.outlines = [] as any;
                  for (let item of _data["outlines"])
                      this.outlines!.push(Outline.fromJS(item));
              }
              (<any>this).isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Variation {
          data = typeof data === 'object' ? data : {};
          let result = new Variation();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["code"] = this.code;
          data["manufacturerPartNumber"] = this.manufacturerPartNumber;
          data["gtin"] = this.gtin;
          data["name"] = this.name;
          data["catalogId"] = this.catalogId;
          data["categoryId"] = this.categoryId;
          data["outline"] = this.outline;
          data["path"] = this.path;
          data["titularItemId"] = this.titularItemId;
          data["mainProductId"] = this.mainProductId;
          data["isBuyable"] = this.isBuyable;
          data["isActive"] = this.isActive;
          data["trackInventory"] = this.trackInventory;
          data["indexingDate"] = this.indexingDate ? this.indexingDate.toISOString() : <any>undefined;
          data["maxQuantity"] = this.maxQuantity;
          data["minQuantity"] = this.minQuantity;
          data["productType"] = this.productType;
          data["packageType"] = this.packageType;
          data["weightUnit"] = this.weightUnit;
          data["weight"] = this.weight;
          data["measureUnit"] = this.measureUnit;
          data["height"] = this.height;
          data["length"] = this.length;
          data["width"] = this.width;
          data["enableReview"] = this.enableReview;
          data["maxNumberOfDownload"] = this.maxNumberOfDownload;
          data["downloadExpiration"] = this.downloadExpiration ? this.downloadExpiration.toISOString() : <any>undefined;
          data["downloadType"] = this.downloadType;
          data["hasUserAgreement"] = this.hasUserAgreement;
          data["shippingType"] = this.shippingType;
          data["taxType"] = this.taxType;
          data["vendor"] = this.vendor;
          data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
          data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
          data["priority"] = this.priority;
          data["outerId"] = this.outerId;
          if (Array.isArray(this.properties)) {
              data["properties"] = [];
              for (let item of this.properties)
                  data["properties"].push(item.toJSON());
          }
          if (Array.isArray(this.excludedProperties)) {
              data["excludedProperties"] = [];
              for (let item of this.excludedProperties)
                  data["excludedProperties"].push(item.toJSON());
          }
          if (Array.isArray(this.propertyValues)) {
              data["propertyValues"] = [];
              for (let item of this.propertyValues)
                  data["propertyValues"].push(item.toJSON());
          }
          data["imgSrc"] = this.imgSrc;
          if (Array.isArray(this.images)) {
              data["images"] = [];
              for (let item of this.images)
                  data["images"].push(item.toJSON());
          }
          if (Array.isArray(this.assets)) {
              data["assets"] = [];
              for (let item of this.assets)
                  data["assets"].push(item.toJSON());
          }
          if (Array.isArray(this.links)) {
              data["links"] = [];
              for (let item of this.links)
                  data["links"].push(item.toJSON());
          }
          if (Array.isArray(this.variations)) {
              data["variations"] = [];
              for (let item of this.variations)
                  data["variations"].push(item.toJSON());
          }
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          if (Array.isArray(this.reviews)) {
              data["reviews"] = [];
              for (let item of this.reviews)
                  data["reviews"].push(item.toJSON());
          }
          if (Array.isArray(this.associations)) {
              data["associations"] = [];
              for (let item of this.associations)
                  data["associations"].push(item.toJSON());
          }
          if (Array.isArray(this.referencedAssociations)) {
              data["referencedAssociations"] = [];
              for (let item of this.referencedAssociations)
                  data["referencedAssociations"].push(item.toJSON());
          }
          if (Array.isArray(this.outlines)) {
              data["outlines"] = [];
              for (let item of this.outlines)
                  data["outlines"].push(item.toJSON());
          }
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IVariation {
      /** SKU code */
      code?: string | undefined;
      manufacturerPartNumber?: string | undefined;
      /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
      gtin?: string | undefined;
      name?: string | undefined;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      outline?: string | undefined;
      /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      path?: string | undefined;
      titularItemId?: string | undefined;
      mainProductId?: string | undefined;
      isBuyable?: boolean | undefined;
      isActive?: boolean | undefined;
      trackInventory?: boolean | undefined;
      indexingDate?: Date | undefined;
      maxQuantity?: number | undefined;
      minQuantity?: number | undefined;
      /** Can be Physical, Digital or Subscription. */
      productType?: string | undefined;
      packageType?: string | undefined;
      weightUnit?: string | undefined;
      weight?: number | undefined;
      measureUnit?: string | undefined;
      height?: number | undefined;
      length?: number | undefined;
      width?: number | undefined;
      enableReview?: boolean | undefined;
      /** re-downloads limit */
      maxNumberOfDownload?: number | undefined;
      downloadExpiration?: Date | undefined;
      /** DownloadType: {Standard Product, Software, Music} */
      downloadType?: string | undefined;
      hasUserAgreement?: boolean | undefined;
      shippingType?: string | undefined;
      taxType?: string | undefined;
      vendor?: string | undefined;
      startDate?: Date;
      endDate?: Date | undefined;
      /** Product order position in catalog */
      priority?: number;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      propertyValues?: PropertyValue[] | undefined;
      /** Gets the default image for the product. */
      imgSrc?: string | undefined;
      images?: Image[] | undefined;
      assets?: Asset[] | undefined;
      links?: CategoryLink[] | undefined;
      variations?: Variation[] | undefined;
      /** Each descendant type should override this property to use other object type for seo records */
      seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      reviews?: EditorialReview[] | undefined;
      associations?: ProductAssociation[] | undefined;
      referencedAssociations?: ProductAssociation[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class CatalogProduct implements ICatalogProduct {
      productParts?: DemoProductPart[] | undefined;
      /** SKU code */
      code?: string | undefined;
      manufacturerPartNumber?: string | undefined;
      /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
      gtin?: string | undefined;
      name?: string | undefined;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      readonly outline?: string | undefined;
      /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      readonly path?: string | undefined;
      readonly titularItemId?: string | undefined;
      mainProductId?: string | undefined;
      isBuyable?: boolean | undefined;
      isActive?: boolean | undefined;
      trackInventory?: boolean | undefined;
      indexingDate?: Date | undefined;
      maxQuantity?: number | undefined;
      minQuantity?: number | undefined;
      /** Can be Physical, Digital or Subscription. */
      productType?: string | undefined;
      packageType?: string | undefined;
      weightUnit?: string | undefined;
      weight?: number | undefined;
      measureUnit?: string | undefined;
      height?: number | undefined;
      length?: number | undefined;
      width?: number | undefined;
      enableReview?: boolean | undefined;
      /** re-downloads limit */
      maxNumberOfDownload?: number | undefined;
      downloadExpiration?: Date | undefined;
      /** DownloadType: {Standard Product, Software, Music} */
      downloadType?: string | undefined;
      hasUserAgreement?: boolean | undefined;
      shippingType?: string | undefined;
      taxType?: string | undefined;
      vendor?: string | undefined;
      startDate?: Date;
      endDate?: Date | undefined;
      /** Product order position in catalog */
      priority?: number;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      propertyValues?: PropertyValue[] | undefined;
      /** Gets the default image for the product. */
      readonly imgSrc?: string | undefined;
      images?: Image[] | undefined;
      assets?: Asset[] | undefined;
      links?: CategoryLink[] | undefined;
      variations?: Variation[] | undefined;
      /** Each descendant type should override this property to use other object type for seo records */
      readonly seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      reviews?: EditorialReview[] | undefined;
      associations?: ProductAssociation[] | undefined;
      referencedAssociations?: ProductAssociation[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      readonly isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: ICatalogProduct) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              if (Array.isArray(_data["productParts"])) {
                  this.productParts = [] as any;
                  for (let item of _data["productParts"])
                      this.productParts!.push(DemoProductPart.fromJS(item));
              }
              this.code = _data["code"];
              this.manufacturerPartNumber = _data["manufacturerPartNumber"];
              this.gtin = _data["gtin"];
              this.name = _data["name"];
              this.catalogId = _data["catalogId"];
              this.categoryId = _data["categoryId"];
              (<any>this).outline = _data["outline"];
              (<any>this).path = _data["path"];
              (<any>this).titularItemId = _data["titularItemId"];
              this.mainProductId = _data["mainProductId"];
              this.isBuyable = _data["isBuyable"];
              this.isActive = _data["isActive"];
              this.trackInventory = _data["trackInventory"];
              this.indexingDate = _data["indexingDate"] ? new Date(_data["indexingDate"].toString()) : <any>undefined;
              this.maxQuantity = _data["maxQuantity"];
              this.minQuantity = _data["minQuantity"];
              this.productType = _data["productType"];
              this.packageType = _data["packageType"];
              this.weightUnit = _data["weightUnit"];
              this.weight = _data["weight"];
              this.measureUnit = _data["measureUnit"];
              this.height = _data["height"];
              this.length = _data["length"];
              this.width = _data["width"];
              this.enableReview = _data["enableReview"];
              this.maxNumberOfDownload = _data["maxNumberOfDownload"];
              this.downloadExpiration = _data["downloadExpiration"] ? new Date(_data["downloadExpiration"].toString()) : <any>undefined;
              this.downloadType = _data["downloadType"];
              this.hasUserAgreement = _data["hasUserAgreement"];
              this.shippingType = _data["shippingType"];
              this.taxType = _data["taxType"];
              this.vendor = _data["vendor"];
              this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
              this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
              this.priority = _data["priority"];
              this.outerId = _data["outerId"];
              if (Array.isArray(_data["properties"])) {
                  this.properties = [] as any;
                  for (let item of _data["properties"])
                      this.properties!.push(Property.fromJS(item));
              }
              if (Array.isArray(_data["excludedProperties"])) {
                  this.excludedProperties = [] as any;
                  for (let item of _data["excludedProperties"])
                      this.excludedProperties!.push(ExcludedProperty.fromJS(item));
              }
              if (Array.isArray(_data["propertyValues"])) {
                  this.propertyValues = [] as any;
                  for (let item of _data["propertyValues"])
                      this.propertyValues!.push(PropertyValue.fromJS(item));
              }
              (<any>this).imgSrc = _data["imgSrc"];
              if (Array.isArray(_data["images"])) {
                  this.images = [] as any;
                  for (let item of _data["images"])
                      this.images!.push(Image.fromJS(item));
              }
              if (Array.isArray(_data["assets"])) {
                  this.assets = [] as any;
                  for (let item of _data["assets"])
                      this.assets!.push(Asset.fromJS(item));
              }
              if (Array.isArray(_data["links"])) {
                  this.links = [] as any;
                  for (let item of _data["links"])
                      this.links!.push(CategoryLink.fromJS(item));
              }
              if (Array.isArray(_data["variations"])) {
                  this.variations = [] as any;
                  for (let item of _data["variations"])
                      this.variations!.push(Variation.fromJS(item));
              }
              (<any>this).seoObjectType = _data["seoObjectType"];
              if (Array.isArray(_data["seoInfos"])) {
                  this.seoInfos = [] as any;
                  for (let item of _data["seoInfos"])
                      this.seoInfos!.push(SeoInfo.fromJS(item));
              }
              if (Array.isArray(_data["reviews"])) {
                  this.reviews = [] as any;
                  for (let item of _data["reviews"])
                      this.reviews!.push(EditorialReview.fromJS(item));
              }
              if (Array.isArray(_data["associations"])) {
                  this.associations = [] as any;
                  for (let item of _data["associations"])
                      this.associations!.push(ProductAssociation.fromJS(item));
              }
              if (Array.isArray(_data["referencedAssociations"])) {
                  this.referencedAssociations = [] as any;
                  for (let item of _data["referencedAssociations"])
                      this.referencedAssociations!.push(ProductAssociation.fromJS(item));
              }
              if (Array.isArray(_data["outlines"])) {
                  this.outlines = [] as any;
                  for (let item of _data["outlines"])
                      this.outlines!.push(Outline.fromJS(item));
              }
              (<any>this).isInherited = _data["isInherited"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): CatalogProduct {
          data = typeof data === 'object' ? data : {};
          let result = new CatalogProduct();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          if (Array.isArray(this.productParts)) {
              data["productParts"] = [];
              for (let item of this.productParts)
                  data["productParts"].push(item.toJSON());
          }
          data["code"] = this.code;
          data["manufacturerPartNumber"] = this.manufacturerPartNumber;
          data["gtin"] = this.gtin;
          data["name"] = this.name;
          data["catalogId"] = this.catalogId;
          data["categoryId"] = this.categoryId;
          data["outline"] = this.outline;
          data["path"] = this.path;
          data["titularItemId"] = this.titularItemId;
          data["mainProductId"] = this.mainProductId;
          data["isBuyable"] = this.isBuyable;
          data["isActive"] = this.isActive;
          data["trackInventory"] = this.trackInventory;
          data["indexingDate"] = this.indexingDate ? this.indexingDate.toISOString() : <any>undefined;
          data["maxQuantity"] = this.maxQuantity;
          data["minQuantity"] = this.minQuantity;
          data["productType"] = this.productType;
          data["packageType"] = this.packageType;
          data["weightUnit"] = this.weightUnit;
          data["weight"] = this.weight;
          data["measureUnit"] = this.measureUnit;
          data["height"] = this.height;
          data["length"] = this.length;
          data["width"] = this.width;
          data["enableReview"] = this.enableReview;
          data["maxNumberOfDownload"] = this.maxNumberOfDownload;
          data["downloadExpiration"] = this.downloadExpiration ? this.downloadExpiration.toISOString() : <any>undefined;
          data["downloadType"] = this.downloadType;
          data["hasUserAgreement"] = this.hasUserAgreement;
          data["shippingType"] = this.shippingType;
          data["taxType"] = this.taxType;
          data["vendor"] = this.vendor;
          data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
          data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
          data["priority"] = this.priority;
          data["outerId"] = this.outerId;
          if (Array.isArray(this.properties)) {
              data["properties"] = [];
              for (let item of this.properties)
                  data["properties"].push(item.toJSON());
          }
          if (Array.isArray(this.excludedProperties)) {
              data["excludedProperties"] = [];
              for (let item of this.excludedProperties)
                  data["excludedProperties"].push(item.toJSON());
          }
          if (Array.isArray(this.propertyValues)) {
              data["propertyValues"] = [];
              for (let item of this.propertyValues)
                  data["propertyValues"].push(item.toJSON());
          }
          data["imgSrc"] = this.imgSrc;
          if (Array.isArray(this.images)) {
              data["images"] = [];
              for (let item of this.images)
                  data["images"].push(item.toJSON());
          }
          if (Array.isArray(this.assets)) {
              data["assets"] = [];
              for (let item of this.assets)
                  data["assets"].push(item.toJSON());
          }
          if (Array.isArray(this.links)) {
              data["links"] = [];
              for (let item of this.links)
                  data["links"].push(item.toJSON());
          }
          if (Array.isArray(this.variations)) {
              data["variations"] = [];
              for (let item of this.variations)
                  data["variations"].push(item.toJSON());
          }
          data["seoObjectType"] = this.seoObjectType;
          if (Array.isArray(this.seoInfos)) {
              data["seoInfos"] = [];
              for (let item of this.seoInfos)
                  data["seoInfos"].push(item.toJSON());
          }
          if (Array.isArray(this.reviews)) {
              data["reviews"] = [];
              for (let item of this.reviews)
                  data["reviews"].push(item.toJSON());
          }
          if (Array.isArray(this.associations)) {
              data["associations"] = [];
              for (let item of this.associations)
                  data["associations"].push(item.toJSON());
          }
          if (Array.isArray(this.referencedAssociations)) {
              data["referencedAssociations"] = [];
              for (let item of this.referencedAssociations)
                  data["referencedAssociations"].push(item.toJSON());
          }
          if (Array.isArray(this.outlines)) {
              data["outlines"] = [];
              for (let item of this.outlines)
                  data["outlines"].push(item.toJSON());
          }
          data["isInherited"] = this.isInherited;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface ICatalogProduct {
      productParts?: DemoProductPart[] | undefined;
      /** SKU code */
      code?: string | undefined;
      manufacturerPartNumber?: string | undefined;
      /** Global Trade Item Number (GTIN). These identifiers include UPC (in North America), EAN (in Europe), JAN (in Japan), and ISBN (for books). */
      gtin?: string | undefined;
      name?: string | undefined;
      catalogId?: string | undefined;
      categoryId?: string | undefined;
      /** Product outline in physical catalog (all parent categories ids concatenated. E.g. (1/21/344)) */
      outline?: string | undefined;
      /** Product path in physical catalog (all parent categories names concatenated. E.g. (parent1/parent2)) */
      path?: string | undefined;
      titularItemId?: string | undefined;
      mainProductId?: string | undefined;
      isBuyable?: boolean | undefined;
      isActive?: boolean | undefined;
      trackInventory?: boolean | undefined;
      indexingDate?: Date | undefined;
      maxQuantity?: number | undefined;
      minQuantity?: number | undefined;
      /** Can be Physical, Digital or Subscription. */
      productType?: string | undefined;
      packageType?: string | undefined;
      weightUnit?: string | undefined;
      weight?: number | undefined;
      measureUnit?: string | undefined;
      height?: number | undefined;
      length?: number | undefined;
      width?: number | undefined;
      enableReview?: boolean | undefined;
      /** re-downloads limit */
      maxNumberOfDownload?: number | undefined;
      downloadExpiration?: Date | undefined;
      /** DownloadType: {Standard Product, Software, Music} */
      downloadType?: string | undefined;
      hasUserAgreement?: boolean | undefined;
      shippingType?: string | undefined;
      taxType?: string | undefined;
      vendor?: string | undefined;
      startDate?: Date;
      endDate?: Date | undefined;
      /** Product order position in catalog */
      priority?: number;
      outerId?: string | undefined;
      properties?: Property[] | undefined;
      excludedProperties?: ExcludedProperty[] | undefined;
      propertyValues?: PropertyValue[] | undefined;
      /** Gets the default image for the product. */
      imgSrc?: string | undefined;
      images?: Image[] | undefined;
      assets?: Asset[] | undefined;
      links?: CategoryLink[] | undefined;
      variations?: Variation[] | undefined;
      /** Each descendant type should override this property to use other object type for seo records */
      seoObjectType?: string | undefined;
      seoInfos?: SeoInfo[] | undefined;
      reviews?: EditorialReview[] | undefined;
      associations?: ProductAssociation[] | undefined;
      referencedAssociations?: ProductAssociation[] | undefined;
      outlines?: Outline[] | undefined;
      /** System flag used to mark that object was inherited from other */
      isInherited?: boolean;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class SellerProduct implements ISellerProduct {
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      name?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      readonly outline?: string | undefined;
      readonly description?: string | undefined;
      hasStagedChanges?: boolean;
      isPublished?: boolean;
      status?: SellerProductStatus;
      readonly canBeModified?: boolean;
      publications?: ProductPublication[] | undefined;
      outerId?: string | undefined;
      productData?: CatalogProduct;
      publishedProductDataId?: string | undefined;
      stagedProductDataId?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: ISellerProduct) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerId = _data["sellerId"];
              this.sellerName = _data["sellerName"];
              this.name = _data["name"];
              this.imgSrc = _data["imgSrc"];
              this.categoryId = _data["categoryId"];
              this.path = _data["path"];
              (<any>this).outline = _data["outline"];
              (<any>this).description = _data["description"];
              this.hasStagedChanges = _data["hasStagedChanges"];
              this.isPublished = _data["isPublished"];
              this.status = _data["status"];
              (<any>this).canBeModified = _data["canBeModified"];
              if (Array.isArray(_data["publications"])) {
                  this.publications = [] as any;
                  for (let item of _data["publications"])
                      this.publications!.push(ProductPublication.fromJS(item));
              }
              this.outerId = _data["outerId"];
              this.productData = _data["productData"] ? CatalogProduct.fromJS(_data["productData"]) : <any>undefined;
              this.publishedProductDataId = _data["publishedProductDataId"];
              this.stagedProductDataId = _data["stagedProductDataId"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): SellerProduct {
          data = typeof data === 'object' ? data : {};
          let result = new SellerProduct();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerId"] = this.sellerId;
          data["sellerName"] = this.sellerName;
          data["name"] = this.name;
          data["imgSrc"] = this.imgSrc;
          data["categoryId"] = this.categoryId;
          data["path"] = this.path;
          data["outline"] = this.outline;
          data["description"] = this.description;
          data["hasStagedChanges"] = this.hasStagedChanges;
          data["isPublished"] = this.isPublished;
          data["status"] = this.status;
          data["canBeModified"] = this.canBeModified;
          if (Array.isArray(this.publications)) {
              data["publications"] = [];
              for (let item of this.publications)
                  data["publications"].push(item.toJSON());
          }
          data["outerId"] = this.outerId;
          data["productData"] = this.productData ? this.productData.toJSON() : <any>undefined;
          data["publishedProductDataId"] = this.publishedProductDataId;
          data["stagedProductDataId"] = this.stagedProductDataId;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface ISellerProduct {
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      name?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      outline?: string | undefined;
      description?: string | undefined;
      hasStagedChanges?: boolean;
      isPublished?: boolean;
      status?: SellerProductStatus;
      canBeModified?: boolean;
      publications?: ProductPublication[] | undefined;
      outerId?: string | undefined;
      productData?: CatalogProduct;
      publishedProductDataId?: string | undefined;
      stagedProductDataId?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class SearchProductsResult implements ISearchProductsResult {
      totalCount?: number;
      results?: SellerProduct[] | undefined;
  
      constructor(data?: ISearchProductsResult) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.totalCount = _data["totalCount"];
              if (Array.isArray(_data["results"])) {
                  this.results = [] as any;
                  for (let item of _data["results"])
                      this.results!.push(SellerProduct.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): SearchProductsResult {
          data = typeof data === 'object' ? data : {};
          let result = new SearchProductsResult();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["totalCount"] = this.totalCount;
          if (Array.isArray(this.results)) {
              data["results"] = [];
              for (let item of this.results)
                  data["results"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface ISearchProductsResult {
      totalCount?: number;
      results?: SellerProduct[] | undefined;
  }
  
  /** Search criteria used for search property dictionary items */
  export class PropertyDictionaryItemSearchCriteria implements IPropertyDictionaryItemSearchCriteria {
      propertyIds?: string[] | undefined;
      catalogIds?: string[] | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      readonly sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  
      constructor(data?: IPropertyDictionaryItemSearchCriteria) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              if (Array.isArray(_data["propertyIds"])) {
                  this.propertyIds = [] as any;
                  for (let item of _data["propertyIds"])
                      this.propertyIds!.push(item);
              }
              if (Array.isArray(_data["catalogIds"])) {
                  this.catalogIds = [] as any;
                  for (let item of _data["catalogIds"])
                      this.catalogIds!.push(item);
              }
              this.responseGroup = _data["responseGroup"];
              this.objectType = _data["objectType"];
              if (Array.isArray(_data["objectTypes"])) {
                  this.objectTypes = [] as any;
                  for (let item of _data["objectTypes"])
                      this.objectTypes!.push(item);
              }
              if (Array.isArray(_data["objectIds"])) {
                  this.objectIds = [] as any;
                  for (let item of _data["objectIds"])
                      this.objectIds!.push(item);
              }
              this.keyword = _data["keyword"];
              this.searchPhrase = _data["searchPhrase"];
              this.languageCode = _data["languageCode"];
              this.sort = _data["sort"];
              if (Array.isArray(_data["sortInfos"])) {
                  (<any>this).sortInfos = [] as any;
                  for (let item of _data["sortInfos"])
                      (<any>this).sortInfos!.push(SortInfo.fromJS(item));
              }
              this.skip = _data["skip"];
              this.take = _data["take"];
          }
      }
  
      static fromJS(data: any): PropertyDictionaryItemSearchCriteria {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyDictionaryItemSearchCriteria();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          if (Array.isArray(this.propertyIds)) {
              data["propertyIds"] = [];
              for (let item of this.propertyIds)
                  data["propertyIds"].push(item);
          }
          if (Array.isArray(this.catalogIds)) {
              data["catalogIds"] = [];
              for (let item of this.catalogIds)
                  data["catalogIds"].push(item);
          }
          data["responseGroup"] = this.responseGroup;
          data["objectType"] = this.objectType;
          if (Array.isArray(this.objectTypes)) {
              data["objectTypes"] = [];
              for (let item of this.objectTypes)
                  data["objectTypes"].push(item);
          }
          if (Array.isArray(this.objectIds)) {
              data["objectIds"] = [];
              for (let item of this.objectIds)
                  data["objectIds"].push(item);
          }
          data["keyword"] = this.keyword;
          data["searchPhrase"] = this.searchPhrase;
          data["languageCode"] = this.languageCode;
          data["sort"] = this.sort;
          if (Array.isArray(this.sortInfos)) {
              data["sortInfos"] = [];
              for (let item of this.sortInfos)
                  data["sortInfos"].push(item.toJSON());
          }
          data["skip"] = this.skip;
          data["take"] = this.take;
          return data; 
      }
  }
  
  /** Search criteria used for search property dictionary items */
  export interface IPropertyDictionaryItemSearchCriteria {
      propertyIds?: string[] | undefined;
      catalogIds?: string[] | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  }
  
  export class PropertyDictionaryItemLocalizedValue implements IPropertyDictionaryItemLocalizedValue {
      languageCode?: string | undefined;
      value?: string | undefined;
  
      constructor(data?: IPropertyDictionaryItemLocalizedValue) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.languageCode = _data["languageCode"];
              this.value = _data["value"];
          }
      }
  
      static fromJS(data: any): PropertyDictionaryItemLocalizedValue {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyDictionaryItemLocalizedValue();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["languageCode"] = this.languageCode;
          data["value"] = this.value;
          return data; 
      }
  }
  
  export interface IPropertyDictionaryItemLocalizedValue {
      languageCode?: string | undefined;
      value?: string | undefined;
  }
  
  export class PropertyDictionaryItem implements IPropertyDictionaryItem {
      propertyId?: string | undefined;
      alias?: string | undefined;
      sortOrder?: number;
      localizedValues?: PropertyDictionaryItemLocalizedValue[] | undefined;
      id?: string | undefined;
  
      constructor(data?: IPropertyDictionaryItem) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.propertyId = _data["propertyId"];
              this.alias = _data["alias"];
              this.sortOrder = _data["sortOrder"];
              if (Array.isArray(_data["localizedValues"])) {
                  this.localizedValues = [] as any;
                  for (let item of _data["localizedValues"])
                      this.localizedValues!.push(PropertyDictionaryItemLocalizedValue.fromJS(item));
              }
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): PropertyDictionaryItem {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyDictionaryItem();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["propertyId"] = this.propertyId;
          data["alias"] = this.alias;
          data["sortOrder"] = this.sortOrder;
          if (Array.isArray(this.localizedValues)) {
              data["localizedValues"] = [];
              for (let item of this.localizedValues)
                  data["localizedValues"].push(item.toJSON());
          }
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IPropertyDictionaryItem {
      propertyId?: string | undefined;
      alias?: string | undefined;
      sortOrder?: number;
      localizedValues?: PropertyDictionaryItemLocalizedValue[] | undefined;
      id?: string | undefined;
  }
  
  export class PropertyDictionaryItemSearchResult implements IPropertyDictionaryItemSearchResult {
      totalCount?: number;
      results?: PropertyDictionaryItem[] | undefined;
  
      constructor(data?: IPropertyDictionaryItemSearchResult) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.totalCount = _data["totalCount"];
              if (Array.isArray(_data["results"])) {
                  this.results = [] as any;
                  for (let item of _data["results"])
                      this.results!.push(PropertyDictionaryItem.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): PropertyDictionaryItemSearchResult {
          data = typeof data === 'object' ? data : {};
          let result = new PropertyDictionaryItemSearchResult();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["totalCount"] = this.totalCount;
          if (Array.isArray(this.results)) {
              data["results"] = [];
              for (let item of this.results)
                  data["results"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface IPropertyDictionaryItemSearchResult {
      totalCount?: number;
      results?: PropertyDictionaryItem[] | undefined;
  }
  
  export class ProductDetails implements IProductDetails {
      name?: string | undefined;
      description?: string | undefined;
      gtin?: string | undefined;
      categoryId?: string | undefined;
      properties?: Property[] | undefined;
      images?: Image[] | undefined;
  
      constructor(data?: IProductDetails) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.name = _data["name"];
              this.description = _data["description"];
              this.gtin = _data["gtin"];
              this.categoryId = _data["categoryId"];
              if (Array.isArray(_data["properties"])) {
                  this.properties = [] as any;
                  for (let item of _data["properties"])
                      this.properties!.push(Property.fromJS(item));
              }
              if (Array.isArray(_data["images"])) {
                  this.images = [] as any;
                  for (let item of _data["images"])
                      this.images!.push(Image.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): ProductDetails {
          data = typeof data === 'object' ? data : {};
          let result = new ProductDetails();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["name"] = this.name;
          data["description"] = this.description;
          data["gtin"] = this.gtin;
          data["categoryId"] = this.categoryId;
          if (Array.isArray(this.properties)) {
              data["properties"] = [];
              for (let item of this.properties)
                  data["properties"].push(item.toJSON());
          }
          if (Array.isArray(this.images)) {
              data["images"] = [];
              for (let item of this.images)
                  data["images"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface IProductDetails {
      name?: string | undefined;
      description?: string | undefined;
      gtin?: string | undefined;
      categoryId?: string | undefined;
      properties?: Property[] | undefined;
      images?: Image[] | undefined;
  }
  
  export class CreateNewProductCommand implements ICreateNewProductCommand {
      sellerName?: string | undefined;
      productDetails?: ProductDetails;
  
      constructor(data?: ICreateNewProductCommand) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerName = _data["sellerName"];
              this.productDetails = _data["productDetails"] ? ProductDetails.fromJS(_data["productDetails"]) : <any>undefined;
          }
      }
  
      static fromJS(data: any): CreateNewProductCommand {
          data = typeof data === 'object' ? data : {};
          let result = new CreateNewProductCommand();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerName"] = this.sellerName;
          data["productDetails"] = this.productDetails ? this.productDetails.toJSON() : <any>undefined;
          return data; 
      }
  }
  
  export interface ICreateNewProductCommand {
      sellerName?: string | undefined;
      productDetails?: ProductDetails;
  }
  
  export class UpdateProductDetailsCommand implements IUpdateProductDetailsCommand {
      sellerProductId?: string | undefined;
      productDetails?: ProductDetails;
  
      constructor(data?: IUpdateProductDetailsCommand) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerProductId = _data["sellerProductId"];
              this.productDetails = _data["productDetails"] ? ProductDetails.fromJS(_data["productDetails"]) : <any>undefined;
          }
      }
  
      static fromJS(data: any): UpdateProductDetailsCommand {
          data = typeof data === 'object' ? data : {};
          let result = new UpdateProductDetailsCommand();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerProductId"] = this.sellerProductId;
          data["productDetails"] = this.productDetails ? this.productDetails.toJSON() : <any>undefined;
          return data; 
      }
  }
  
  export interface IUpdateProductDetailsCommand {
      sellerProductId?: string | undefined;
      productDetails?: ProductDetails;
  }
  
  export class CreateNewPublicationRequestCommand implements ICreateNewPublicationRequestCommand {
      storeId?: string | undefined;
      productId!: string;
      comment?: string | undefined;
  
      constructor(data?: ICreateNewPublicationRequestCommand) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.storeId = _data["storeId"];
              this.productId = _data["productId"];
              this.comment = _data["comment"];
          }
      }
  
      static fromJS(data: any): CreateNewPublicationRequestCommand {
          data = typeof data === 'object' ? data : {};
          let result = new CreateNewPublicationRequestCommand();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["storeId"] = this.storeId;
          data["productId"] = this.productId;
          data["comment"] = this.comment;
          return data; 
      }
  }
  
  export interface ICreateNewPublicationRequestCommand {
      storeId?: string | undefined;
      productId: string;
      comment?: string | undefined;
  }
  
  export class SearchOffersQuery implements ISearchOffersQuery {
      sellerId?: string | undefined;
      sellerProductId?: string | undefined;
      productId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      readonly sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  
      constructor(data?: ISearchOffersQuery) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerId = _data["sellerId"];
              this.sellerProductId = _data["sellerProductId"];
              this.productId = _data["productId"];
              this.responseGroup = _data["responseGroup"];
              this.objectType = _data["objectType"];
              if (Array.isArray(_data["objectTypes"])) {
                  this.objectTypes = [] as any;
                  for (let item of _data["objectTypes"])
                      this.objectTypes!.push(item);
              }
              if (Array.isArray(_data["objectIds"])) {
                  this.objectIds = [] as any;
                  for (let item of _data["objectIds"])
                      this.objectIds!.push(item);
              }
              this.keyword = _data["keyword"];
              this.searchPhrase = _data["searchPhrase"];
              this.languageCode = _data["languageCode"];
              this.sort = _data["sort"];
              if (Array.isArray(_data["sortInfos"])) {
                  (<any>this).sortInfos = [] as any;
                  for (let item of _data["sortInfos"])
                      (<any>this).sortInfos!.push(SortInfo.fromJS(item));
              }
              this.skip = _data["skip"];
              this.take = _data["take"];
          }
      }
  
      static fromJS(data: any): SearchOffersQuery {
          data = typeof data === 'object' ? data : {};
          let result = new SearchOffersQuery();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerId"] = this.sellerId;
          data["sellerProductId"] = this.sellerProductId;
          data["productId"] = this.productId;
          data["responseGroup"] = this.responseGroup;
          data["objectType"] = this.objectType;
          if (Array.isArray(this.objectTypes)) {
              data["objectTypes"] = [];
              for (let item of this.objectTypes)
                  data["objectTypes"].push(item);
          }
          if (Array.isArray(this.objectIds)) {
              data["objectIds"] = [];
              for (let item of this.objectIds)
                  data["objectIds"].push(item);
          }
          data["keyword"] = this.keyword;
          data["searchPhrase"] = this.searchPhrase;
          data["languageCode"] = this.languageCode;
          data["sort"] = this.sort;
          if (Array.isArray(this.sortInfos)) {
              data["sortInfos"] = [];
              for (let item of this.sortInfos)
                  data["sortInfos"].push(item.toJSON());
          }
          data["skip"] = this.skip;
          data["take"] = this.take;
          return data; 
      }
  }
  
  export interface ISearchOffersQuery {
      sellerId?: string | undefined;
      sellerProductId?: string | undefined;
      productId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  }
  
  export class OfferPrice implements IOfferPrice {
      listPrice!: number;
      salePrice?: number | undefined;
      minQuantity?: number;
      id?: string | undefined;
  
      constructor(data?: IOfferPrice) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.listPrice = _data["listPrice"];
              this.salePrice = _data["salePrice"];
              this.minQuantity = _data["minQuantity"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): OfferPrice {
          data = typeof data === 'object' ? data : {};
          let result = new OfferPrice();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["listPrice"] = this.listPrice;
          data["salePrice"] = this.salePrice;
          data["minQuantity"] = this.minQuantity;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IOfferPrice {
      listPrice: number;
      salePrice?: number | undefined;
      minQuantity?: number;
      id?: string | undefined;
  }
  
  export class Offer implements IOffer {
      isActive?: boolean;
      outerId?: string | undefined;
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      storeId?: string | undefined;
      storeName?: string | undefined;
      name?: string | undefined;
      sku?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      currency?: string | undefined;
      readonly listPrice?: number | undefined;
      readonly salePrice?: number | undefined;
      readonly minQuantity?: number | undefined;
      prices?: OfferPrice[] | undefined;
      inStockQuantity?: number;
      startDate?: Date | undefined;
      endDate?: Date | undefined;
      estimatedDeliveryDate?: string | undefined;
      productId?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IOffer) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.isActive = _data["isActive"];
              this.outerId = _data["outerId"];
              this.sellerId = _data["sellerId"];
              this.sellerName = _data["sellerName"];
              this.storeId = _data["storeId"];
              this.storeName = _data["storeName"];
              this.name = _data["name"];
              this.sku = _data["sku"];
              this.imgSrc = _data["imgSrc"];
              this.categoryId = _data["categoryId"];
              this.path = _data["path"];
              this.currency = _data["currency"];
              (<any>this).listPrice = _data["listPrice"];
              (<any>this).salePrice = _data["salePrice"];
              (<any>this).minQuantity = _data["minQuantity"];
              if (Array.isArray(_data["prices"])) {
                  this.prices = [] as any;
                  for (let item of _data["prices"])
                      this.prices!.push(OfferPrice.fromJS(item));
              }
              this.inStockQuantity = _data["inStockQuantity"];
              this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
              this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
              this.estimatedDeliveryDate = _data["estimatedDeliveryDate"];
              this.productId = _data["productId"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): Offer {
          data = typeof data === 'object' ? data : {};
          let result = new Offer();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["isActive"] = this.isActive;
          data["outerId"] = this.outerId;
          data["sellerId"] = this.sellerId;
          data["sellerName"] = this.sellerName;
          data["storeId"] = this.storeId;
          data["storeName"] = this.storeName;
          data["name"] = this.name;
          data["sku"] = this.sku;
          data["imgSrc"] = this.imgSrc;
          data["categoryId"] = this.categoryId;
          data["path"] = this.path;
          data["currency"] = this.currency;
          data["listPrice"] = this.listPrice;
          data["salePrice"] = this.salePrice;
          data["minQuantity"] = this.minQuantity;
          if (Array.isArray(this.prices)) {
              data["prices"] = [];
              for (let item of this.prices)
                  data["prices"].push(item.toJSON());
          }
          data["inStockQuantity"] = this.inStockQuantity;
          data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
          data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
          data["estimatedDeliveryDate"] = this.estimatedDeliveryDate;
          data["productId"] = this.productId;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IOffer {
      isActive?: boolean;
      outerId?: string | undefined;
      sellerId?: string | undefined;
      sellerName?: string | undefined;
      storeId?: string | undefined;
      storeName?: string | undefined;
      name?: string | undefined;
      sku?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      currency?: string | undefined;
      listPrice?: number | undefined;
      salePrice?: number | undefined;
      minQuantity?: number | undefined;
      prices?: OfferPrice[] | undefined;
      inStockQuantity?: number;
      startDate?: Date | undefined;
      endDate?: Date | undefined;
      estimatedDeliveryDate?: string | undefined;
      productId?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class SearchOffersResult implements ISearchOffersResult {
      totalCount?: number;
      results?: Offer[] | undefined;
  
      constructor(data?: ISearchOffersResult) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.totalCount = _data["totalCount"];
              if (Array.isArray(_data["results"])) {
                  this.results = [] as any;
                  for (let item of _data["results"])
                      this.results!.push(Offer.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): SearchOffersResult {
          data = typeof data === 'object' ? data : {};
          let result = new SearchOffersResult();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["totalCount"] = this.totalCount;
          if (Array.isArray(this.results)) {
              data["results"] = [];
              for (let item of this.results)
                  data["results"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface ISearchOffersResult {
      totalCount?: number;
      results?: Offer[] | undefined;
  }
  
  export class SearchProductsForNewOfferQuery implements ISearchProductsForNewOfferQuery {
      sellerId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      readonly sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  
      constructor(data?: ISearchProductsForNewOfferQuery) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.sellerId = _data["sellerId"];
              this.responseGroup = _data["responseGroup"];
              this.objectType = _data["objectType"];
              if (Array.isArray(_data["objectTypes"])) {
                  this.objectTypes = [] as any;
                  for (let item of _data["objectTypes"])
                      this.objectTypes!.push(item);
              }
              if (Array.isArray(_data["objectIds"])) {
                  this.objectIds = [] as any;
                  for (let item of _data["objectIds"])
                      this.objectIds!.push(item);
              }
              this.keyword = _data["keyword"];
              this.searchPhrase = _data["searchPhrase"];
              this.languageCode = _data["languageCode"];
              this.sort = _data["sort"];
              if (Array.isArray(_data["sortInfos"])) {
                  (<any>this).sortInfos = [] as any;
                  for (let item of _data["sortInfos"])
                      (<any>this).sortInfos!.push(SortInfo.fromJS(item));
              }
              this.skip = _data["skip"];
              this.take = _data["take"];
          }
      }
  
      static fromJS(data: any): SearchProductsForNewOfferQuery {
          data = typeof data === 'object' ? data : {};
          let result = new SearchProductsForNewOfferQuery();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["sellerId"] = this.sellerId;
          data["responseGroup"] = this.responseGroup;
          data["objectType"] = this.objectType;
          if (Array.isArray(this.objectTypes)) {
              data["objectTypes"] = [];
              for (let item of this.objectTypes)
                  data["objectTypes"].push(item);
          }
          if (Array.isArray(this.objectIds)) {
              data["objectIds"] = [];
              for (let item of this.objectIds)
                  data["objectIds"].push(item);
          }
          data["keyword"] = this.keyword;
          data["searchPhrase"] = this.searchPhrase;
          data["languageCode"] = this.languageCode;
          data["sort"] = this.sort;
          if (Array.isArray(this.sortInfos)) {
              data["sortInfos"] = [];
              for (let item of this.sortInfos)
                  data["sortInfos"].push(item.toJSON());
          }
          data["skip"] = this.skip;
          data["take"] = this.take;
          return data; 
      }
  }
  
  export interface ISearchProductsForNewOfferQuery {
      sellerId?: string | undefined;
      responseGroup?: string | undefined;
      /** Search object type */
      objectType?: string | undefined;
      objectTypes?: string[] | undefined;
      objectIds?: string[] | undefined;
      /** Search phrase */
      keyword?: string | undefined;
      /** Property is left for backward compatibility */
      searchPhrase?: string | undefined;
      /** Search phrase language */
      languageCode?: string | undefined;
      sort?: string | undefined;
      sortInfos?: SortInfo[] | undefined;
      skip?: number;
      take?: number;
  }
  
  export class OfferProduct implements IOfferProduct {
      name?: string | undefined;
      sku?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  
      constructor(data?: IOfferProduct) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.name = _data["name"];
              this.sku = _data["sku"];
              this.imgSrc = _data["imgSrc"];
              this.categoryId = _data["categoryId"];
              this.path = _data["path"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): OfferProduct {
          data = typeof data === 'object' ? data : {};
          let result = new OfferProduct();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["name"] = this.name;
          data["sku"] = this.sku;
          data["imgSrc"] = this.imgSrc;
          data["categoryId"] = this.categoryId;
          data["path"] = this.path;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IOfferProduct {
      name?: string | undefined;
      sku?: string | undefined;
      imgSrc?: string | undefined;
      categoryId?: string | undefined;
      path?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      id?: string | undefined;
  }
  
  export class SearchOfferProductsResult implements ISearchOfferProductsResult {
      totalCount?: number;
      results?: OfferProduct[] | undefined;
  
      constructor(data?: ISearchOfferProductsResult) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.totalCount = _data["totalCount"];
              if (Array.isArray(_data["results"])) {
                  this.results = [] as any;
                  for (let item of _data["results"])
                      this.results!.push(OfferProduct.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): SearchOfferProductsResult {
          data = typeof data === 'object' ? data : {};
          let result = new SearchOfferProductsResult();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["totalCount"] = this.totalCount;
          if (Array.isArray(this.results)) {
              data["results"] = [];
              for (let item of this.results)
                  data["results"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface ISearchOfferProductsResult {
      totalCount?: number;
      results?: OfferProduct[] | undefined;
  }
  
  export class OfferDetails implements IOfferDetails {
      productId?: string | undefined;
      isActive?: boolean;
      outerId?: string | undefined;
      name?: string | undefined;
      sku!: string;
      currency!: string;
      prices?: OfferPrice[] | undefined;
      inStockQuantity?: number;
      startDate?: Date | undefined;
      endDate?: Date | undefined;
      estimatedDeliveryDate?: string | undefined;
  
      constructor(data?: IOfferDetails) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.productId = _data["productId"];
              this.isActive = _data["isActive"];
              this.outerId = _data["outerId"];
              this.name = _data["name"];
              this.sku = _data["sku"];
              this.currency = _data["currency"];
              if (Array.isArray(_data["prices"])) {
                  this.prices = [] as any;
                  for (let item of _data["prices"])
                      this.prices!.push(OfferPrice.fromJS(item));
              }
              this.inStockQuantity = _data["inStockQuantity"];
              this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
              this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
              this.estimatedDeliveryDate = _data["estimatedDeliveryDate"];
          }
      }
  
      static fromJS(data: any): OfferDetails {
          data = typeof data === 'object' ? data : {};
          let result = new OfferDetails();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["productId"] = this.productId;
          data["isActive"] = this.isActive;
          data["outerId"] = this.outerId;
          data["name"] = this.name;
          data["sku"] = this.sku;
          data["currency"] = this.currency;
          if (Array.isArray(this.prices)) {
              data["prices"] = [];
              for (let item of this.prices)
                  data["prices"].push(item.toJSON());
          }
          data["inStockQuantity"] = this.inStockQuantity;
          data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
          data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
          data["estimatedDeliveryDate"] = this.estimatedDeliveryDate;
          return data; 
      }
  }
  
  export interface IOfferDetails {
      productId?: string | undefined;
      isActive?: boolean;
      outerId?: string | undefined;
      name?: string | undefined;
      sku: string;
      currency: string;
      prices?: OfferPrice[] | undefined;
      inStockQuantity?: number;
      startDate?: Date | undefined;
      endDate?: Date | undefined;
      estimatedDeliveryDate?: string | undefined;
  }
  
  export class CreateNewOfferCommand implements ICreateNewOfferCommand {
      outerId?: string | undefined;
      sellerName!: string;
      storeId?: string | undefined;
      storeName?: string | undefined;
      details!: OfferDetails;
      productId!: string;
  
      constructor(data?: ICreateNewOfferCommand) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
          if (!data) {
              this.details = new OfferDetails();
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.outerId = _data["outerId"];
              this.sellerName = _data["sellerName"];
              this.storeId = _data["storeId"];
              this.storeName = _data["storeName"];
              this.details = _data["details"] ? OfferDetails.fromJS(_data["details"]) : new OfferDetails();
              this.productId = _data["productId"];
          }
      }
  
      static fromJS(data: any): CreateNewOfferCommand {
          data = typeof data === 'object' ? data : {};
          let result = new CreateNewOfferCommand();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["outerId"] = this.outerId;
          data["sellerName"] = this.sellerName;
          data["storeId"] = this.storeId;
          data["storeName"] = this.storeName;
          data["details"] = this.details ? this.details.toJSON() : <any>undefined;
          data["productId"] = this.productId;
          return data; 
      }
  }
  
  export interface ICreateNewOfferCommand {
      outerId?: string | undefined;
      sellerName: string;
      storeId?: string | undefined;
      storeName?: string | undefined;
      details: OfferDetails;
      productId: string;
  }
  
  export class PermissionScope implements IPermissionScope {
      /** Scope type name */
      type?: string | undefined;
      /** Display label for particular scope value used only for  representation */
      label?: string | undefined;
      /** Represent string scope value */
      scope?: string | undefined;
  
      constructor(data?: IPermissionScope) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.type = _data["type"];
              this.label = _data["label"];
              this.scope = _data["scope"];
          }
      }
  
      static fromJS(data: any): PermissionScope {
          data = typeof data === 'object' ? data : {};
          let result = new PermissionScope();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["type"] = this.type;
          data["label"] = this.label;
          data["scope"] = this.scope;
          return data; 
      }
  }
  
  export interface IPermissionScope {
      /** Scope type name */
      type?: string | undefined;
      /** Display label for particular scope value used only for  representation */
      label?: string | undefined;
      /** Represent string scope value */
      scope?: string | undefined;
  }
  
  export class Permission implements IPermission {
      id?: string | undefined;
      name?: string | undefined;
      /** Id of the module which has registered this permission. */
      moduleId?: string | undefined;
      /** Display name of the group to which this permission belongs. The '|' character is used to separate Child and parent groups. */
      groupName?: string | undefined;
      assignedScopes?: PermissionScope[] | undefined;
      readonly availableScopes?: PermissionScope[] | undefined;
  
      constructor(data?: IPermission) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.id = _data["id"];
              this.name = _data["name"];
              this.moduleId = _data["moduleId"];
              this.groupName = _data["groupName"];
              if (Array.isArray(_data["assignedScopes"])) {
                  this.assignedScopes = [] as any;
                  for (let item of _data["assignedScopes"])
                      this.assignedScopes!.push(PermissionScope.fromJS(item));
              }
              if (Array.isArray(_data["availableScopes"])) {
                  (<any>this).availableScopes = [] as any;
                  for (let item of _data["availableScopes"])
                      (<any>this).availableScopes!.push(PermissionScope.fromJS(item));
              }
          }
      }
  
      static fromJS(data: any): Permission {
          data = typeof data === 'object' ? data : {};
          let result = new Permission();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["id"] = this.id;
          data["name"] = this.name;
          data["moduleId"] = this.moduleId;
          data["groupName"] = this.groupName;
          if (Array.isArray(this.assignedScopes)) {
              data["assignedScopes"] = [];
              for (let item of this.assignedScopes)
                  data["assignedScopes"].push(item.toJSON());
          }
          if (Array.isArray(this.availableScopes)) {
              data["availableScopes"] = [];
              for (let item of this.availableScopes)
                  data["availableScopes"].push(item.toJSON());
          }
          return data; 
      }
  }
  
  export interface IPermission {
      id?: string | undefined;
      name?: string | undefined;
      /** Id of the module which has registered this permission. */
      moduleId?: string | undefined;
      /** Display name of the group to which this permission belongs. The '|' character is used to separate Child and parent groups. */
      groupName?: string | undefined;
      assignedScopes?: PermissionScope[] | undefined;
      availableScopes?: PermissionScope[] | undefined;
  }
  
  export class StringIdentityUserRole implements IStringIdentityUserRole {
      userId?: string | undefined;
      roleId?: string | undefined;
  
      constructor(data?: IStringIdentityUserRole) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.userId = _data["userId"];
              this.roleId = _data["roleId"];
          }
      }
  
      static fromJS(data: any): StringIdentityUserRole {
          data = typeof data === 'object' ? data : {};
          let result = new StringIdentityUserRole();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["userId"] = this.userId;
          data["roleId"] = this.roleId;
          return data; 
      }
  }
  
  export interface IStringIdentityUserRole {
      userId?: string | undefined;
      roleId?: string | undefined;
  }
  
  export class Role implements IRole {
      description?: string | undefined;
      permissions?: Permission[] | undefined;
      id?: string | undefined;
      name?: string | undefined;
      normalizedName?: string | undefined;
      concurrencyStamp?: string | undefined;
  
      constructor(data?: IRole) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.description = _data["description"];
              if (Array.isArray(_data["permissions"])) {
                  this.permissions = [] as any;
                  for (let item of _data["permissions"])
                      this.permissions!.push(Permission.fromJS(item));
              }
              this.id = _data["id"];
              this.name = _data["name"];
              this.normalizedName = _data["normalizedName"];
              this.concurrencyStamp = _data["concurrencyStamp"];
          }
      }
  
      static fromJS(data: any): Role {
          data = typeof data === 'object' ? data : {};
          let result = new Role();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["description"] = this.description;
          if (Array.isArray(this.permissions)) {
              data["permissions"] = [];
              for (let item of this.permissions)
                  data["permissions"].push(item.toJSON());
          }
          data["id"] = this.id;
          data["name"] = this.name;
          data["normalizedName"] = this.normalizedName;
          data["concurrencyStamp"] = this.concurrencyStamp;
          return data; 
      }
  }
  
  export interface IRole {
      description?: string | undefined;
      permissions?: Permission[] | undefined;
      id?: string | undefined;
      name?: string | undefined;
      normalizedName?: string | undefined;
      concurrencyStamp?: string | undefined;
  }
  
  /** Obsolete. Left due to compatibility issues. Will be removed. Instead of, use: ApplicationUser.EmailConfirmed, ApplicationUser.LockoutEnd. */
  export enum AccountState {
      PendingApproval = "PendingApproval",
      Approved = "Approved",
      Rejected = "Rejected",
  }
  
  export class ApplicationUserLogin implements IApplicationUserLogin {
      loginProvider?: string | undefined;
      providerKey?: string | undefined;
  
      constructor(data?: IApplicationUserLogin) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.loginProvider = _data["loginProvider"];
              this.providerKey = _data["providerKey"];
          }
      }
  
      static fromJS(data: any): ApplicationUserLogin {
          data = typeof data === 'object' ? data : {};
          let result = new ApplicationUserLogin();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["loginProvider"] = this.loginProvider;
          data["providerKey"] = this.providerKey;
          return data; 
      }
  }
  
  export interface IApplicationUserLogin {
      loginProvider?: string | undefined;
      providerKey?: string | undefined;
  }
  
  export class ApplicationUser implements IApplicationUser {
      /** Tenant id */
      storeId?: string | undefined;
      memberId?: string | undefined;
      isAdministrator?: boolean;
      photoUrl?: string | undefined;
      userType?: string | undefined;
      status?: string | undefined;
      password?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      roles?: Role[] | undefined;
      /** Obsolete. Use LockoutEnd. DateTime in UTC when lockout ends, any time in the past is considered not locked out. */
      lockoutEndDateUtc?: Date | undefined;
      userState?: AccountState;
      /** Obsolete. All permissions from assigned roles. */
      permissions?: string[] | undefined;
      /** External provider logins. */
      logins?: ApplicationUserLogin[] | undefined;
      /** Indicates that the password for this user is expired and must be changed. */
      passwordExpired?: boolean;
      /** The last date when the password was changed */
      lastPasswordChangedDate?: Date | undefined;
      /** The last date when the requested password change. */
      lastPasswordChangeRequestDate?: Date | undefined;
      id?: string | undefined;
      userName?: string | undefined;
      normalizedUserName?: string | undefined;
      email?: string | undefined;
      normalizedEmail?: string | undefined;
      emailConfirmed?: boolean;
      passwordHash?: string | undefined;
      securityStamp?: string | undefined;
      concurrencyStamp?: string | undefined;
      phoneNumber?: string | undefined;
      phoneNumberConfirmed?: boolean;
      twoFactorEnabled?: boolean;
      lockoutEnd?: Date | undefined;
      lockoutEnabled?: boolean;
      accessFailedCount?: number;
  
      constructor(data?: IApplicationUser) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.storeId = _data["storeId"];
              this.memberId = _data["memberId"];
              this.isAdministrator = _data["isAdministrator"];
              this.photoUrl = _data["photoUrl"];
              this.userType = _data["userType"];
              this.status = _data["status"];
              this.password = _data["password"];
              this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
              this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
              this.createdBy = _data["createdBy"];
              this.modifiedBy = _data["modifiedBy"];
              if (Array.isArray(_data["roles"])) {
                  this.roles = [] as any;
                  for (let item of _data["roles"])
                      this.roles!.push(Role.fromJS(item));
              }
              this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? new Date(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
              this.userState = _data["userState"];
              if (Array.isArray(_data["permissions"])) {
                  this.permissions = [] as any;
                  for (let item of _data["permissions"])
                      this.permissions!.push(item);
              }
              if (Array.isArray(_data["logins"])) {
                  this.logins = [] as any;
                  for (let item of _data["logins"])
                      this.logins!.push(ApplicationUserLogin.fromJS(item));
              }
              this.passwordExpired = _data["passwordExpired"];
              this.lastPasswordChangedDate = _data["lastPasswordChangedDate"] ? new Date(_data["lastPasswordChangedDate"].toString()) : <any>undefined;
              this.lastPasswordChangeRequestDate = _data["lastPasswordChangeRequestDate"] ? new Date(_data["lastPasswordChangeRequestDate"].toString()) : <any>undefined;
              this.id = _data["id"];
              this.userName = _data["userName"];
              this.normalizedUserName = _data["normalizedUserName"];
              this.email = _data["email"];
              this.normalizedEmail = _data["normalizedEmail"];
              this.emailConfirmed = _data["emailConfirmed"];
              this.passwordHash = _data["passwordHash"];
              this.securityStamp = _data["securityStamp"];
              this.concurrencyStamp = _data["concurrencyStamp"];
              this.phoneNumber = _data["phoneNumber"];
              this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
              this.twoFactorEnabled = _data["twoFactorEnabled"];
              this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
              this.lockoutEnabled = _data["lockoutEnabled"];
              this.accessFailedCount = _data["accessFailedCount"];
          }
      }
  
      static fromJS(data: any): ApplicationUser {
          data = typeof data === 'object' ? data : {};
          let result = new ApplicationUser();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["storeId"] = this.storeId;
          data["memberId"] = this.memberId;
          data["isAdministrator"] = this.isAdministrator;
          data["photoUrl"] = this.photoUrl;
          data["userType"] = this.userType;
          data["status"] = this.status;
          data["password"] = this.password;
          data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
          data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
          data["createdBy"] = this.createdBy;
          data["modifiedBy"] = this.modifiedBy;
          if (Array.isArray(this.roles)) {
              data["roles"] = [];
              for (let item of this.roles)
                  data["roles"].push(item.toJSON());
          }
          data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
          data["userState"] = this.userState;
          if (Array.isArray(this.permissions)) {
              data["permissions"] = [];
              for (let item of this.permissions)
                  data["permissions"].push(item);
          }
          if (Array.isArray(this.logins)) {
              data["logins"] = [];
              for (let item of this.logins)
                  data["logins"].push(item.toJSON());
          }
          data["passwordExpired"] = this.passwordExpired;
          data["lastPasswordChangedDate"] = this.lastPasswordChangedDate ? this.lastPasswordChangedDate.toISOString() : <any>undefined;
          data["lastPasswordChangeRequestDate"] = this.lastPasswordChangeRequestDate ? this.lastPasswordChangeRequestDate.toISOString() : <any>undefined;
          data["id"] = this.id;
          data["userName"] = this.userName;
          data["normalizedUserName"] = this.normalizedUserName;
          data["email"] = this.email;
          data["normalizedEmail"] = this.normalizedEmail;
          data["emailConfirmed"] = this.emailConfirmed;
          data["passwordHash"] = this.passwordHash;
          data["securityStamp"] = this.securityStamp;
          data["concurrencyStamp"] = this.concurrencyStamp;
          data["phoneNumber"] = this.phoneNumber;
          data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
          data["twoFactorEnabled"] = this.twoFactorEnabled;
          data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
          data["lockoutEnabled"] = this.lockoutEnabled;
          data["accessFailedCount"] = this.accessFailedCount;
          return data; 
      }
  }
  
  export interface IApplicationUser {
      /** Tenant id */
      storeId?: string | undefined;
      memberId?: string | undefined;
      isAdministrator?: boolean;
      photoUrl?: string | undefined;
      userType?: string | undefined;
      status?: string | undefined;
      password?: string | undefined;
      createdDate?: Date;
      modifiedDate?: Date | undefined;
      createdBy?: string | undefined;
      modifiedBy?: string | undefined;
      roles?: Role[] | undefined;
      /** Obsolete. Use LockoutEnd. DateTime in UTC when lockout ends, any time in the past is considered not locked out. */
      lockoutEndDateUtc?: Date | undefined;
      userState?: AccountState;
      /** Obsolete. All permissions from assigned roles. */
      permissions?: string[] | undefined;
      /** External provider logins. */
      logins?: ApplicationUserLogin[] | undefined;
      /** Indicates that the password for this user is expired and must be changed. */
      passwordExpired?: boolean;
      /** The last date when the password was changed */
      lastPasswordChangedDate?: Date | undefined;
      /** The last date when the requested password change. */
      lastPasswordChangeRequestDate?: Date | undefined;
      id?: string | undefined;
      userName?: string | undefined;
      normalizedUserName?: string | undefined;
      email?: string | undefined;
      normalizedEmail?: string | undefined;
      emailConfirmed?: boolean;
      passwordHash?: string | undefined;
      securityStamp?: string | undefined;
      concurrencyStamp?: string | undefined;
      phoneNumber?: string | undefined;
      phoneNumberConfirmed?: boolean;
      twoFactorEnabled?: boolean;
      lockoutEnd?: Date | undefined;
      lockoutEnabled?: boolean;
      accessFailedCount?: number;
  }
  
  export class ImportProfileOptions implements IImportProfileOptions {
      type?: string | undefined;
      previewObjectCount?: number;
      importFileUrl?: string | undefined;
  
      constructor(data?: IImportProfileOptions) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.type = _data["type"];
              this.previewObjectCount = _data["previewObjectCount"];
              this.importFileUrl = _data["importFileUrl"];
          }
      }
  
      static fromJS(data: any): ImportProfileOptions {
          data = typeof data === 'object' ? data : {};
          let result = new ImportProfileOptions();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["type"] = this.type;
          data["previewObjectCount"] = this.previewObjectCount;
          data["importFileUrl"] = this.importFileUrl;
          return data; 
      }
  }
  
  export interface IImportProfileOptions {
      type?: string | undefined;
      previewObjectCount?: number;
      importFileUrl?: string | undefined;
  }
  
  export class ImportProfile implements IImportProfile {
      id?: string | undefined;
      dataImporterType?: string | undefined;
      options?: ImportProfileOptions;
  
      constructor(data?: IImportProfile) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.id = _data["id"];
              this.dataImporterType = _data["dataImporterType"];
              this.options = _data["options"] ? ImportProfileOptions.fromJS(_data["options"]) : <any>undefined;
          }
      }
  
      static fromJS(data: any): ImportProfile {
          data = typeof data === 'object' ? data : {};
          let result = new ImportProfile();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["id"] = this.id;
          data["dataImporterType"] = this.dataImporterType;
          data["options"] = this.options ? this.options.toJSON() : <any>undefined;
          return data; 
      }
  }
  
  export interface IImportProfile {
      id?: string | undefined;
      dataImporterType?: string | undefined;
      options?: ImportProfileOptions;
  }
  
  export class ImportDataCommand implements IImportDataCommand {
      importProfile?: ImportProfile;
  
      constructor(data?: IImportDataCommand) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.importProfile = _data["importProfile"] ? ImportProfile.fromJS(_data["importProfile"]) : <any>undefined;
          }
      }
  
      static fromJS(data: any): ImportDataCommand {
          data = typeof data === 'object' ? data : {};
          let result = new ImportDataCommand();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["importProfile"] = this.importProfile ? this.importProfile.toJSON() : <any>undefined;
          return data; 
      }
  }
  
  export interface IImportDataCommand {
      importProfile?: ImportProfile;
  }
  
  export class ImportPushNotification implements IImportPushNotification {
      jobId?: string | undefined;
      finished?: Date | undefined;
      totalCount?: number;
      processedCount?: number;
      errorCount?: number;
      errors?: string[] | undefined;
      reportUrl?: string | undefined;
      serverId?: string | undefined;
      creator?: string | undefined;
      created?: Date;
      isNew?: boolean;
      notifyType?: string | undefined;
      description?: string | undefined;
      title?: string | undefined;
      repeatCount?: number;
      id?: string | undefined;
  
      constructor(data?: IImportPushNotification) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.jobId = _data["jobId"];
              this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
              this.totalCount = _data["totalCount"];
              this.processedCount = _data["processedCount"];
              this.errorCount = _data["errorCount"];
              if (Array.isArray(_data["errors"])) {
                  this.errors = [] as any;
                  for (let item of _data["errors"])
                      this.errors!.push(item);
              }
              this.reportUrl = _data["reportUrl"];
              this.serverId = _data["serverId"];
              this.creator = _data["creator"];
              this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
              this.isNew = _data["isNew"];
              this.notifyType = _data["notifyType"];
              this.description = _data["description"];
              this.title = _data["title"];
              this.repeatCount = _data["repeatCount"];
              this.id = _data["id"];
          }
      }
  
      static fromJS(data: any): ImportPushNotification {
          data = typeof data === 'object' ? data : {};
          let result = new ImportPushNotification();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["jobId"] = this.jobId;
          data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
          data["totalCount"] = this.totalCount;
          data["processedCount"] = this.processedCount;
          data["errorCount"] = this.errorCount;
          if (Array.isArray(this.errors)) {
              data["errors"] = [];
              for (let item of this.errors)
                  data["errors"].push(item);
          }
          data["reportUrl"] = this.reportUrl;
          data["serverId"] = this.serverId;
          data["creator"] = this.creator;
          data["created"] = this.created ? this.created.toISOString() : <any>undefined;
          data["isNew"] = this.isNew;
          data["notifyType"] = this.notifyType;
          data["description"] = this.description;
          data["title"] = this.title;
          data["repeatCount"] = this.repeatCount;
          data["id"] = this.id;
          return data; 
      }
  }
  
  export interface IImportPushNotification {
      jobId?: string | undefined;
      finished?: Date | undefined;
      totalCount?: number;
      processedCount?: number;
      errorCount?: number;
      errors?: string[] | undefined;
      reportUrl?: string | undefined;
      serverId?: string | undefined;
      creator?: string | undefined;
      created?: Date;
      isNew?: boolean;
      notifyType?: string | undefined;
      description?: string | undefined;
      title?: string | undefined;
      repeatCount?: number;
      id?: string | undefined;
  }
  
  export class ImportCancellationRequest implements IImportCancellationRequest {
      jobId?: string | undefined;
  
      constructor(data?: IImportCancellationRequest) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.jobId = _data["jobId"];
          }
      }
  
      static fromJS(data: any): ImportCancellationRequest {
          data = typeof data === 'object' ? data : {};
          let result = new ImportCancellationRequest();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["jobId"] = this.jobId;
          return data; 
      }
  }
  
  export interface IImportCancellationRequest {
      jobId?: string | undefined;
  }
  
  export class PreviewDataQuery implements IPreviewDataQuery {
      importProfile?: ImportProfile;
  
      constructor(data?: IPreviewDataQuery) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.importProfile = _data["importProfile"] ? ImportProfile.fromJS(_data["importProfile"]) : <any>undefined;
          }
      }
  
      static fromJS(data: any): PreviewDataQuery {
          data = typeof data === 'object' ? data : {};
          let result = new PreviewDataQuery();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["importProfile"] = this.importProfile ? this.importProfile.toJSON() : <any>undefined;
          return data; 
      }
  }
  
  export interface IPreviewDataQuery {
      importProfile?: ImportProfile;
  }
  
  export class ImportDataPreview implements IImportDataPreview {
      totalCount?: number;
      fileName?: string | undefined;
      records?: any[] | undefined;
  
      constructor(data?: IImportDataPreview) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.totalCount = _data["totalCount"];
              this.fileName = _data["fileName"];
              if (Array.isArray(_data["records"])) {
                  this.records = [] as any;
                  for (let item of _data["records"])
                      this.records!.push(item);
              }
          }
      }
  
      static fromJS(data: any): ImportDataPreview {
          data = typeof data === 'object' ? data : {};
          let result = new ImportDataPreview();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["totalCount"] = this.totalCount;
          data["fileName"] = this.fileName;
          if (Array.isArray(this.records)) {
              data["records"] = [];
              for (let item of this.records)
                  data["records"].push(item);
          }
          return data; 
      }
  }
  
  export interface IImportDataPreview {
      totalCount?: number;
      fileName?: string | undefined;
      records?: any[] | undefined;
  }
  
  export class ImporterMetadata implements IImporterMetadata {
      importerType?: string | undefined;
      importerOptions?: ImportProfileOptions;
  
      constructor(data?: IImporterMetadata) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.importerType = _data["importerType"];
              this.importerOptions = _data["importerOptions"] ? ImportProfileOptions.fromJS(_data["importerOptions"]) : <any>undefined;
          }
      }
  
      static fromJS(data: any): ImporterMetadata {
          data = typeof data === 'object' ? data : {};
          let result = new ImporterMetadata();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["importerType"] = this.importerType;
          data["importerOptions"] = this.importerOptions ? this.importerOptions.toJSON() : <any>undefined;
          return data; 
      }
  }
  
  export interface IImporterMetadata {
      importerType?: string | undefined;
      importerOptions?: ImportProfileOptions;
  }
  
  export class ForgotPasswordCommand implements IForgotPasswordCommand {
      loginOrEmail!: string;
  
      constructor(data?: IForgotPasswordCommand) {
          if (data) {
              for (var property in data) {
                  if (data.hasOwnProperty(property))
                      (<any>this)[property] = (<any>data)[property];
              }
          }
      }
  
      init(_data?: any) {
          if (_data) {
              this.loginOrEmail = _data["loginOrEmail"];
          }
      }
  
      static fromJS(data: any): ForgotPasswordCommand {
          data = typeof data === 'object' ? data : {};
          let result = new ForgotPasswordCommand();
          result.init(data);
          return result;
      }
  
      toJSON(data?: any) {
          data = typeof data === 'object' ? data : {};
          data["loginOrEmail"] = this.loginOrEmail;
          return data; 
      }
  }
  
  export interface IForgotPasswordCommand {
      loginOrEmail: string;
  }
  
  export class ApiException extends Error {
      message: string;
      status: number;
      response: string;
      headers: { [key: string]: any; };
      result: any;
  
      constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
          super();
  
          this.message = message;
          this.status = status;
          this.response = response;
          this.headers = headers;
          this.result = result;
      }
  
      protected isApiException = true;
  
      static isApiException(obj: any): obj is ApiException {
          return obj.isApiException === true;
      }
  }
  
  function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
      if (result !== null && result !== undefined)
          throw result;
      else
          throw new ApiException(message, status, response, headers, null);
  }
  
  /* eslint-disable */