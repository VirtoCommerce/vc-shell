# VC-Shell Framework - AI Development Rules

## üìã Overview

VC-Shell is a Vue 3 Composition API-based framework for building enterprise e-commerce applications. This ruleset ensures consistent, high-quality code generation aligned with framework patterns.

**IMPORTANT:** This is the primary rules file. For complete documentation, ALWAYS consult:
- `ai-guides/UI_COMPONENTS_REFERENCE.md` - Full component documentation (27 components)
- `ai-guides/README.md` - Navigation guide for all documentation
- `ai-guides/prompts/` - Ready-to-use prompt templates
- `ai-guides/guides/` - Technical guides and workflows

---

## üéØ Core Principles

1. **Component-Based Architecture**: Use atomic design (atoms, molecules, organisms)
2. **Type Safety**: All code must be TypeScript with proper interfaces
3. **Composable Logic**: Extract complex logic into composables
4. **State Management**: Use provide/inject pattern with typed injection keys
5. **Responsive Design**: Implement mobile and desktop variants
6. **Accessibility**: Support keyboard navigation and ARIA attributes

---

## üèóÔ∏è Project Structure

```
src/
‚îú‚îÄ‚îÄ modules/                    # Feature modules
‚îÇ   ‚îî‚îÄ‚îÄ {{module-name}}/
‚îÇ       ‚îú‚îÄ‚îÄ pages/             # Blade components
‚îÇ       ‚îú‚îÄ‚îÄ composables/       # Business logic
‚îÇ       ‚îú‚îÄ‚îÄ components/        # Module-specific components
‚îÇ       ‚îú‚îÄ‚îÄ locales/           # i18n translations
‚îÇ       ‚îî‚îÄ‚îÄ index.ts           # Module exports
‚îú‚îÄ‚îÄ api/                       # API clients
‚îú‚îÄ‚îÄ core/                      # Framework core (DO NOT MODIFY)
‚îî‚îÄ‚îÄ shared/                    # Shared utilities (DO NOT MODIFY)
```

---

## ‚úÖ Essential Patterns

### 1. Blade Structure (Grid View)

```vue
<template>
  <VcBlade
    :title="$t('{{MODULE}}.PAGES.LIST.TITLE')"
    :toolbar-items="bladeToolbar"
    width="70%"
  >
    <!-- Search and filters -->
    <VcCard class="tw-mb-4">
      <VcInput
        v-model="searchValue"
        :placeholder="$t('{{MODULE}}.PAGES.LIST.SEARCH_PLACEHOLDER')"
        clearable
        @update:model-value="onSearchList"
      />
    </VcCard>

    <!-- Data table -->
    <VcCard>
      <VcTable
        :items="items"
        :columns="columns"
        :totalCount="totalCount"
        :pages="pages"
        :currentPage="currentPage"
        :sort="sort"
        state-key="{{module}}-grid"
        @headerClick="onHeaderClick"
        @itemClick="onItemClick"
      >
        <!-- Custom cell templates -->
        <template #item_{{field}}="{ item }">
          {{ item.{{field}} }}
        </template>
      </VcTable>
    </VcCard>
  </VcBlade>
</template>

<script setup lang="ts">
import { computed, ref, onMounted } from "vue";
import { useI18n } from "vue-i18n";
import { use{{Entity}}, useBladeNavigation } from "../composables";
import { IBladeToolbar, ITableColumns } from "@vc-shell/framework";

const { t } = useI18n({ useScope: "global" });
const { openBlade, resolveBladeByName } = useBladeNavigation();
const {
  items,
  totalCount,
  pages,
  currentPage,
  sort,
  loading,
  searchValue,
  load,
  search,
} = use{{Entity}}();

const columns = computed<ITableColumns[]>(() => [
  { id: "{{field}}", title: t("{{MODULE}}.PAGES.LIST.TABLE.{{FIELD}}"), sortable: true, width: 200 },
  // Add more columns
]);

const bladeToolbar = computed<IBladeToolbar[]>(() => [
  {
    id: "add",
    title: t("{{MODULE}}.PAGES.LIST.TOOLBAR.ADD"),
    icon: "material-add",
    async clickHandler() {
      await openBlade({
        blade: resolveBladeByName("{{entity}}-details"),
        param: "new",
      });
    },
  },
]);

function onHeaderClick(column: ITableColumns) {
  // Handle sorting
}

async function onItemClick(item: {{EntityType}}) {
  await openBlade({
    blade: resolveBladeByName("{{entity}}-details"),
    param: item.id,
  });
}

function onSearchList(keyword: string) {
  search(keyword);
}

onMounted(async () => {
  await load();
});
</script>
```

### 2. Blade Structure (Details View)

```vue
<template>
  <VcBlade
    :title="title"
    :toolbar-items="bladeToolbar"
    :modified="modified"
    width="50%"
    @close="onClose"
  >
    <template #actions>
      <VcButton
        :disabled="loading || !modified"
        variant="primary"
        @click="onSave"
      >
        {{ $t("{{MODULE}}.PAGES.DETAILS.TOOLBAR.SAVE") }}
      </VcButton>
    </template>

    <!-- General Information Section -->
    <VcCard :header="$t('{{MODULE}}.PAGES.DETAILS.SECTIONS.GENERAL')" icon="material-info" is-collapsable>
      <VcInput
        v-model="{{entity}}.{{field}}"
        :label="$t('{{MODULE}}.PAGES.DETAILS.FIELDS.{{FIELD}}')"
        required
        :error="!!errors.{{field}}"
        :error-message="errors.{{field}}"
      />
      <!-- Add more fields -->
    </VcCard>

    <!-- Additional Sections -->
    <VcCard :header="$t('{{MODULE}}.PAGES.DETAILS.SECTIONS.{{SECTION}}')" icon="material-settings">
      <!-- Section content -->
    </VcCard>
  </VcBlade>
</template>

<script setup lang="ts">
import { computed, ref, onMounted } from "vue";
import { useI18n } from "vue-i18n";
import { useForm, useField } from "vee-validate";
import * as yup from "yup";
import { use{{Entity}}, useBladeNavigation } from "../composables";
import { IBladeToolbar } from "@vc-shell/framework";

interface Props {
  expanded?: boolean;
  closable?: boolean;
  param?: string;
}

const props = withDefaults(defineProps<Props>(), {
  expanded: true,
  closable: true,
  param: undefined,
});

const { t } = useI18n({ useScope: "global" });
const { close: closeThisBlade } = useBladeNavigation();
const {
  item: {{entity}},
  loading,
  modified,
  load,
  save,
  resetModificationState,
} = use{{Entity}}({
  id: computed(() => props.param),
});

// Validation schema
const validationSchema = yup.object({
  {{field}}: yup.string().required(t("{{MODULE}}.PAGES.DETAILS.VALIDATION.{{FIELD}}_REQUIRED")),
  // Add more validations
});

const { errors, validate } = useForm({
  validationSchema,
  validateOnMount: false,
});

// Form fields
const { value: {{field}} } = useField<string>("{{field}}");

const title = computed(() =>
  {{entity}}.value?.{{nameField}} || t("{{MODULE}}.PAGES.DETAILS.TITLE_NEW")
);

const bladeToolbar = computed<IBladeToolbar[]>(() => [
  // Toolbar items
]);

async function onSave() {
  const { valid } = await validate();
  if (valid) {
    await save();
    resetModificationState();
  }
}

function onClose() {
  closeThisBlade();
}

onMounted(async () => {
  await load();
});
</script>
```

### 3. Composable Pattern

```typescript
import { ref, Ref, computed, unref } from "vue";
import { useLazyAsync, useModificationTracker, useLogger } from "@vc-shell/framework";
import { {{EntityClient}} } from "@/api/{{module}}";

export interface Use{{Entity}}Scope {
  item: Ref<{{EntityType}} | undefined>;
  loading: Ref<boolean>;
  modified: Ref<boolean>;
  load: () => Promise<void>;
  save: () => Promise<void>;
  remove: () => Promise<void>;
  resetModificationState: () => void;
}

interface Use{{Entity}}Options {
  id: Ref<string | undefined>;
}

export function use{{Entity}}(options: Use{{Entity}}Options): Use{{Entity}}Scope {
  const { id } = options;
  const logger = useLogger();
  const apiClient = new {{EntityClient}}();

  const { innerLoading: loading, exec } = useLazyAsync();

  const item = ref<{{EntityType}}>();
  const pristineValue = ref<{{EntityType}}>();

  // Track modifications
  const { modified, currentValue, pristineValue: trackedPristine, resetModificationState } = useModificationTracker({
    currentValue: computed(() => item.value),
    pristineValue: computed(() => pristineValue.value),
  });

  async function load() {
    const itemId = unref(id);
    if (!itemId || itemId === "new") {
      item.value = createDefaultEntity();
      pristineValue.value = createDefaultEntity();
      return;
    }

    await exec(async () => {
      const result = await apiClient.get{{ Entity }}(itemId);
      item.value = result;
      pristineValue.value = { ...result };
    });
  }

  async function save() {
    if (!item.value) return;

    await exec(async () => {
      const itemId = unref(id);
      if (!itemId || itemId === "new") {
        const created = await apiClient.create{{ Entity }}(item.value!);
        item.value = created;
        pristineValue.value = { ...created };
      } else {
        const updated = await apiClient.update{{ Entity }}(item.value!);
        item.value = updated;
        pristineValue.value = { ...updated };
      }
      logger.info("{{Entity}} saved successfully");
    });
  }

  async function remove() {
    const itemId = unref(id);
    if (!itemId) return;

    await exec(async () => {
      await apiClient.delete{{ Entity }}(itemId);
      logger.info("{{Entity}} removed successfully");
    });
  }

  function createDefaultEntity(): {{EntityType}} {
    return {
      // Default values
    };
  }

  return {
    item,
    loading,
    modified,
    load,
    save,
    remove,
    resetModificationState,
  };
}
```

### 4. Widget Pattern

**CRITICAL:** Widgets ONLY use VcWidget props. NO custom HTML inside.

```vue
<template>
  <VcWidget
    :value="count"
    :title="$t('{{MODULE}}.WIDGETS.{{WIDGET}}.TITLE')"
    icon="material-{{icon}}"
    :loading="loading"
    @click="handleClick"
  />
</template>

<script setup lang="ts">
import { ref, onMounted } from "vue";
import { VcWidget, useBladeNavigation } from "@vc-shell/framework";
import { {{EntityClient}} } from "@/api/{{module}}";

interface Props {
  item: {{EntityType}};
}

const props = defineProps<Props>();

const { openBlade, resolveBladeByName } = useBladeNavigation();
const count = ref(0);
const loading = ref(false);
const widgetOpened = ref(false);

async function loadCount() {
  loading.value = true;
  try {
    const client = new {{EntityClient}}();
    const result = await client.get{{Entity}}Count(props.item.id);
    count.value = result;
  } finally {
    loading.value = false;
  }
}

function handleClick() {
  if (!widgetOpened.value) {
    openBlade({
      blade: resolveBladeByName("{{widget}}-list"),
      options: {
        {{entityId}}: props.item.id,
      },
      onOpen() {
        widgetOpened.value = true;
      },
      onClose() {
        widgetOpened.value = false;
      },
    });
  }
}

onMounted(() => {
  loadCount();
});
</script>
```

### 5. API Client Pattern

```typescript
import { IAuthApiBase } from "@vc-shell/framework";

export interface {{EntityType}} {
  id?: string;
  {{field}}: string;
  // Add all entity properties
}

export class {{EntityClient}} {
  constructor(private readonly apiClient: IAuthApiBase) {}

  async get{{Entity}}(id: string): Promise<{{EntityType}}> {
    return this.apiClient.get(`/api/{{module}}/${id}`);
  }

  async search{{Entities}}(query: {{SearchQuery}}): Promise<{{SearchResult}}> {
    return this.apiClient.post(`/api/{{module}}/search`, query);
  }

  async create{{Entity}}(entity: {{EntityType}}): Promise<{{EntityType}}> {
    return this.apiClient.post(`/api/{{module}}`, entity);
  }

  async update{{Entity}}(entity: {{EntityType}}): Promise<{{EntityType}}> {
    return this.apiClient.put(`/api/{{module}}/${entity.id}`, entity);
  }

  async delete{{Entity}}(id: string): Promise<void> {
    return this.apiClient.delete(`/api/{{module}}/${id}`);
  }
}
```

---

## üö´ Deprecated Patterns - DO NOT USE

### ‚ùå WRONG: Custom HTML in VcWidget

```vue
<!-- NEVER DO THIS -->
<VcWidget>
  <div class="custom-content">
    <span>{{ customText }}</span>
  </div>
</VcWidget>
```

### ‚úÖ CORRECT: Props Only

```vue
<VcWidget
  :value="count"
  :title="title"
  icon="material-analytics"
  @click="handleClick"
/>
```

### ‚ùå WRONG: Tabs for Sections

```vue
<!-- TABS DON'T EXIST IN VC-SHELL -->
<VcTabs>
  <VcTab title="General">...</VcTab>
</VcTabs>
```

### ‚úÖ CORRECT: Multiple VcCard

```vue
<VcCard header="General Information">...</VcCard>
<VcCard header="Additional Settings">...</VcCard>
```

### ‚ùå WRONG: Incorrect useModificationTracker

```vue
<script>
// WRONG - missing pristineValue
const { modified } = useModificationTracker({
  currentValue: computed(() => item.value)
});
</script>
```

### ‚úÖ CORRECT: Complete Tracker Setup

```typescript
const { modified, currentValue, pristineValue, resetModificationState } = useModificationTracker({
  currentValue: computed(() => item.value),
  pristineValue: computed(() => pristineSnapshot.value),
});
```

---

## üé® UI Component Patterns

### Form Fields

```vue
<!-- Text Input -->
<VcInput
  v-model="entity.field"
  label="Field Label"
  required
  :error="!!errors.field"
  :error-message="errors.field"
/>

<!-- Textarea -->
<VcTextarea
  v-model="entity.description"
  label="Description"
  :maxlength="1000"
  placeholder="Enter description"
/>

<!-- Select -->
<VcSelect
  v-model="entity.categoryId"
  :options="categories"
  option-label="name"
  option-value="id"
  label="Category"
  searchable
  emit-value
/>

<!-- Rich Text -->
<VcEditor
  v-model="entity.description"
  label="Description"
  :toolbar="['bold', 'italic', 'bulletList', 'link']"
  :maxlength="5000"
/>

<!-- Gallery -->
<VcGallery
  :images="entity.images"
  label="Images"
  multiple
  @upload="handleUpload"
  @sort="handleSort"
/>

<!-- Currency -->
<VcInputCurrency
  v-model="entity.price"
  v-model:option="entity.currency"
  :options="currencies"
  label="Price"
  :precision="2"
/>

<!-- Multi-value -->
<VcMultivalue
  v-model="entity.tags"
  label="Tags"
  placeholder="Enter tag"
/>

<!-- Switch -->
<VcSwitch
  v-model="entity.isActive"
  label="Active"
/>

<!-- Checkbox -->
<VcCheckbox
  v-model="entity.featured"
  label="Featured"
  tooltip="Show on homepage"
/>

<!-- Radio Button Group -->
<VcRadioButton
  v-model="entity.status"
  value="active"
  label="Active"
  name="status"
/>
<VcRadioButton
  v-model="entity.status"
  value="inactive"
  label="Inactive"
  name="status"
/>

<!-- File Upload -->
<VcFileUpload
  :accept="'.pdf, .doc'"
  multiple
  @upload="handleFileUpload"
/>
```

### Grouping Content

```vue
<!-- Use VcCard for sections -->
<VcCard header="General Information" icon="material-info" is-collapsable>
  <VcInput v-model="entity.name" label="Name" />
  <VcInput v-model="entity.sku" label="SKU" />
</VcCard>

<!-- Nested tables -->
<VcCard header="Related Items">
  <VcTable
    :items="entity.items"
    :columns="itemColumns"
    state-key="nested-items"
  >
    <template #item_name="{ item }">
      {{ item.name }}
    </template>
  </VcTable>
</VcCard>
```

### Computed Fields

```typescript
// Use Vue computed for calculated values
const totalPrice = computed(() => {
  return entity.value.items.reduce((sum, item) => sum + item.price, 0);
});

const displayName = computed(() => {
  return `${entity.value.firstName} ${entity.value.lastName}`;
});
```

---

## ‚úîÔ∏è Verification Steps

Before submitting generated code, verify:

1. **TypeScript**: All types are defined, no `any` types
2. **Imports**: All framework components are imported from `@vc-shell/framework`
3. **Validation**: VeeValidate schema is properly configured
4. **i18n**: All text uses `$t()` or `t()` from `useI18n`
5. **Composables**: Business logic is extracted to composables
6. **Modification Tracking**: `useModificationTracker` is correctly implemented
7. **Error Handling**: Try-catch blocks for async operations
8. **Responsive**: Mobile and desktop considerations
9. **Accessibility**: Keyboard navigation and ARIA attributes
10. **VcWidget**: Only props are used, no custom content

**Failure to verify will result in:**
- TypeScript compilation errors
- Runtime errors
- Poor user experience
- Non-functional modifications tracking
- Inaccessible UI

---

## üîß CLI Commands Reference

```bash
# Create new application
npx create-vc-app my-app

# Generate module with grid blade
npx create-vc-app generate \
  --module products \
  --type grid \
  --name product \
  --form-fields "name:text,sku:text,price:currency"

# Generate details blade
npx create-vc-app generate \
  --module products \
  --type details \
  --name product \
  --form-fields "name:text,description:editor,price:currency,images:gallery"

# Generate widget
npx create-vc-app generate \
  --widget-module products \
  --widget-blade product-details \
  --widget-name ProductStats \
  --widget-entity product \
  --widget-icon analytics
```

---

## üêõ Common Pitfalls & Solutions

| Issue | Solution |
|-------|----------|
| VcWidget not clickable | Remove custom HTML, use only props |
| Modified state not working | Ensure both `currentValue` and `pristineValue` are provided to `useModificationTracker` |
| Table state not persisting | Provide unique `stateKey` prop |
| VcEditor character limit | Limit applies to Markdown/HTML source, not rendered text |
| Async VcSelect not loading | Return `{ results, totalCount }` from async function |
| Section not showing | Use `VcCard` with `header` prop, NOT tabs |
| Computed field not reactive | Use Vue `computed()`, not plain function |
| Nested data not displaying | Use `VcTable` inside `VcCard` for related data |
| Validation not triggering | Call `validate()` before `save()` |
| i18n keys not found | Ensure keys follow `{{MODULE}}.{{SECTION}}.{{KEY}}` pattern |
| Checkbox not working with arrays | Use `value` prop for array mode, omit for boolean |
| Radio buttons not grouped | Ensure all options share the same `name` prop |
| Multi-line text not displaying | Use `VcTextarea` instead of `VcInput` with type="textarea" |
| Icon not showing | Verify correct prefix: `material-`, `fas fa-`, `bi-`, `lucide-` |
| Popup not closing | Handle `@close` event to remove popup from DOM |
| File upload accepting wrong types | Set `accept` prop with correct file extensions |
| Tooltip overflow | Tooltip auto-adjusts with `shift` middleware |

---

## üìö Additional Resources

**CRITICAL:** Before starting ANY development task, consult these resources:

1. **UI Components Reference** (`ai-guides/UI_COMPONENTS_REFERENCE.md`)
   - Complete documentation for all 27 UI components
   - Props, events, slots, and usage examples
   - Common pitfalls and solutions

2. **Prompt Templates** (`ai-guides/prompts/`)
   - `quick-start-scenarios.md` - 10 ready-to-use module templates
   - `simple-modifications.md` - 65+ modification templates
   - `advanced-scenarios.md` - Complex patterns (wizards, multi-step forms, etc.)
   - `cli-usage.md` - Complete CLI command reference
   - `api-client-generation.md` - API integration patterns
   - `adapt-existing-module.md` - Module adaptation guide

3. **Technical Guides** (`ai-guides/guides/`)
   - `complete-workflow.md` - Full development lifecycle
   - `composables-reference.md` - Framework composables guide
   - `blade-patterns.md` - Blade architecture patterns
   - `troubleshooting.md` - Common issues and solutions
   - `AI_GUIDE.md` - AI-specific development instructions

4. **CLI Commands**
   ```bash
   # Generate module with grid blade
   npx create-vc-app generate --module {name} --type grid --name {entity} --form-fields "{fields}"

   # Generate details blade
   npx create-vc-app generate --module {name} --type details --name {entity} --form-fields "{fields}"

   # Generate widget
   npx create-vc-app generate --widget-module {module} --widget-blade {blade} --widget-name {name} --widget-entity {entity}
   ```

**WORKFLOW FOR AI:**
1. User provides requirement
2. Check `ai-guides/prompts/` for matching template
3. If using CLI: Use non-interactive mode with all parameters
4. If modifying: Follow patterns from `ai-guides/guides/`
5. Always use components from `ai-guides/UI_COMPONENTS_REFERENCE.md`
6. Verify against checklist in this file

---

## üéì Quick Start Checklist

When creating a new module:

- [ ] Generate grid blade with CLI
- [ ] Generate details blade with CLI
- [ ] Create composable for business logic
- [ ] Implement API client
- [ ] Add validation schema
- [ ] Create localization keys
- [ ] Group fields with VcCard
- [ ] Add modification tracking
- [ ] Implement save/load logic
- [ ] Test all CRUD operations
- [ ] Verify mobile responsiveness
- [ ] Check keyboard navigation

---

## üí° Best Practices

1. **Single Responsibility**: Each composable handles one entity
2. **Type Everything**: No `any` types, use proper interfaces
3. **Extract Logic**: Move business logic to composables
4. **Use Framework**: Prefer framework utilities over custom implementations
5. **Consistent Naming**: Follow `use{{Entity}}` pattern for composables
6. **Error Handling**: Always wrap async calls in try-catch
7. **Loading States**: Show loading indicators during async operations
8. **Validation First**: Validate before saving
9. **i18n Everything**: Never hardcode text
10. **Test Edge Cases**: Handle empty states, errors, and loading

---

**Remember**: VC-Shell provides a complete set of components and patterns. Use them instead of creating custom solutions.
