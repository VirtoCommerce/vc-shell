/**
 * ComposableSynthesizer
 *
 * Composables are already generated by create-vc-app!
 * This class only modifies them if needed based on UI-Plan.
 */

import fs from "node:fs/promises";
import path from "node:path";

export interface ComposableOptions {
  /**
   * Project working directory
   */
  cwd: string;

  /**
   * Module name
   */
  moduleName: string;

  /**
   * Entity name
   */
  entityName: string;

  /**
   * Blade type
   */
  bladeType: "list" | "details";

  /**
   * Features to add
   */
  features: string[];
}

export interface ComposableResult {
  /**
   * Path to composable file
   */
  composablePath: string;

  /**
   * Success flag
   */
  success: boolean;

  /**
   * Error if failed
   */
  error?: string;
}

/**
 * ComposableSynthesizer
 *
 * Modifies composables generated by create-vc-app according to UI-Plan features.
 * Does NOT generate composables from scratch - they're already created by create-vc-app!
 */
export class ComposableSynthesizer {
  /**
   * Modify existing composable based on features
   */
  async synthesize(options: ComposableOptions): Promise<ComposableResult> {
    try {
      const composablePath = this.getComposablePath(options);

      // Check if composable exists (should be created by create-vc-app)
      try {
        await fs.access(composablePath);
      } catch {
        return {
          composablePath,
          success: false,
          error: `Composable not found at ${composablePath}. It should be created by create-vc-app first.`,
        };
      }

      // Read composable
      let content = await fs.readFile(composablePath, "utf-8");

      // Apply modifications based on features
      content = this.applyFeatureModifications(content, options.features);

      // Write modified content
      await fs.writeFile(composablePath, content, "utf-8");

      return {
        composablePath,
        success: true,
      };
    } catch (error) {
      return {
        composablePath: "",
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Apply feature-specific modifications
   */
  private applyFeatureModifications(content: string, features: string[]): string {
    let modified = content;

    // Add feature-specific logic
    for (const feature of features) {
      switch (feature) {
        case "filters":
          modified = this.addFiltersSupport(modified);
          break;
        case "multiselect":
          modified = this.addMultiselectSupport(modified);
          break;
        case "validation":
          modified = this.addValidationSupport(modified);
          break;
        // Add more features as needed
      }
    }

    return modified;
  }

  /**
   * Add filters support
   */
  private addFiltersSupport(content: string): string {
    // create-vc-app already includes filters in grid composables
    // This is just a placeholder for additional customization
    return content;
  }

  /**
   * Add multiselect support
   */
  private addMultiselectSupport(content: string): string {
    // create-vc-app already includes multiselect
    // Placeholder for customization
    return content;
  }

  /**
   * Add validation support
   */
  private addValidationSupport(content: string): string {
    // create-vc-app already includes validation in details composables
    // Placeholder for customization
    return content;
  }

  /**
   * Get composable file path
   */
  private getComposablePath(options: ComposableOptions): string {
    const modulePath = path.join(options.cwd, "src", "modules", options.moduleName);
    const EntityName = this.capitalize(options.entityName);

    const composableName =
      options.bladeType === "list"
        ? `use${EntityName}s.ts` // Grid composable
        : `use${EntityName}Details.ts`; // Details composable

    return path.join(modulePath, "composables", composableName);
  }

  /**
   * Capitalize string
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
