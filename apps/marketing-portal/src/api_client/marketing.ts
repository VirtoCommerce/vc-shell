//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AuthApiBase {
  authToken = "";
  protected constructor() {}

  // Enforce always return empty string as baseUrl
  getBaseUrl(defaultUrl: string, baseUrl: string) {
    return "";
  }

  setAuthToken(token: string) {
    this.authToken = token;
  }

  protected transformOptions(options: any): Promise<any> {
    options.headers['authorization'] =  `Bearer ${this.authToken}`;
    return Promise.resolve(options);
  }
}

export class MarketingModuleDynamicContentClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("http://marketing-platform.dev.govirto.com:443", baseUrl);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dynamicContentPlaceListEntriesSearch(body: DynamicContentPlaceSearchCriteria | undefined): Promise<DynamicContentListEntrySearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces/listentries/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDynamicContentPlaceListEntriesSearch(_response);
        });
    }

    protected processDynamicContentPlaceListEntriesSearch(response: Response): Promise<DynamicContentListEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentListEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentListEntrySearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dynamicContentPlacesSearch(body: DynamicContentPlaceSearchCriteria | undefined): Promise<DynamicContentPlaceSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDynamicContentPlacesSearch(_response);
        });
    }

    protected processDynamicContentPlacesSearch(response: Response): Promise<DynamicContentPlaceSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPlaceSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPlaceSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dynamicContentItemsEntriesSearch(body: DynamicContentItemSearchCriteria | undefined): Promise<DynamicContentListEntrySearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/listentries/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDynamicContentItemsEntriesSearch(_response);
        });
    }

    protected processDynamicContentItemsEntriesSearch(response: Response): Promise<DynamicContentListEntrySearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentListEntrySearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentListEntrySearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dynamicContentItemsSearch(body: DynamicContentItemSearchCriteria | undefined): Promise<DynamicContentItemSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDynamicContentItemsSearch(_response);
        });
    }

    protected processDynamicContentItemsSearch(response: Response): Promise<DynamicContentItemSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentItemSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItemSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    dynamicContentPublicationsSearch(body: DynamicContentPublicationSearchCriteria | undefined): Promise<DynamicContentPublicationSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDynamicContentPublicationsSearch(_response);
        });
    }

    protected processDynamicContentPublicationsSearch(response: Response): Promise<DynamicContentPublicationSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublicationSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublicationSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    evaluateDynamicContent(body: DynamicContentEvaluationContext | undefined): Promise<DynamicContentItem[]> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEvaluateDynamicContent(_response);
        });
    }

    protected processEvaluateDynamicContent(response: Response): Promise<DynamicContentItem[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DynamicContentItem.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItem[]>(null as any);
    }

    /**
     * @return Success
     */
    getDynamicContentById(id: string | null): Promise<DynamicContentItem> {
        let url_ = this.baseUrl + "/api/marketing/contentitems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDynamicContentById(_response);
        });
    }

    protected processGetDynamicContentById(response: Response): Promise<DynamicContentItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItem>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDynamicContent(body: DynamicContentItem | undefined): Promise<DynamicContentItem> {
        let url_ = this.baseUrl + "/api/marketing/contentitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDynamicContent(_response);
        });
    }

    protected processCreateDynamicContent(response: Response): Promise<DynamicContentItem> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentItem.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentItem>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDynamicContent(body: DynamicContentItem | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentitems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateDynamicContent(_response);
        });
    }

    protected processUpdateDynamicContent(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteDynamicContents(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentitems?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteDynamicContents(_response);
        });
    }

    protected processDeleteDynamicContents(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getDynamicContentPlaceById(id: string | null): Promise<DynamicContentPlace> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDynamicContentPlaceById(_response);
        });
    }

    protected processGetDynamicContentPlaceById(response: Response): Promise<DynamicContentPlace> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPlace.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPlace>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDynamicContentPlace(body: DynamicContentPlace | undefined): Promise<DynamicContentPlace> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDynamicContentPlace(_response);
        });
    }

    protected processCreateDynamicContentPlace(response: Response): Promise<DynamicContentPlace> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPlace.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPlace>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDynamicContentPlace(body: DynamicContentPlace | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateDynamicContentPlace(_response);
        });
    }

    protected processUpdateDynamicContentPlace(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteDynamicContentPlaces(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentplaces?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteDynamicContentPlaces(_response);
        });
    }

    protected processDeleteDynamicContentPlaces(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getNewDynamicPublication(): Promise<DynamicContentPublication> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewDynamicPublication(_response);
        });
    }

    protected processGetNewDynamicPublication(response: Response): Promise<DynamicContentPublication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublication.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublication>(null as any);
    }

    /**
     * @return Success
     */
    getDynamicContentPublicationById(id: string | null): Promise<DynamicContentPublication> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDynamicContentPublicationById(_response);
        });
    }

    protected processGetDynamicContentPublicationById(response: Response): Promise<DynamicContentPublication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublication.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublication>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDynamicContentPublication(body: DynamicContentPublication | undefined): Promise<DynamicContentPublication> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDynamicContentPublication(_response);
        });
    }

    protected processCreateDynamicContentPublication(response: Response): Promise<DynamicContentPublication> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentPublication.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentPublication>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDynamicContentPublication(body: DynamicContentPublication | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateDynamicContentPublication(_response);
        });
    }

    protected processUpdateDynamicContentPublication(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteDynamicContentPublications(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentpublications?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteDynamicContentPublications(_response);
        });
    }

    protected processDeleteDynamicContentPublications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getDynamicContentFolderById(id: string | null): Promise<DynamicContentFolder> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDynamicContentFolderById(_response);
        });
    }

    protected processGetDynamicContentFolderById(response: Response): Promise<DynamicContentFolder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentFolder.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentFolder>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDynamicContentFolder(body: DynamicContentFolder | undefined): Promise<DynamicContentFolder> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateDynamicContentFolder(_response);
        });
    }

    protected processCreateDynamicContentFolder(response: Response): Promise<DynamicContentFolder> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicContentFolder.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DynamicContentFolder>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDynamicContentFolder(body: DynamicContentFolder | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateDynamicContentFolder(_response);
        });
    }

    protected processUpdateDynamicContentFolder(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteDynamicContentFolders(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/contentfolders?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteDynamicContentFolders(_response);
        });
    }

    protected processDeleteDynamicContentFolders(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class MarketingModulePromotionClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("http://marketing-platform.dev.govirto.com:443", baseUrl);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    promotionsSearch(body: PromotionSearchCriteria | undefined): Promise<PromotionSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/promotions/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPromotionsSearch(_response);
        });
    }

    protected processPromotionsSearch(response: Response): Promise<PromotionSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PromotionSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PromotionSearchResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    evaluatePromotions(body: PromotionEvaluationContext | undefined): Promise<PromotionReward[]> {
        let url_ = this.baseUrl + "/api/marketing/promotions/evaluate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEvaluatePromotions(_response);
        });
    }

    protected processEvaluatePromotions(response: Response): Promise<PromotionReward[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PromotionReward.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PromotionReward[]>(null as any);
    }

    /**
     * @return Success
     */
    getPromotionById(id: string | null): Promise<Promotion> {
        let url_ = this.baseUrl + "/api/marketing/promotions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPromotionById(_response);
        });
    }

    protected processGetPromotionById(response: Response): Promise<Promotion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Promotion.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Promotion>(null as any);
    }

    /**
     * @return Success
     */
    getNewDynamicPromotion(): Promise<Promotion> {
        let url_ = this.baseUrl + "/api/marketing/promotions/new";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetNewDynamicPromotion(_response);
        });
    }

    protected processGetNewDynamicPromotion(response: Response): Promise<Promotion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Promotion.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Promotion>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPromotion(body: Promotion | undefined): Promise<Promotion> {
        let url_ = this.baseUrl + "/api/marketing/promotions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreatePromotion(_response);
        });
    }

    protected processCreatePromotion(response: Response): Promise<Promotion> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Promotion.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Promotion>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePromotions(body: Promotion | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdatePromotions(_response);
        });
    }

    protected processUpdatePromotions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deletePromotions(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeletePromotions(_response);
        });
    }

    protected processDeletePromotions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchCoupons(body: CouponSearchCriteria | undefined): Promise<CouponSearchResult> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchCoupons(_response);
        });
    }

    protected processSearchCoupons(response: Response): Promise<CouponSearchResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponSearchResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CouponSearchResult>(null as any);
    }

    /**
     * @return Success
     */
    getCoupon(id: string | null): Promise<Coupon> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCoupon(_response);
        });
    }

    protected processGetCoupon(response: Response): Promise<Coupon> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Coupon.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Coupon>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addCoupons(body: Coupon[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddCoupons(_response);
        });
    }

    protected processAddCoupons(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ids (optional) 
     * @return Success
     */
    deleteCoupons(ids: string[] | null | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/delete?";
        if (ids !== undefined && ids !== null)
            ids && ids.forEach(item => { url_ += "ids=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteCoupons(_response);
        });
    }

    protected processDeleteCoupons(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importCoupons(body: ImportRequest | undefined): Promise<ImportNotification> {
        let url_ = this.baseUrl + "/api/marketing/promotions/coupons/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processImportCoupons(_response);
        });
    }

    protected processImportCoupons(response: Response): Promise<ImportNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportNotification>(null as any);
    }
}

export enum SortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class SortInfo implements ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sortColumn = _data["sortColumn"];
            this.sortDirection = _data["sortDirection"];
        }
    }

    static fromJS(data: any): SortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortColumn"] = this.sortColumn;
        data["sortDirection"] = this.sortDirection;
        return data;
    }
}

export interface ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortDirection;
}

export class DynamicContentPlaceSearchCriteria implements IDynamicContentPlaceSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicContentPlaceSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.folderId = _data["folderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicContentPlaceSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPlaceSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["folderId"] = this.folderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IDynamicContentPlaceSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class DynamicContentListEntry implements IDynamicContentListEntry {
    objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentListEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentListEntry {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentListEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicContentListEntry {
    objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentListEntrySearchResult implements IDynamicContentListEntrySearchResult {
    totalCount?: number;
    results?: DynamicContentListEntry[] | undefined;

    constructor(data?: IDynamicContentListEntrySearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentListEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentListEntrySearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentListEntrySearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicContentListEntrySearchResult {
    totalCount?: number;
    results?: DynamicContentListEntry[] | undefined;
}

export class DynamicContentFolder implements IDynamicContentFolder {
    readonly path?: string | undefined;
    readonly outline?: string | undefined;
    parentFolderId?: string | undefined;
    parentFolder?: DynamicContentFolder;
    readonly objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).path = _data["path"];
            (<any>this).outline = _data["outline"];
            this.parentFolderId = _data["parentFolderId"];
            this.parentFolder = _data["parentFolder"] ? DynamicContentFolder.fromJS(_data["parentFolder"]) : <any>undefined;
            (<any>this).objectType = _data["objectType"];
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentFolder {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentFolder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path;
        data["outline"] = this.outline;
        data["parentFolderId"] = this.parentFolderId;
        data["parentFolder"] = this.parentFolder ? this.parentFolder.toJSON() : <any>undefined;
        data["objectType"] = this.objectType;
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicContentFolder {
    path?: string | undefined;
    outline?: string | undefined;
    parentFolderId?: string | undefined;
    parentFolder?: DynamicContentFolder;
    objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentPlace implements IDynamicContentPlace {
    readonly outline?: string | undefined;
    readonly path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentPlace) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            this.folderId = _data["folderId"];
            this.folder = _data["folder"] ? DynamicContentFolder.fromJS(_data["folder"]) : <any>undefined;
            this.objectType = _data["objectType"];
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentPlace {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPlace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["folderId"] = this.folderId;
        data["folder"] = this.folder ? this.folder.toJSON() : <any>undefined;
        data["objectType"] = this.objectType;
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicContentPlace {
    outline?: string | undefined;
    path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    objectType?: string | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentPlaceSearchResult implements IDynamicContentPlaceSearchResult {
    totalCount?: number;
    results?: DynamicContentPlace[] | undefined;

    constructor(data?: IDynamicContentPlaceSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentPlace.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentPlaceSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPlaceSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicContentPlaceSearchResult {
    totalCount?: number;
    results?: DynamicContentPlace[] | undefined;
}

export class DynamicContentItemSearchCriteria implements IDynamicContentItemSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicContentItemSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.folderId = _data["folderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicContentItemSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentItemSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["folderId"] = this.folderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IDynamicContentItemSearchCriteria {
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export enum DynamicPropertyValueType {
    Undefined = "Undefined",
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    Html = "Html",
    Image = "Image",
}

export class DynamicPropertyObjectValue implements IDynamicPropertyObjectValue {
    objectType?: string | undefined;
    objectId?: string | undefined;
    locale?: string | undefined;
    value?: any | undefined;
    valueId?: string | undefined;
    valueType?: DynamicPropertyValueType;
    propertyId?: string | undefined;
    propertyName?: string | undefined;

    constructor(data?: IDynamicPropertyObjectValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectType = _data["objectType"];
            this.objectId = _data["objectId"];
            this.locale = _data["locale"];
            this.value = _data["value"];
            this.valueId = _data["valueId"];
            this.valueType = _data["valueType"];
            this.propertyId = _data["propertyId"];
            this.propertyName = _data["propertyName"];
        }
    }

    static fromJS(data: any): DynamicPropertyObjectValue {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyObjectValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectType"] = this.objectType;
        data["objectId"] = this.objectId;
        data["locale"] = this.locale;
        data["value"] = this.value;
        data["valueId"] = this.valueId;
        data["valueType"] = this.valueType;
        data["propertyId"] = this.propertyId;
        data["propertyName"] = this.propertyName;
        return data;
    }
}

export interface IDynamicPropertyObjectValue {
    objectType?: string | undefined;
    objectId?: string | undefined;
    locale?: string | undefined;
    value?: any | undefined;
    valueId?: string | undefined;
    valueType?: DynamicPropertyValueType;
    propertyId?: string | undefined;
    propertyName?: string | undefined;
}

export class DynamicPropertyName implements IDynamicPropertyName {
    locale?: string | undefined;
    name?: string | undefined;

    constructor(data?: IDynamicPropertyName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locale = _data["locale"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): DynamicPropertyName {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locale"] = this.locale;
        data["name"] = this.name;
        return data;
    }
}

export interface IDynamicPropertyName {
    locale?: string | undefined;
    name?: string | undefined;
}

export class DynamicObjectProperty implements IDynamicObjectProperty {
    objectId?: string | undefined;
    values?: DynamicPropertyObjectValue[] | undefined;
    name?: string | undefined;
    description?: string | undefined;
    objectType?: string | undefined;
    isArray?: boolean;
    isDictionary?: boolean;
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    valueType?: DynamicPropertyValueType;
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicObjectProperty) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectId = _data["objectId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(DynamicPropertyObjectValue.fromJS(item));
            }
            this.name = _data["name"];
            this.description = _data["description"];
            this.objectType = _data["objectType"];
            this.isArray = _data["isArray"];
            this.isDictionary = _data["isDictionary"];
            this.isMultilingual = _data["isMultilingual"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["displayNames"])) {
                this.displayNames = [] as any;
                for (let item of _data["displayNames"])
                    this.displayNames!.push(DynamicPropertyName.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicObjectProperty {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicObjectProperty();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectId"] = this.objectId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["description"] = this.description;
        data["objectType"] = this.objectType;
        data["isArray"] = this.isArray;
        data["isDictionary"] = this.isDictionary;
        data["isMultilingual"] = this.isMultilingual;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.displayNames)) {
            data["displayNames"] = [];
            for (let item of this.displayNames)
                data["displayNames"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicObjectProperty {
    objectId?: string | undefined;
    values?: DynamicPropertyObjectValue[] | undefined;
    name?: string | undefined;
    description?: string | undefined;
    objectType?: string | undefined;
    isArray?: boolean;
    isDictionary?: boolean;
    isMultilingual?: boolean;
    isRequired?: boolean;
    displayOrder?: number | undefined;
    valueType?: DynamicPropertyValueType;
    displayNames?: DynamicPropertyName[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentItem implements IDynamicContentItem {
    contentType?: string | undefined;
    priority?: number;
    readonly outline?: string | undefined;
    readonly path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    readonly objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contentType = _data["contentType"];
            this.priority = _data["priority"];
            (<any>this).outline = _data["outline"];
            (<any>this).path = _data["path"];
            this.folderId = _data["folderId"];
            this.folder = _data["folder"] ? DynamicContentFolder.fromJS(_data["folder"]) : <any>undefined;
            (<any>this).objectType = _data["objectType"];
            if (Array.isArray(_data["dynamicProperties"])) {
                this.dynamicProperties = [] as any;
                for (let item of _data["dynamicProperties"])
                    this.dynamicProperties!.push(DynamicObjectProperty.fromJS(item));
            }
            this.imageUrl = _data["imageUrl"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentItem {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        data["priority"] = this.priority;
        data["outline"] = this.outline;
        data["path"] = this.path;
        data["folderId"] = this.folderId;
        data["folder"] = this.folder ? this.folder.toJSON() : <any>undefined;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.dynamicProperties)) {
            data["dynamicProperties"] = [];
            for (let item of this.dynamicProperties)
                data["dynamicProperties"].push(item.toJSON());
        }
        data["imageUrl"] = this.imageUrl;
        data["name"] = this.name;
        data["description"] = this.description;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicContentItem {
    contentType?: string | undefined;
    priority?: number;
    outline?: string | undefined;
    path?: string | undefined;
    folderId?: string | undefined;
    folder?: DynamicContentFolder;
    objectType?: string | undefined;
    dynamicProperties?: DynamicObjectProperty[] | undefined;
    imageUrl?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentItemSearchResult implements IDynamicContentItemSearchResult {
    totalCount?: number;
    results?: DynamicContentItem[] | undefined;

    constructor(data?: IDynamicContentItemSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentItemSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentItemSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicContentItemSearchResult {
    totalCount?: number;
    results?: DynamicContentItem[] | undefined;
}

export class DynamicContentPublicationSearchCriteria implements IDynamicContentPublicationSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    placeName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IDynamicContentPublicationSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlyActive = _data["onlyActive"];
            this.store = _data["store"];
            this.placeName = _data["placeName"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.folderId = _data["folderId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): DynamicContentPublicationSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPublicationSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlyActive"] = this.onlyActive;
        data["store"] = this.store;
        data["placeName"] = this.placeName;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["folderId"] = this.folderId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IDynamicContentPublicationSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    placeName?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    folderId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class IConditionTree implements IIConditionTree {
    readonly id?: string | undefined;
    readonly availableChildren?: IConditionTree[] | undefined;
    readonly children?: IConditionTree[] | undefined;

    constructor(data?: IIConditionTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                (<any>this).availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    (<any>this).availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                (<any>this).children = [] as any;
                for (let item of _data["children"])
                    (<any>this).children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IConditionTree {
        data = typeof data === 'object' ? data : {};
        let result = new IConditionTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IIConditionTree {
    id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

export class DynamicContentConditionTree implements IDynamicContentConditionTree {
    all?: boolean;
    not?: boolean;
    readonly id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;

    constructor(data?: IDynamicContentConditionTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.all = _data["all"];
            this.not = _data["not"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                this.availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    this.availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentConditionTree {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentConditionTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["all"] = this.all;
        data["not"] = this.not;
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicContentConditionTree {
    all?: boolean;
    not?: boolean;
    id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

export class DynamicContentPublication implements IDynamicContentPublication {
    name?: string | undefined;
    description?: string | undefined;
    priority?: number;
    isActive?: boolean;
    storeId?: string | undefined;
    dynamicExpression?: DynamicContentConditionTree;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    contentItems?: DynamicContentItem[] | undefined;
    contentPlaces?: DynamicContentPlace[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IDynamicContentPublication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.priority = _data["priority"];
            this.isActive = _data["isActive"];
            this.storeId = _data["storeId"];
            this.dynamicExpression = _data["dynamicExpression"] ? DynamicContentConditionTree.fromJS(_data["dynamicExpression"]) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.outerId = _data["outerId"];
            if (Array.isArray(_data["contentItems"])) {
                this.contentItems = [] as any;
                for (let item of _data["contentItems"])
                    this.contentItems!.push(DynamicContentItem.fromJS(item));
            }
            if (Array.isArray(_data["contentPlaces"])) {
                this.contentPlaces = [] as any;
                for (let item of _data["contentPlaces"])
                    this.contentPlaces!.push(DynamicContentPlace.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicContentPublication {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPublication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["priority"] = this.priority;
        data["isActive"] = this.isActive;
        data["storeId"] = this.storeId;
        data["dynamicExpression"] = this.dynamicExpression ? this.dynamicExpression.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["outerId"] = this.outerId;
        if (Array.isArray(this.contentItems)) {
            data["contentItems"] = [];
            for (let item of this.contentItems)
                data["contentItems"].push(item.toJSON());
        }
        if (Array.isArray(this.contentPlaces)) {
            data["contentPlaces"] = [];
            for (let item of this.contentPlaces)
                data["contentPlaces"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicContentPublication {
    name?: string | undefined;
    description?: string | undefined;
    priority?: number;
    isActive?: boolean;
    storeId?: string | undefined;
    dynamicExpression?: DynamicContentConditionTree;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    contentItems?: DynamicContentItem[] | undefined;
    contentPlaces?: DynamicContentPlace[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class DynamicContentPublicationSearchResult implements IDynamicContentPublicationSearchResult {
    totalCount?: number;
    results?: DynamicContentPublication[] | undefined;

    constructor(data?: IDynamicContentPublicationSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(DynamicContentPublication.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DynamicContentPublicationSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentPublicationSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDynamicContentPublicationSearchResult {
    totalCount?: number;
    results?: DynamicContentPublication[] | undefined;
}

export class DynamicContentEvaluationContext implements IDynamicContentEvaluationContext {
    storeId?: string | undefined;
    placeName?: string | undefined;
    tags?: string[] | undefined;
    toDate?: Date;
    categoryId?: string | undefined;
    productId?: string | undefined;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;

    constructor(data?: IDynamicContentEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
            this.placeName = _data["placeName"];
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.productId = _data["productId"];
            this.contextObject = _data["contextObject"];
            this.geoCity = _data["geoCity"];
            this.geoState = _data["geoState"];
            this.geoCountry = _data["geoCountry"];
            this.geoContinent = _data["geoContinent"];
            this.geoZipCode = _data["geoZipCode"];
            this.geoConnectionType = _data["geoConnectionType"];
            this.geoTimeZone = _data["geoTimeZone"];
            this.geoIpRoutingType = _data["geoIpRoutingType"];
            this.geoIspSecondLevel = _data["geoIspSecondLevel"];
            this.geoIspTopLevel = _data["geoIspTopLevel"];
            this.shopperAge = _data["shopperAge"];
            this.shopperGender = _data["shopperGender"];
            this.language = _data["language"];
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
            this.shopperSearchedPhraseOnInternet = _data["shopperSearchedPhraseOnInternet"];
            this.currentUrl = _data["currentUrl"];
            this.referredUrl = _data["referredUrl"];
        }
    }

    static fromJS(data: any): DynamicContentEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicContentEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        data["placeName"] = this.placeName;
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["productId"] = this.productId;
        data["contextObject"] = this.contextObject;
        data["geoCity"] = this.geoCity;
        data["geoState"] = this.geoState;
        data["geoCountry"] = this.geoCountry;
        data["geoContinent"] = this.geoContinent;
        data["geoZipCode"] = this.geoZipCode;
        data["geoConnectionType"] = this.geoConnectionType;
        data["geoTimeZone"] = this.geoTimeZone;
        data["geoIpRoutingType"] = this.geoIpRoutingType;
        data["geoIspSecondLevel"] = this.geoIspSecondLevel;
        data["geoIspTopLevel"] = this.geoIspTopLevel;
        data["shopperAge"] = this.shopperAge;
        data["shopperGender"] = this.shopperGender;
        data["language"] = this.language;
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
        data["shopperSearchedPhraseOnInternet"] = this.shopperSearchedPhraseOnInternet;
        data["currentUrl"] = this.currentUrl;
        data["referredUrl"] = this.referredUrl;
        return data;
    }
}

export interface IDynamicContentEvaluationContext {
    storeId?: string | undefined;
    placeName?: string | undefined;
    tags?: string[] | undefined;
    toDate?: Date;
    categoryId?: string | undefined;
    productId?: string | undefined;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;
}

export class PromotionSearchCriteria implements IPromotionSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: IPromotionSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.onlyActive = _data["onlyActive"];
            this.store = _data["store"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PromotionSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["onlyActive"] = this.onlyActive;
        data["store"] = this.store;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface IPromotionSearchCriteria {
    onlyActive?: boolean;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class PromotionConditionAndRewardTree implements IPromotionConditionAndRewardTree {
    all?: boolean;
    not?: boolean;
    readonly id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;

    constructor(data?: IPromotionConditionAndRewardTree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.all = _data["all"];
            this.not = _data["not"];
            (<any>this).id = _data["id"];
            if (Array.isArray(_data["availableChildren"])) {
                this.availableChildren = [] as any;
                for (let item of _data["availableChildren"])
                    this.availableChildren!.push(IConditionTree.fromJS(item));
            }
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(IConditionTree.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PromotionConditionAndRewardTree {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionConditionAndRewardTree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["all"] = this.all;
        data["not"] = this.not;
        data["id"] = this.id;
        if (Array.isArray(this.availableChildren)) {
            data["availableChildren"] = [];
            for (let item of this.availableChildren)
                data["availableChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPromotionConditionAndRewardTree {
    all?: boolean;
    not?: boolean;
    id?: string | undefined;
    availableChildren?: IConditionTree[] | undefined;
    children?: IConditionTree[] | undefined;
}

export class Promotion implements IPromotion {
    isAllowCombiningWithSelf?: boolean;
    dynamicExpression?: PromotionConditionAndRewardTree;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    name?: string | undefined;
    type?: string | undefined;
    isActive?: boolean;
    priority?: number;
    isExclusive?: boolean;
    hasCoupons?: boolean;
    description?: string | undefined;
    maxUsageCount?: number;
    maxUsageOnOrder?: number;
    maxPersonalUsageCount?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IPromotion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isAllowCombiningWithSelf = _data["isAllowCombiningWithSelf"];
            this.dynamicExpression = _data["dynamicExpression"] ? PromotionConditionAndRewardTree.fromJS(_data["dynamicExpression"]) : <any>undefined;
            this.store = _data["store"];
            if (Array.isArray(_data["storeIds"])) {
                this.storeIds = [] as any;
                for (let item of _data["storeIds"])
                    this.storeIds!.push(item);
            }
            this.name = _data["name"];
            this.type = _data["type"];
            this.isActive = _data["isActive"];
            this.priority = _data["priority"];
            this.isExclusive = _data["isExclusive"];
            this.hasCoupons = _data["hasCoupons"];
            this.description = _data["description"];
            this.maxUsageCount = _data["maxUsageCount"];
            this.maxUsageOnOrder = _data["maxUsageOnOrder"];
            this.maxPersonalUsageCount = _data["maxPersonalUsageCount"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Promotion {
        data = typeof data === 'object' ? data : {};
        let result = new Promotion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAllowCombiningWithSelf"] = this.isAllowCombiningWithSelf;
        data["dynamicExpression"] = this.dynamicExpression ? this.dynamicExpression.toJSON() : <any>undefined;
        data["store"] = this.store;
        if (Array.isArray(this.storeIds)) {
            data["storeIds"] = [];
            for (let item of this.storeIds)
                data["storeIds"].push(item);
        }
        data["name"] = this.name;
        data["type"] = this.type;
        data["isActive"] = this.isActive;
        data["priority"] = this.priority;
        data["isExclusive"] = this.isExclusive;
        data["hasCoupons"] = this.hasCoupons;
        data["description"] = this.description;
        data["maxUsageCount"] = this.maxUsageCount;
        data["maxUsageOnOrder"] = this.maxUsageOnOrder;
        data["maxPersonalUsageCount"] = this.maxPersonalUsageCount;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IPromotion {
    isAllowCombiningWithSelf?: boolean;
    dynamicExpression?: PromotionConditionAndRewardTree;
    store?: string | undefined;
    storeIds?: string[] | undefined;
    name?: string | undefined;
    type?: string | undefined;
    isActive?: boolean;
    priority?: number;
    isExclusive?: boolean;
    hasCoupons?: boolean;
    description?: string | undefined;
    maxUsageCount?: number;
    maxUsageOnOrder?: number;
    maxPersonalUsageCount?: number;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class PromotionSearchResult implements IPromotionSearchResult {
    totalCount?: number;
    results?: Promotion[] | undefined;

    constructor(data?: IPromotionSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Promotion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PromotionSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPromotionSearchResult {
    totalCount?: number;
    results?: Promotion[] | undefined;
}

export class ProductPromoEntry implements IProductPromoEntry {
    code?: string | undefined;
    quantity?: number;
    inStockQuantity?: number;
    price?: number;
    listPrice?: number;
    discount?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    productId?: string | undefined;
    owner?: any | undefined;
    outline?: string | undefined;
    variations?: ProductPromoEntry[] | undefined;
    attributes?: { [key: string]: string; } | undefined;

    constructor(data?: IProductPromoEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.quantity = _data["quantity"];
            this.inStockQuantity = _data["inStockQuantity"];
            this.price = _data["price"];
            this.listPrice = _data["listPrice"];
            this.discount = _data["discount"];
            this.catalogId = _data["catalogId"];
            this.categoryId = _data["categoryId"];
            this.productId = _data["productId"];
            this.owner = _data["owner"];
            this.outline = _data["outline"];
            if (Array.isArray(_data["variations"])) {
                this.variations = [] as any;
                for (let item of _data["variations"])
                    this.variations!.push(ProductPromoEntry.fromJS(item));
            }
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProductPromoEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPromoEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["quantity"] = this.quantity;
        data["inStockQuantity"] = this.inStockQuantity;
        data["price"] = this.price;
        data["listPrice"] = this.listPrice;
        data["discount"] = this.discount;
        data["catalogId"] = this.catalogId;
        data["categoryId"] = this.categoryId;
        data["productId"] = this.productId;
        data["owner"] = this.owner;
        data["outline"] = this.outline;
        if (Array.isArray(this.variations)) {
            data["variations"] = [];
            for (let item of this.variations)
                data["variations"].push(item.toJSON());
        }
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        return data;
    }
}

export interface IProductPromoEntry {
    code?: string | undefined;
    quantity?: number;
    inStockQuantity?: number;
    price?: number;
    listPrice?: number;
    discount?: number;
    catalogId?: string | undefined;
    categoryId?: string | undefined;
    productId?: string | undefined;
    owner?: any | undefined;
    outline?: string | undefined;
    variations?: ProductPromoEntry[] | undefined;
    attributes?: { [key: string]: string; } | undefined;
}

export class PromotionEvaluationContext implements IPromotionEvaluationContext {
    refusedGiftIds?: string[] | undefined;
    storeId?: string | undefined;
    currency?: string | undefined;
    customerId?: string | undefined;
    isRegisteredUser?: boolean;
    isFirstTimeBuyer?: boolean;
    isEveryone?: boolean;
    cartTotal?: number;
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    shipmentMethodPrice?: number;
    availableShipmentMethodCodes?: string[] | undefined;
    paymentMethodCode?: string | undefined;
    paymentMethodPrice?: number;
    availablePaymentMethodCodes?: string[] | undefined;
    coupon?: string | undefined;
    coupons?: string[] | undefined;
    cartPromoEntries?: ProductPromoEntry[] | undefined;
    promoEntries?: ProductPromoEntry[] | undefined;
    promoEntry?: ProductPromoEntry;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;

    constructor(data?: IPromotionEvaluationContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["refusedGiftIds"])) {
                this.refusedGiftIds = [] as any;
                for (let item of _data["refusedGiftIds"])
                    this.refusedGiftIds!.push(item);
            }
            this.storeId = _data["storeId"];
            this.currency = _data["currency"];
            this.customerId = _data["customerId"];
            this.isRegisteredUser = _data["isRegisteredUser"];
            this.isFirstTimeBuyer = _data["isFirstTimeBuyer"];
            this.isEveryone = _data["isEveryone"];
            this.cartTotal = _data["cartTotal"];
            this.shipmentMethodCode = _data["shipmentMethodCode"];
            this.shipmentMethodOption = _data["shipmentMethodOption"];
            this.shipmentMethodPrice = _data["shipmentMethodPrice"];
            if (Array.isArray(_data["availableShipmentMethodCodes"])) {
                this.availableShipmentMethodCodes = [] as any;
                for (let item of _data["availableShipmentMethodCodes"])
                    this.availableShipmentMethodCodes!.push(item);
            }
            this.paymentMethodCode = _data["paymentMethodCode"];
            this.paymentMethodPrice = _data["paymentMethodPrice"];
            if (Array.isArray(_data["availablePaymentMethodCodes"])) {
                this.availablePaymentMethodCodes = [] as any;
                for (let item of _data["availablePaymentMethodCodes"])
                    this.availablePaymentMethodCodes!.push(item);
            }
            this.coupon = _data["coupon"];
            if (Array.isArray(_data["coupons"])) {
                this.coupons = [] as any;
                for (let item of _data["coupons"])
                    this.coupons!.push(item);
            }
            if (Array.isArray(_data["cartPromoEntries"])) {
                this.cartPromoEntries = [] as any;
                for (let item of _data["cartPromoEntries"])
                    this.cartPromoEntries!.push(ProductPromoEntry.fromJS(item));
            }
            if (Array.isArray(_data["promoEntries"])) {
                this.promoEntries = [] as any;
                for (let item of _data["promoEntries"])
                    this.promoEntries!.push(ProductPromoEntry.fromJS(item));
            }
            this.promoEntry = _data["promoEntry"] ? ProductPromoEntry.fromJS(_data["promoEntry"]) : <any>undefined;
            this.contextObject = _data["contextObject"];
            this.geoCity = _data["geoCity"];
            this.geoState = _data["geoState"];
            this.geoCountry = _data["geoCountry"];
            this.geoContinent = _data["geoContinent"];
            this.geoZipCode = _data["geoZipCode"];
            this.geoConnectionType = _data["geoConnectionType"];
            this.geoTimeZone = _data["geoTimeZone"];
            this.geoIpRoutingType = _data["geoIpRoutingType"];
            this.geoIspSecondLevel = _data["geoIspSecondLevel"];
            this.geoIspTopLevel = _data["geoIspTopLevel"];
            this.shopperAge = _data["shopperAge"];
            this.shopperGender = _data["shopperGender"];
            this.language = _data["language"];
            if (Array.isArray(_data["userGroups"])) {
                this.userGroups = [] as any;
                for (let item of _data["userGroups"])
                    this.userGroups!.push(item);
            }
            this.shopperSearchedPhraseInStore = _data["shopperSearchedPhraseInStore"];
            this.shopperSearchedPhraseOnInternet = _data["shopperSearchedPhraseOnInternet"];
            this.currentUrl = _data["currentUrl"];
            this.referredUrl = _data["referredUrl"];
        }
    }

    static fromJS(data: any): PromotionEvaluationContext {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionEvaluationContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.refusedGiftIds)) {
            data["refusedGiftIds"] = [];
            for (let item of this.refusedGiftIds)
                data["refusedGiftIds"].push(item);
        }
        data["storeId"] = this.storeId;
        data["currency"] = this.currency;
        data["customerId"] = this.customerId;
        data["isRegisteredUser"] = this.isRegisteredUser;
        data["isFirstTimeBuyer"] = this.isFirstTimeBuyer;
        data["isEveryone"] = this.isEveryone;
        data["cartTotal"] = this.cartTotal;
        data["shipmentMethodCode"] = this.shipmentMethodCode;
        data["shipmentMethodOption"] = this.shipmentMethodOption;
        data["shipmentMethodPrice"] = this.shipmentMethodPrice;
        if (Array.isArray(this.availableShipmentMethodCodes)) {
            data["availableShipmentMethodCodes"] = [];
            for (let item of this.availableShipmentMethodCodes)
                data["availableShipmentMethodCodes"].push(item);
        }
        data["paymentMethodCode"] = this.paymentMethodCode;
        data["paymentMethodPrice"] = this.paymentMethodPrice;
        if (Array.isArray(this.availablePaymentMethodCodes)) {
            data["availablePaymentMethodCodes"] = [];
            for (let item of this.availablePaymentMethodCodes)
                data["availablePaymentMethodCodes"].push(item);
        }
        data["coupon"] = this.coupon;
        if (Array.isArray(this.coupons)) {
            data["coupons"] = [];
            for (let item of this.coupons)
                data["coupons"].push(item);
        }
        if (Array.isArray(this.cartPromoEntries)) {
            data["cartPromoEntries"] = [];
            for (let item of this.cartPromoEntries)
                data["cartPromoEntries"].push(item.toJSON());
        }
        if (Array.isArray(this.promoEntries)) {
            data["promoEntries"] = [];
            for (let item of this.promoEntries)
                data["promoEntries"].push(item.toJSON());
        }
        data["promoEntry"] = this.promoEntry ? this.promoEntry.toJSON() : <any>undefined;
        data["contextObject"] = this.contextObject;
        data["geoCity"] = this.geoCity;
        data["geoState"] = this.geoState;
        data["geoCountry"] = this.geoCountry;
        data["geoContinent"] = this.geoContinent;
        data["geoZipCode"] = this.geoZipCode;
        data["geoConnectionType"] = this.geoConnectionType;
        data["geoTimeZone"] = this.geoTimeZone;
        data["geoIpRoutingType"] = this.geoIpRoutingType;
        data["geoIspSecondLevel"] = this.geoIspSecondLevel;
        data["geoIspTopLevel"] = this.geoIspTopLevel;
        data["shopperAge"] = this.shopperAge;
        data["shopperGender"] = this.shopperGender;
        data["language"] = this.language;
        if (Array.isArray(this.userGroups)) {
            data["userGroups"] = [];
            for (let item of this.userGroups)
                data["userGroups"].push(item);
        }
        data["shopperSearchedPhraseInStore"] = this.shopperSearchedPhraseInStore;
        data["shopperSearchedPhraseOnInternet"] = this.shopperSearchedPhraseOnInternet;
        data["currentUrl"] = this.currentUrl;
        data["referredUrl"] = this.referredUrl;
        return data;
    }
}

export interface IPromotionEvaluationContext {
    refusedGiftIds?: string[] | undefined;
    storeId?: string | undefined;
    currency?: string | undefined;
    customerId?: string | undefined;
    isRegisteredUser?: boolean;
    isFirstTimeBuyer?: boolean;
    isEveryone?: boolean;
    cartTotal?: number;
    shipmentMethodCode?: string | undefined;
    shipmentMethodOption?: string | undefined;
    shipmentMethodPrice?: number;
    availableShipmentMethodCodes?: string[] | undefined;
    paymentMethodCode?: string | undefined;
    paymentMethodPrice?: number;
    availablePaymentMethodCodes?: string[] | undefined;
    coupon?: string | undefined;
    coupons?: string[] | undefined;
    cartPromoEntries?: ProductPromoEntry[] | undefined;
    promoEntries?: ProductPromoEntry[] | undefined;
    promoEntry?: ProductPromoEntry;
    contextObject?: any | undefined;
    geoCity?: string | undefined;
    geoState?: string | undefined;
    geoCountry?: string | undefined;
    geoContinent?: string | undefined;
    geoZipCode?: string | undefined;
    geoConnectionType?: string | undefined;
    geoTimeZone?: string | undefined;
    geoIpRoutingType?: string | undefined;
    geoIspSecondLevel?: string | undefined;
    geoIspTopLevel?: string | undefined;
    shopperAge?: number;
    shopperGender?: string | undefined;
    language?: string | undefined;
    userGroups?: string[] | undefined;
    shopperSearchedPhraseInStore?: string | undefined;
    shopperSearchedPhraseOnInternet?: string | undefined;
    currentUrl?: string | undefined;
    referredUrl?: string | undefined;
}

export enum RewardAmountType {
    Absolute = "Absolute",
    Relative = "Relative",
}

export class PromotionReward implements IPromotionReward {
    isValid?: boolean;
    description?: string | undefined;
    couponAmount?: number;
    coupon?: string | undefined;
    couponMinOrderAmount?: number | undefined;
    promotionId?: string | undefined;
    promotion?: Promotion;
    rewardType?: string | undefined;
    amountType?: RewardAmountType;
    amount?: number;
    quantity?: number;
    lineItemId?: string | undefined;
    productId?: string | undefined;
    conditionalProductId?: string | undefined;
    categoryId?: string | undefined;
    measureUnit?: string | undefined;
    imageUrl?: string | undefined;
    shippingMethod?: string | undefined;
    paymentMethod?: string | undefined;
    maxLimit?: number;
    forNthQuantity?: number;
    inEveryNthQuantity?: number;

    constructor(data?: IPromotionReward) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValid = _data["isValid"];
            this.description = _data["description"];
            this.couponAmount = _data["couponAmount"];
            this.coupon = _data["coupon"];
            this.couponMinOrderAmount = _data["couponMinOrderAmount"];
            this.promotionId = _data["promotionId"];
            this.promotion = _data["promotion"] ? Promotion.fromJS(_data["promotion"]) : <any>undefined;
            this.rewardType = _data["rewardType"];
            this.amountType = _data["amountType"];
            this.amount = _data["amount"];
            this.quantity = _data["quantity"];
            this.lineItemId = _data["lineItemId"];
            this.productId = _data["productId"];
            this.conditionalProductId = _data["conditionalProductId"];
            this.categoryId = _data["categoryId"];
            this.measureUnit = _data["measureUnit"];
            this.imageUrl = _data["imageUrl"];
            this.shippingMethod = _data["shippingMethod"];
            this.paymentMethod = _data["paymentMethod"];
            this.maxLimit = _data["maxLimit"];
            this.forNthQuantity = _data["forNthQuantity"];
            this.inEveryNthQuantity = _data["inEveryNthQuantity"];
        }
    }

    static fromJS(data: any): PromotionReward {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionReward();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        data["description"] = this.description;
        data["couponAmount"] = this.couponAmount;
        data["coupon"] = this.coupon;
        data["couponMinOrderAmount"] = this.couponMinOrderAmount;
        data["promotionId"] = this.promotionId;
        data["promotion"] = this.promotion ? this.promotion.toJSON() : <any>undefined;
        data["rewardType"] = this.rewardType;
        data["amountType"] = this.amountType;
        data["amount"] = this.amount;
        data["quantity"] = this.quantity;
        data["lineItemId"] = this.lineItemId;
        data["productId"] = this.productId;
        data["conditionalProductId"] = this.conditionalProductId;
        data["categoryId"] = this.categoryId;
        data["measureUnit"] = this.measureUnit;
        data["imageUrl"] = this.imageUrl;
        data["shippingMethod"] = this.shippingMethod;
        data["paymentMethod"] = this.paymentMethod;
        data["maxLimit"] = this.maxLimit;
        data["forNthQuantity"] = this.forNthQuantity;
        data["inEveryNthQuantity"] = this.inEveryNthQuantity;
        return data;
    }
}

export interface IPromotionReward {
    isValid?: boolean;
    description?: string | undefined;
    couponAmount?: number;
    coupon?: string | undefined;
    couponMinOrderAmount?: number | undefined;
    promotionId?: string | undefined;
    promotion?: Promotion;
    rewardType?: string | undefined;
    amountType?: RewardAmountType;
    amount?: number;
    quantity?: number;
    lineItemId?: string | undefined;
    productId?: string | undefined;
    conditionalProductId?: string | undefined;
    categoryId?: string | undefined;
    measureUnit?: string | undefined;
    imageUrl?: string | undefined;
    shippingMethod?: string | undefined;
    paymentMethod?: string | undefined;
    maxLimit?: number;
    forNthQuantity?: number;
    inEveryNthQuantity?: number;
}

export class CouponSearchCriteria implements ICouponSearchCriteria {
    code?: string | undefined;
    codes?: string[] | undefined;
    promotionId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ICouponSearchCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            if (Array.isArray(_data["codes"])) {
                this.codes = [] as any;
                for (let item of _data["codes"])
                    this.codes!.push(item);
            }
            this.promotionId = _data["promotionId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): CouponSearchCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CouponSearchCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        if (Array.isArray(this.codes)) {
            data["codes"] = [];
            for (let item of this.codes)
                data["codes"].push(item);
        }
        data["promotionId"] = this.promotionId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ICouponSearchCriteria {
    code?: string | undefined;
    codes?: string[] | undefined;
    promotionId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class Coupon implements ICoupon {
    maxUsesNumber?: number;
    maxUsesPerUser?: number;
    expirationDate?: Date | undefined;
    code?: string | undefined;
    promotionId?: string | undefined;
    totalUsesCount?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxUsesNumber = _data["maxUsesNumber"];
            this.maxUsesPerUser = _data["maxUsesPerUser"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.code = _data["code"];
            this.promotionId = _data["promotionId"];
            this.totalUsesCount = _data["totalUsesCount"];
            this.outerId = _data["outerId"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxUsesNumber"] = this.maxUsesNumber;
        data["maxUsesPerUser"] = this.maxUsesPerUser;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["promotionId"] = this.promotionId;
        data["totalUsesCount"] = this.totalUsesCount;
        data["outerId"] = this.outerId;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICoupon {
    maxUsesNumber?: number;
    maxUsesPerUser?: number;
    expirationDate?: Date | undefined;
    code?: string | undefined;
    promotionId?: string | undefined;
    totalUsesCount?: number;
    outerId?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class CouponSearchResult implements ICouponSearchResult {
    totalCount?: number;
    results?: Coupon[] | undefined;

    constructor(data?: ICouponSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Coupon.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CouponSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new CouponSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICouponSearchResult {
    totalCount?: number;
    results?: Coupon[] | undefined;
}

export class ImportRequest implements IImportRequest {
    fileUrl?: string | undefined;
    delimiter?: string | undefined;
    promotionId?: string | undefined;
    expirationDate?: Date | undefined;

    constructor(data?: IImportRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUrl = _data["fileUrl"];
            this.delimiter = _data["delimiter"];
            this.promotionId = _data["promotionId"];
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ImportRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl;
        data["delimiter"] = this.delimiter;
        data["promotionId"] = this.promotionId;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IImportRequest {
    fileUrl?: string | undefined;
    delimiter?: string | undefined;
    promotionId?: string | undefined;
    expirationDate?: Date | undefined;
}

export class ImportNotification implements IImportNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IImportNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            this.errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImportNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ImportNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IImportNotification {
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* eslint-disable */