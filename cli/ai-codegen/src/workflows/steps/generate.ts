/**
 * Generate Step Executor
 *
 * CORRECT WORKFLOW:
 * 1. Run create-vc-app to generate base files (blade, composable, locale)
 * 2. Discover relevant components/hooks from registry (semantic search)
 * 3. Load templates, patterns, rules for this blade type
 * 4. Create enriched prompt/guide for AI
 * 5. Return guide ‚Üí AI will generate final code
 *
 * AI generates code, NOT this step!
 */

import path from "node:path";
import { fileURLToPath } from "node:url";
import type { WorkflowState, WorkflowContext, StepExecutor, StepResult } from "../types";
import type { UIPlan } from "../../generators/types";

/**
 * GenerateStepExecutor
 *
 * Step 5: Prepare generation guides for AI.
 * Each guide contains:
 * - Base files generated by create-vc-app
 * - Relevant components from registry (VcTable, VcForm, etc.)
 * - Relevant framework hooks (useBladeNavigation, useApiClient, etc.)
 * - Templates for this blade type
 * - Patterns to follow
 * - Rules and constraints
 * - Detailed instructions for AI
 */
export class GenerateStepExecutor implements StepExecutor {
  async execute(
    state: WorkflowState,
    context: WorkflowContext,
    input: { plan: UIPlan; cwd: string; bladeId?: string },
  ): Promise<StepResult> {
    const { plan, cwd, bladeId } = input;
    const { kb, componentResolver } = context;

    try {
      console.log(`[GenerateStep] Preparing generation guides for: ${bladeId || "all blades"}`);

      const guides: any[] = [];

      // Filter blades if bladeId provided
      const bladesToGenerate = bladeId
        ? plan.blades.filter((b) => b.id === bladeId)
        : plan.blades;

      if (bladesToGenerate.length === 0) {
        return {
          success: false,
          errors: [`Blade not found: ${bladeId}`],
        };
      }

      // Generate guide for each blade
      for (const blade of bladesToGenerate) {
        console.log(`[GenerateStep] Processing blade: ${blade.id}`);

        // Step 1: Generate base files using create-vc-app
        const entityName = this.extractEntityName(blade.id, blade.type);
        console.log(`[GenerateStep]   ‚Üí Running create-vc-app (non-interactive)...`);

        await this.generateBaseFiles(plan.module, entityName, blade, cwd);
        console.log(`[GenerateStep]   ‚úì Base files created by create-vc-app`);

        // Step 2: Discover relevant components from registry
        console.log(`[GenerateStep]   ‚Üí Discovering components from registry...`);
        const relevantComponents = await this.discoverComponents(blade, componentResolver);
        console.log(`[GenerateStep]   ‚úì Found ${relevantComponents.length} relevant components`);

        // Step 3: Discover relevant framework hooks/APIs
        console.log(`[GenerateStep]   ‚Üí Discovering framework hooks...`);
        const relevantHooks = await this.discoverFrameworkHooks(blade, kb);
        console.log(`[GenerateStep]   ‚úì Found ${relevantHooks.length} relevant hooks`);

        // Step 4: Load best template
        console.log(`[GenerateStep]   ‚Üí Loading template...`);
        const template = kb.templates.findBestMatch(blade.type, blade.features || []);
        if (template) {
          // Load template content
          template.content = await kb.templates.getContent(template.id);
          console.log(`[GenerateStep]   ‚úì Template: ${template.id} (${template.complexity})`);
        }

        // Step 5: Load relevant patterns
        console.log(`[GenerateStep]   ‚Üí Loading patterns...`);
        const patterns = kb.patterns.getForBladeType(blade.type);
        const relevantPatterns = blade.features?.length
          ? patterns.filter((p: any) => blade.features!.some((f: string) => p.features.includes(f)))
          : patterns.slice(0, 5); // Top 5 if no specific features

        // Load pattern content
        for (const pattern of relevantPatterns) {
          pattern.content = await kb.patterns.getContent(pattern.id);
        }
        console.log(`[GenerateStep]   ‚úì Loaded ${relevantPatterns.length} patterns`);

        // Step 6: Load applicable rules
        console.log(`[GenerateStep]   ‚Üí Loading rules...`);
        const rules = this.getApplicableRules(blade, kb);
        console.log(`[GenerateStep]   ‚úì Loaded ${rules.length} rules`);

        // Step 7: Build lightweight generation guide for AI (metadata only)
        const guide = {
          // Metadata
          bladeId: blade.id,
          module: plan.module,
          entity: entityName,
          bladeType: blade.type,
          features: blade.features || [],

          // Base files (already generated by create-vc-app)
          baseFiles: {
            blade: this.getBladePath(plan.module, blade.id, cwd),
            composable: this.getComposablePath(plan.module, entityName, blade.type, cwd),
            locale: this.getLocalePath(plan.module, cwd),
          },

          // Component registry (lightweight - no full content)
          components: relevantComponents.map((c) => ({
            name: c.item.component,
            description: c.item.description,
            // ‚ö†Ô∏è No props, slots, events, capabilities, examples here
            // AI will request full details via get_component_capabilities(name)
            matchReason: c.reason,
            confidence: c.confidence,
          })),

          // Framework hooks (lightweight - no full content)
          hooks: relevantHooks.map((h) => ({
            name: h.name,
            import: h.import,
            description: h.description,
            // ‚ö†Ô∏è No methods, capabilities, examples here
            // AI will request full details via get_framework_capabilities(name)
          })),

          // Template reference (lightweight - no content)
          template: template ? {
            id: template.id,
            complexity: template.complexity,
            description: template.description,
            // ‚ö†Ô∏è No content here
            // AI will request full content via get_template_by_id(id)
          } : null,

          // Pattern references (lightweight - no content)
          patterns: relevantPatterns.map((p: any) => ({
            id: p.id,
            description: p.description,
            features: p.features,
            // ‚ö†Ô∏è No content here
            // AI will request full content via get_patterns_by_ids([ids])
          })),

          // Rule references (lightweight - no content)
          rules: rules.map((r) => ({
            id: r.id,
            description: r.description,
            // ‚ö†Ô∏è No content here
            // AI will request full content via get_rules_by_ids([ids])
          })),

          // AI Instructions
          instructions: this.buildLazyLoadingInstructions(blade, template, relevantComponents, relevantHooks),

          // Expected output format
          expectedOutput: {
            blade: "Complete Vue SFC (.vue file)",
            composable: "TypeScript composable with proper types",
            apiClient: blade.type === "list" ? "API client with CRUD methods" : null,
          },
        };

        guides.push(guide);
        console.log(`[GenerateStep] ‚úì Guide created for ${blade.id}`);
        console.log(`[GenerateStep]   Components: ${relevantComponents.length}`);
        console.log(`[GenerateStep]   Hooks: ${relevantHooks.length}`);
        console.log(`[GenerateStep]   Patterns: ${relevantPatterns.length}`);
        console.log(`[GenerateStep]   Rules: ${rules.length}`);
      }

      console.log(`[GenerateStep] ‚úÖ Generated ${guides.length} guides for AI`);
      console.log(`[GenerateStep] üì§ Next: Send guides to AI for code generation`);

      return {
        success: true,
        data: {
          plan,
          generationGuides: guides,
        },
        nextStep: "ai-codegen" as any, // New step: AI Code Generation
      };
    } catch (error: any) {
      return {
        success: false,
        errors: [`Generation guide creation failed: ${error.message}`],
      };
    }
  }

  canExecute(state: WorkflowState): boolean {
    // Can execute from validating or generating state
    // Plan must exist (from state or will be provided via input)
    return (
      state.currentStep === ("validating" as any) ||
      state.currentStep === ("generating" as any)
    );
  }

  getRequiredInput(): string[] {
    return ["plan", "cwd"];
  }

  /**
   * Generate base files using create-vc-app CLI
   */
  private async generateBaseFiles(
    module: string,
    entityName: string,
    blade: any,
    cwd: string,
  ): Promise<void> {
    const formFields = blade.type === "details" ? this.buildFormFields(blade) : undefined;

    // Import execa dynamically
    const { execa } = await import("execa");

    // Get the path to create-vc-app for local development
    // In production, this would use npx @vc-shell/create-vc-app
    // tsup creates flat dist/ structure, so from dist/lib.js -> cli/ -> create-vc-app/
    const currentDir = path.dirname(fileURLToPath(import.meta.url));
    const createVcAppPath = path.resolve(currentDir, "..", "..", "create-vc-app", "src", "index.ts");

    // Build command arguments
    const args = [
      "tsx",
      createVcAppPath,
      "blade",
      "--module",
      module,
      "--type",
      blade.type === "list" ? "grid" : "details",
      "--name",
      entityName,
      "--composable",
      "--locales",
    ];

    if (blade.isWorkspace) {
      args.push("--workspace");
    }

    if (formFields) {
      args.push("--form-fields", formFields);
      args.push("--skip-form-editor");
    }

    console.log(`[GenerateStep] Running: npx ${args.join(" ")}`);

    try {
      await execa("npx", args, {
        cwd,
        stdio: "pipe",
      });
    } catch (error: any) {
      throw new Error(
        `\n‚ùå Generation failed: ${error.message}\n\n${error.stderr || error.stdout || ""}`,
      );
    }
  }

  /**
   * Discover relevant components using semantic search
   */
  private async discoverComponents(blade: any, componentResolver: any): Promise<any[]> {
    // Build intent query
    const intent = blade.type === "list"
      ? `data table for listing ${blade.id} with ${(blade.features || []).join(", ")}`
      : `form for editing ${blade.id} with ${(blade.features || []).join(", ")}`;

    // Semantic search in component registry
    const result = await componentResolver.resolve({
      intent,
      context: blade.type === "list" ? "list" : "details",
      features: blade.features || [],
    });

    // Return top matches (scored and ranked)
    return result ? [result] : [];
  }

  /**
   * Discover relevant framework hooks
   */
  private async discoverFrameworkHooks(blade: any, kb: any): Promise<any[]> {
    const hooks: any[] = [];

    // Always needed
    hooks.push(kb.frameworkAPIs.findByName("useBladeNavigation"));
    hooks.push(kb.frameworkAPIs.findByName("useApiClient"));

    // Blade-specific
    if (blade.type === "list") {
      hooks.push(kb.frameworkAPIs.findByName("useNotifications"));
    } else {
      hooks.push(kb.frameworkAPIs.findByName("useModificationTracker"));
      hooks.push(kb.frameworkAPIs.findByName("useNotifications"));
    }

    // Feature-specific
    if (blade.features?.includes("validation")) {
      // Add validation hook if exists
    }

    return hooks.filter(Boolean);
  }

  /**
   * Get applicable rules
   */
  private getApplicableRules(blade: any, _kb: any): any[] {
    const rules = [];

    // Workspace blade rules
    if (blade.isWorkspace) {
      rules.push({ id: "workspace-blade", content: "/* workspace blade rules */" });
    }

    // Blade type rules
    rules.push({ id: `${blade.type}-blade`, content: `/* ${blade.type} blade rules */` });

    // Feature rules
    for (const feature of blade.features || []) {
      rules.push({ id: `${feature}-rule`, content: `/* ${feature} rules */` });
    }

    return rules;
  }

  /**
   * Build lazy loading instructions for AI
   *
   * This guide tells AI to fetch full content as needed using MCP tools
   */
  private buildLazyLoadingInstructions(
    blade: any,
    template: any,
    components: any[],
    hooks: any[],
  ): string {
    const instructions: string[] = [];

    instructions.push("# AI Code Generation Instructions (Lazy Loading Mode)");
    instructions.push("");
    instructions.push(`## Task: Generate ${blade.type} blade: ${blade.id}`);
    instructions.push("");

    instructions.push("## üîÑ IMPORTANT: Lazy Loading Workflow");
    instructions.push("This guide contains only METADATA (IDs, names, descriptions).");
    instructions.push("You MUST fetch full content using MCP tools before generating code:");
    instructions.push("");

    instructions.push("### Step 1: Plan Generation (Current Step)");
    instructions.push("- Review component names and descriptions");
    instructions.push("- Review hook names and descriptions");
    instructions.push("- Review template/pattern IDs");
    instructions.push("- Decide which resources you need for code generation");
    instructions.push("");

    instructions.push("### Step 2: Fetch Full Content");
    instructions.push("Before generating code, fetch full details:");
    instructions.push("");

    if (components.length > 0) {
      instructions.push("**Components:** Use `view_components` tool");
      instructions.push("```");
      instructions.push(`view_components({ components: [${components.map(c => `"${c.name}"`).join(", ")}] })`);
      instructions.push("```");
      instructions.push("");
    }

    if (hooks.length > 0) {
      instructions.push("**Framework Hooks:** Use `view_framework_apis` tool");
      instructions.push("```");
      instructions.push(`view_framework_apis({ apis: [${hooks.map(h => `"${h.name}"`).join(", ")}] })`);
      instructions.push("```");
      instructions.push("");
    }

    if (template) {
      instructions.push("**Template:** Use `get_best_template` tool");
      instructions.push("```");
      instructions.push(`get_best_template({ bladeType: "${blade.type}", features: [${(blade.features || []).map((f: string) => `"${f}"`).join(", ")}] })`);
      instructions.push("```");
      instructions.push("");
    }

    instructions.push("**Patterns:** Use `get_relevant_patterns` tool");
    instructions.push("```");
    instructions.push(`get_relevant_patterns({ bladeType: "${blade.type}", features: [${(blade.features || []).map((f: string) => `"${f}"`).join(", ")}] })`);
    instructions.push("```");
    instructions.push("");

    instructions.push("### Step 3: Generate Code");
    instructions.push("After fetching all necessary content, generate code.");
    instructions.push("");

    instructions.push("## Base Files (Already Created by create-vc-app):");
    instructions.push("- Vue SFC blade (modify according to requirements)");
    instructions.push("- TypeScript composable (modify according to requirements)");
    instructions.push("- Locale file (add custom translations if needed)");
    instructions.push("");

    instructions.push("## Components Available (Fetch details before use):");
    components.forEach((c) => {
      instructions.push(`- **${c.name}**: ${c.description}`);
      instructions.push(`  Confidence: ${(c.confidence * 100).toFixed(0)}%`);
    });
    instructions.push("");

    instructions.push("## Framework Hooks Available (Fetch details before use):");
    hooks.forEach((h) => {
      instructions.push(`- **${h.name}**: ${h.description}`);
    });
    instructions.push("");

    if (template) {
      instructions.push("## Template Available:");
      instructions.push(`- **${template.id}** (${template.complexity}): ${template.description}`);
      instructions.push("");
    }

    if (blade.features?.length) {
      instructions.push("## Features to Implement:");
      blade.features.forEach((f: string) => {
        instructions.push(`- ${f}`);
      });
      instructions.push("");
    }

    instructions.push("## Requirements:");
    instructions.push("1. Fetch full content for components/hooks/patterns BEFORE generating code");
    instructions.push("2. Use TypeScript with strict types");
    instructions.push("3. Follow Vue 3 Composition API");
    instructions.push("4. Use VC-Shell components from registry (above)");
    instructions.push("5. Use VC-Shell framework hooks (above)");
    instructions.push("6. Follow patterns provided");
    instructions.push("7. Respect all rules");
    instructions.push("8. Add proper error handling");
    instructions.push("9. Match UI-Plan exactly");
    instructions.push("");

    instructions.push("## Validation:");
    instructions.push("- Code will be validated against UI-Plan");
    instructions.push("- TypeScript type checking will be run");
    instructions.push("- Up to 3 retry attempts if validation fails");

    return instructions.join("\n");
  }

  /**
   * Extract entity name from blade ID
   */
  private extractEntityName(bladeId: string, bladeType: "list" | "details"): string {
    return bladeId.replace(new RegExp(`-(${bladeType})$`), "");
  }

  /**
   * Build form fields JSON for create-vc-app
   */
  private buildFormFields(blade: any): string | undefined {
    if (!blade.component?.props?.columns) {
      return undefined;
    }

    const fields = blade.component.props.columns.map((col: any) => ({
      name: col.id,
      type: this.mapTypeToFormFieldType(col.type),
      label: col.title,
      required: col.required || false,
    }));

    return JSON.stringify(fields);
  }

  /**
   * Map type to form field type
   */
  private mapTypeToFormFieldType(type: string): string {
    const typeMap: Record<string, string> = {
      string: "text",
      number: "number",
      boolean: "checkbox",
      date: "date",
      array: "multivalue",
    };
    return typeMap[type] || "text";
  }

  /**
   * Get file paths
   */
  private getBladePath(module: string, bladeId: string, cwd: string): string {
    return `${cwd}/src/modules/${module}/pages/${bladeId}.vue`;
  }

  private getComposablePath(module: string, entity: string, type: string, cwd: string): string {
    const name = type === "list"
      ? `use${this.capitalize(entity)}s.ts`
      : `use${this.capitalize(entity)}Details.ts`;
    return `${cwd}/src/modules/${module}/composables/${name}`;
  }

  private getLocalePath(module: string, cwd: string): string {
    return `${cwd}/src/modules/${module}/locales/en.json`;
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
