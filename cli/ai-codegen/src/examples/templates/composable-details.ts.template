/**
 * Details Composable Template
 *
 * Production-ready composable for details/form blades.
 * Features: load, save, delete, modification tracking.
 *
 * USAGE:
 * 1. Replace {{EntityName}} with your entity name (e.g., Offer, Product)
 * 2. Replace {{entityName}} with camelCase entity name (e.g., offer, product)
 * 3. Replace {{MODULE_NAME}} with your module name (e.g., offers, products)
 * 4. Import actual types from your API client
 *
 * ⚠️ TYPE SAFETY RULES (vue-tsc MUST pass with 0 errors!):
 * 1. Use actual Vue types in interfaces: Ref<T>, ComputedRef<T>, Readonly<Ref<T>>
 *    - NEVER use ReturnType<typeof ref<T>>
 * 2. useModificationTracker returns { isModified, currentValue, resetModificationState }
 *    - NEVER destructure as { modified: isModified } - "modified" doesn't exist!
 * 3. useAsync callbacks can receive undefined - ALWAYS guard with if (!param) return;
 * 4. Return currentValue from tracker, NOT the original item ref
 */

import { computed, ref, reactive, type ComputedRef, type Ref } from "vue";
import { useAsync, useApiClient, useLoading, useModificationTracker } from "@vc-shell/framework";
import { {{EntityName}}Client } from "../../../api_client/{{MODULE_NAME}}.client";
import {
  {{EntityName}},
  type I{{EntityName}},
  Create{{EntityName}}Command,
  Update{{EntityName}}Command,
} from "../../../api_client/{{MODULE_NAME}}.api";

/**
 * Interface for the composable return type
 *
 * ✅ CORRECT: Use actual Vue types directly
 * ❌ WRONG: ReturnType<typeof ref<T>> - verbose and confusing
 */
export interface IUse{{EntityName}}Details {
  // Data - use Ref<T> directly, NOT ReturnType<typeof ref<T>>
  item: Ref<I{{EntityName}}>;
  loading: ComputedRef<boolean>;

  // Modification tracking - use Readonly<Ref<boolean>> for tracked refs
  isModified: Readonly<Ref<boolean>>;
  resetModificationState: () => void;

  // Methods
  load{{EntityName}}: (id: string) => Promise<void>;
  save{{EntityName}}: (data?: I{{EntityName}}) => Promise<I{{EntityName}} | undefined>;
  delete{{EntityName}}: (id: string) => Promise<void>;
}

/**
 * Details composable for {{EntityName}} entity
 *
 * Uses useModificationTracker for change detection.
 * IMPORTANT: Return currentValue from tracker, not the original item ref!
 *
 * @returns Reactive state and methods for entity management
 */
export function use{{EntityName}}Details(): IUse{{EntityName}}Details {
  const { getApiClient } = useApiClient({{EntityName}}Client);

  // Initialize with empty reactive entity
  const item = ref<I{{EntityName}}>(reactive(new {{EntityName}}()));

  // ✅ CORRECT: Use exact property names from useModificationTracker
  // Returns: { isModified, currentValue, resetModificationState }
  // ❌ WRONG: { modified: isModified } - "modified" does NOT exist!
  const { isModified, currentValue, resetModificationState } = useModificationTracker(item);

// Load entity by ID
// ✅ CORRECT: useAsync callback param is optional - ALWAYS guard it!
const { action: load{{EntityName}}, loading: loadingEntity } = useAsync<string>(async (id?: string) => {
  if (!id) return;  // REQUIRED: Guard against undefined param

  const client = await getApiClient();
  const data = await client.get{{EntityName}}ById(id);

    // Assign to currentValue to properly track modifications
    currentValue.value = reactive(data);
    resetModificationState();
  });

  // Save entity (create or update based on id presence)
  const { action: save{{EntityName}}, loading: saving } = useAsync<I{{EntityName}} | undefined, I{{EntityName}} | undefined>(
    async (data) => {
      if (!data) return;

      const client = await getApiClient();
      let result: I{{EntityName}};

      if (data.id) {
        // Update existing entity
        result = await client.update{{EntityName}}(new Update{{EntityName}}Command(data));
      } else {
        // Create new entity
        result = await client.create{{EntityName}}(new Create{{EntityName}}Command(data));
      }

      // Update currentValue with saved result
      currentValue.value = reactive(result);
      resetModificationState();

      return result;
    }
  );

// Delete entity
const { action: delete{{EntityName}}, loading: deleting } = useAsync<string>(async (id) => {
  if (!id) return;

  const client = await getApiClient();
  await client.delete{{EntityName}}(id);
});

  return {
    // IMPORTANT: Return currentValue, not item!
    // This ensures modification tracking works correctly
    item: currentValue,
    loading: useLoading(loadingEntity, saving, deleting),

    // Modification tracking
    isModified: computed(() => isModified.value),
    resetModificationState,

    // Methods
    load{{EntityName}},
    save{{EntityName}},
    delete{{EntityName}},
  };
}
