//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AuthApiBase {
  authToken = "";
  protected constructor() {}

  // Enforce always return empty string as baseUrl
  getBaseUrl(defaultUrl: string, baseUrl: string) {
    return "";
  }

  setAuthToken(token: string) {
    this.authToken = token;
  }

  protected transformOptions(options: any): Promise<any> {
    options.headers['authorization'] =  `Bearer ${this.authToken}`;
    return Promise.resolve(options);
  }
}

export class ImportClient extends AuthApiBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    runImport(body?: ImportProfile | undefined): Promise<ImportPushNotification> {
        let url_ = this.baseUrl + "/api/import/run";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRunImport(_response);
        });
    }

    protected processRunImport(response: Response): Promise<ImportPushNotification> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportPushNotification.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportPushNotification>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelJob(body?: ImportCancellationRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/import/task/cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancelJob(_response);
        });
    }

    protected processCancelJob(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    preview(body?: ImportProfile | undefined): Promise<ImportDataPreview> {
        let url_ = this.baseUrl + "/api/import/preview";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processPreview(_response);
        });
    }

    protected processPreview(response: Response): Promise<ImportDataPreview> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportDataPreview.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportDataPreview>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    validate(body?: ImportProfile | undefined): Promise<ValidationResult> {
        let url_ = this.baseUrl + "/api/import/validate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processValidate(_response);
        });
    }

    protected processValidate(response: Response): Promise<ValidationResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ValidationResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ValidationResult>(null as any);
    }

    /**
     * @return Success
     */
    getImporters(): Promise<IDataImporter[]> {
        let url_ = this.baseUrl + "/api/import/importers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetImporters(_response);
        });
    }

    protected processGetImporters(response: Response): Promise<IDataImporter[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IDataImporter.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IDataImporter[]>(null as any);
    }

    /**
     * @return Success
     */
    getImportProfileById(profileId: string): Promise<ImportProfile> {
        let url_ = this.baseUrl + "/api/import/profiles/{profileId}";
        if (profileId === undefined || profileId === null)
            throw new Error("The parameter 'profileId' must be defined.");
        url_ = url_.replace("{profileId}", encodeURIComponent("" + profileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetImportProfileById(_response);
        });
    }

    protected processGetImportProfileById(response: Response): Promise<ImportProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportProfile>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createImportProfile(body?: ImportProfile | undefined): Promise<ImportProfile> {
        let url_ = this.baseUrl + "/api/import/profiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateImportProfile(_response);
        });
    }

    protected processCreateImportProfile(response: Response): Promise<ImportProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportProfile>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateImportProfile(body?: ImportProfile | undefined): Promise<ImportProfile> {
        let url_ = this.baseUrl + "/api/import/profiles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateImportProfile(_response);
        });
    }

    protected processUpdateImportProfile(response: Response): Promise<ImportProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImportProfile>(null as any);
    }

    /**
     * @param profileId (optional) 
     * @return Success
     */
    deleteProfile(profileId?: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/import/profiles?";
        if (profileId === null)
            throw new Error("The parameter 'profileId' cannot be null.");
        else if (profileId !== undefined)
            url_ += "profileId=" + encodeURIComponent("" + profileId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteProfile(_response);
        });
    }

    protected processDeleteProfile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchImportProfiles(body?: SearchImportProfilesCriteria | undefined): Promise<SearchImportProfilesResult> {
        let url_ = this.baseUrl + "/api/import/profiles/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchImportProfiles(_response);
        });
    }

    protected processSearchImportProfiles(response: Response): Promise<SearchImportProfilesResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchImportProfilesResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchImportProfilesResult>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    searchImportRunHistory(body?: SearchImportRunHistoryCriteria | undefined): Promise<SearchImportRunHistoryResult> {
        let url_ = this.baseUrl + "/api/import/profiles/execution/history/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchImportRunHistory(_response);
        });
    }

    protected processSearchImportRunHistory(response: Response): Promise<SearchImportRunHistoryResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchImportRunHistoryResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Unauthorized", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Forbidden", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchImportRunHistoryResult>(null as any);
    }
}

export class Action implements IAction {
    readonly target?: any | undefined;
    readonly method?: MethodInfo | undefined;

    constructor(data?: IAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).target = _data["target"];
            (<any>this).method = _data["method"] ? MethodInfo.fromJS(_data["method"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Action {
        data = typeof data === 'object' ? data : {};
        let result = new Action();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["target"] = this.target;
        data["method"] = this.method ? this.method.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAction {
    target?: any | undefined;
    method?: MethodInfo | undefined;
}

export class Assembly implements IAssembly {
    readonly definedTypes?: string[] | undefined;
    readonly exportedTypes?: string[] | undefined;
    readonly codeBase?: string | undefined;
    readonly entryPoint?: MethodInfo | undefined;
    readonly fullName?: string | undefined;
    readonly imageRuntimeVersion?: string | undefined;
    readonly isDynamic?: boolean;
    readonly location?: string | undefined;
    readonly reflectionOnly?: boolean;
    readonly isCollectible?: boolean;
    readonly isFullyTrusted?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly escapedCodeBase?: string | undefined;
    readonly manifestModule?: Module | undefined;
    readonly modules?: Module[] | undefined;
    readonly globalAssemblyCache?: boolean;
    readonly hostContext?: number;
    readonly securityRuleSet?: AssemblySecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["definedTypes"])) {
                (<any>this).definedTypes = [] as any;
                for (let item of _data["definedTypes"])
                    (<any>this).definedTypes!.push(item);
            }
            if (Array.isArray(_data["exportedTypes"])) {
                (<any>this).exportedTypes = [] as any;
                for (let item of _data["exportedTypes"])
                    (<any>this).exportedTypes!.push(item);
            }
            (<any>this).codeBase = _data["codeBase"];
            (<any>this).entryPoint = _data["entryPoint"] ? MethodInfo.fromJS(_data["entryPoint"]) : <any>undefined;
            (<any>this).fullName = _data["fullName"];
            (<any>this).imageRuntimeVersion = _data["imageRuntimeVersion"];
            (<any>this).isDynamic = _data["isDynamic"];
            (<any>this).location = _data["location"];
            (<any>this).reflectionOnly = _data["reflectionOnly"];
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).isFullyTrusted = _data["isFullyTrusted"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).escapedCodeBase = _data["escapedCodeBase"];
            (<any>this).manifestModule = _data["manifestModule"] ? Module.fromJS(_data["manifestModule"]) : <any>undefined;
            if (Array.isArray(_data["modules"])) {
                (<any>this).modules = [] as any;
                for (let item of _data["modules"])
                    (<any>this).modules!.push(Module.fromJS(item));
            }
            (<any>this).globalAssemblyCache = _data["globalAssemblyCache"];
            (<any>this).hostContext = _data["hostContext"];
            (<any>this).securityRuleSet = _data["securityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        let result = new Assembly();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["definedTypes"] = [];
            for (let item of this.definedTypes)
                data["definedTypes"].push(item);
        }
        if (Array.isArray(this.exportedTypes)) {
            data["exportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["exportedTypes"].push(item);
        }
        data["codeBase"] = this.codeBase;
        data["entryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["fullName"] = this.fullName;
        data["imageRuntimeVersion"] = this.imageRuntimeVersion;
        data["isDynamic"] = this.isDynamic;
        data["location"] = this.location;
        data["reflectionOnly"] = this.reflectionOnly;
        data["isCollectible"] = this.isCollectible;
        data["isFullyTrusted"] = this.isFullyTrusted;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["escapedCodeBase"] = this.escapedCodeBase;
        data["manifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["globalAssemblyCache"] = this.globalAssemblyCache;
        data["hostContext"] = this.hostContext;
        data["securityRuleSet"] = this.securityRuleSet;
        return data;
    }
}

export interface IAssembly {
    definedTypes?: string[] | undefined;
    exportedTypes?: string[] | undefined;
    codeBase?: string | undefined;
    entryPoint?: MethodInfo | undefined;
    fullName?: string | undefined;
    imageRuntimeVersion?: string | undefined;
    isDynamic?: boolean;
    location?: string | undefined;
    reflectionOnly?: boolean;
    isCollectible?: boolean;
    isFullyTrusted?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    escapedCodeBase?: string | undefined;
    manifestModule?: Module | undefined;
    modules?: Module[] | undefined;
    globalAssemblyCache?: boolean;
    hostContext?: number;
    securityRuleSet?: AssemblySecurityRuleSet;
}

export enum CallingConventions {
    Standard = "Standard",
    VarArgs = "VarArgs",
    Any = "Any",
    HasThis = "HasThis",
    ExplicitThis = "ExplicitThis",
}

export class ConstructorInfo implements IConstructorInfo {
    readonly memberType?: ConstructorInfoMemberType;
    readonly attributes?: ConstructorInfoAttributes;
    readonly methodImplementationFlags?: ConstructorInfoMethodImplementationFlags;
    readonly callingConvention?: ConstructorInfoCallingConvention;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    readonly name?: string | undefined;
    readonly declaringType?: string | undefined;
    readonly reflectedType?: string | undefined;
    readonly module?: Module | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IConstructorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).memberType = _data["memberType"];
            (<any>this).attributes = _data["attributes"];
            (<any>this).methodImplementationFlags = _data["methodImplementationFlags"];
            (<any>this).callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            (<any>this).declaringType = _data["declaringType"];
            (<any>this).reflectedType = _data["reflectedType"];
            (<any>this).module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConstructorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType;
        data["reflectedType"] = this.reflectedType;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IConstructorInfo {
    memberType?: ConstructorInfoMemberType;
    attributes?: ConstructorInfoAttributes;
    methodImplementationFlags?: ConstructorInfoMethodImplementationFlags;
    callingConvention?: ConstructorInfoCallingConvention;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    name?: string | undefined;
    declaringType?: string | undefined;
    reflectedType?: string | undefined;
    module?: Module | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export class CustomAttributeData implements ICustomAttributeData {
    readonly attributeType?: string | undefined;
    readonly constructor_?: ConstructorInfo | undefined;
    readonly constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    readonly namedArguments?: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).attributeType = _data["attributeType"];
            (<any>this).constructor_ = _data["constructor"] ? ConstructorInfo.fromJS(_data["constructor"]) : <any>undefined;
            if (Array.isArray(_data["constructorArguments"])) {
                (<any>this).constructorArguments = [] as any;
                for (let item of _data["constructorArguments"])
                    (<any>this).constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (Array.isArray(_data["namedArguments"])) {
                (<any>this).namedArguments = [] as any;
                for (let item of _data["namedArguments"])
                    (<any>this).namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeType"] = this.attributeType;
        data["constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (Array.isArray(this.constructorArguments)) {
            data["constructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["constructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["namedArguments"] = [];
            for (let item of this.namedArguments)
                data["namedArguments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomAttributeData {
    attributeType?: string | undefined;
    constructor_?: ConstructorInfo | undefined;
    constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    namedArguments?: CustomAttributeNamedArgument[] | undefined;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo | undefined;
    readonly typedValue?: CustomAttributeTypedArgument;
    readonly memberName?: string | undefined;
    readonly isField?: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberInfo = _data["memberInfo"] ? MemberInfo.fromJS(_data["memberInfo"]) : <any>undefined;
            (<any>this).typedValue = _data["typedValue"] ? CustomAttributeTypedArgument.fromJS(_data["typedValue"]) : <any>undefined;
            (<any>this).memberName = _data["memberName"];
            (<any>this).isField = _data["isField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["typedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["memberName"] = this.memberName;
        data["isField"] = this.isField;
        return data;
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo | undefined;
    typedValue?: CustomAttributeTypedArgument;
    memberName?: string | undefined;
    isField?: boolean;
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType?: string | undefined;
    value?: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType;
        data["value"] = this.value;
        return data;
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType?: string | undefined;
    value?: any | undefined;
}

export class IAuthorizationRequirement implements IIAuthorizationRequirement {

    constructor(data?: IIAuthorizationRequirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): IAuthorizationRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new IAuthorizationRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IIAuthorizationRequirement {
}

export class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ICustomAttributeProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ICustomAttributeProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IICustomAttributeProvider {
}

export class IDataImporter implements IIDataImporter {
    readonly typeName?: string | undefined;
    readonly metadata?: { [key: string]: string; } | undefined;
    availSettings?: SettingDescriptor[] | undefined;
    authorizationRequirement?: IAuthorizationRequirement | undefined;

    constructor(data?: IIDataImporter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).typeName = _data["typeName"];
            if (_data["metadata"]) {
                (<any>this).metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>(<any>this).metadata)![key] = _data["metadata"][key];
                }
            }
            if (Array.isArray(_data["availSettings"])) {
                this.availSettings = [] as any;
                for (let item of _data["availSettings"])
                    this.availSettings!.push(SettingDescriptor.fromJS(item));
            }
            this.authorizationRequirement = _data["authorizationRequirement"] ? IAuthorizationRequirement.fromJS(_data["authorizationRequirement"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IDataImporter {
        data = typeof data === 'object' ? data : {};
        let result = new IDataImporter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        if (Array.isArray(this.availSettings)) {
            data["availSettings"] = [];
            for (let item of this.availSettings)
                data["availSettings"].push(item.toJSON());
        }
        data["authorizationRequirement"] = this.authorizationRequirement ? this.authorizationRequirement.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIDataImporter {
    typeName?: string | undefined;
    metadata?: { [key: string]: string; } | undefined;
    availSettings?: SettingDescriptor[] | undefined;
    authorizationRequirement?: IAuthorizationRequirement | undefined;
}

export class ImportCancellationRequest implements IImportCancellationRequest {
    jobId?: string | undefined;

    constructor(data?: IImportCancellationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobId = _data["jobId"];
        }
    }

    static fromJS(data: any): ImportCancellationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportCancellationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobId"] = this.jobId;
        return data;
    }
}

export interface IImportCancellationRequest {
    jobId?: string | undefined;
}

export class ImportDataPreview implements IImportDataPreview {
    totalCount?: number;
    fileName?: string | undefined;
    records?: any[] | undefined;
    errors?: string[] | undefined;

    constructor(data?: IImportDataPreview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.fileName = _data["fileName"];
            if (Array.isArray(_data["records"])) {
                this.records = [] as any;
                for (let item of _data["records"])
                    this.records!.push(item);
            }
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ImportDataPreview {
        data = typeof data === 'object' ? data : {};
        let result = new ImportDataPreview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["fileName"] = this.fileName;
        if (Array.isArray(this.records)) {
            data["records"] = [];
            for (let item of this.records)
                data["records"].push(item);
        }
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IImportDataPreview {
    totalCount?: number;
    fileName?: string | undefined;
    records?: any[] | undefined;
    errors?: string[] | undefined;
}

export class ImportProfile implements IImportProfile {
    name?: string | undefined;
    dataImporterType?: string | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    readonly typeName?: string | undefined;
    importFileUrl?: string | undefined;
    importReportUrl?: string | undefined;
    importReporterType?: string | undefined;
    previewObjectCount?: number;
    onImportCompleted?: Action | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IImportProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.dataImporterType = _data["dataImporterType"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            (<any>this).typeName = _data["typeName"];
            this.importFileUrl = _data["importFileUrl"];
            this.importReportUrl = _data["importReportUrl"];
            this.importReporterType = _data["importReporterType"];
            this.previewObjectCount = _data["previewObjectCount"];
            this.onImportCompleted = _data["onImportCompleted"] ? Action.fromJS(_data["onImportCompleted"]) : <any>undefined;
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImportProfile {
        data = typeof data === 'object' ? data : {};
        let result = new ImportProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["dataImporterType"] = this.dataImporterType;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["typeName"] = this.typeName;
        data["importFileUrl"] = this.importFileUrl;
        data["importReportUrl"] = this.importReportUrl;
        data["importReporterType"] = this.importReporterType;
        data["previewObjectCount"] = this.previewObjectCount;
        data["onImportCompleted"] = this.onImportCompleted ? this.onImportCompleted.toJSON() : <any>undefined;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IImportProfile {
    name?: string | undefined;
    dataImporterType?: string | undefined;
    userId?: string | undefined;
    userName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    typeName?: string | undefined;
    importFileUrl?: string | undefined;
    importReportUrl?: string | undefined;
    importReporterType?: string | undefined;
    previewObjectCount?: number;
    onImportCompleted?: Action | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class ImportPushNotification implements IImportPushNotification {
    profileId?: string | undefined;
    profileName?: string | undefined;
    jobId?: string | undefined;
    estimatingRemaining?: boolean;
    estimatedRemaining?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    readonly errorCount?: number;
    errors?: string[] | undefined;
    reportUrl?: string | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;

    constructor(data?: IImportPushNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profileId = _data["profileId"];
            this.profileName = _data["profileName"];
            this.jobId = _data["jobId"];
            this.estimatingRemaining = _data["estimatingRemaining"];
            this.estimatedRemaining = _data["estimatedRemaining"];
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            (<any>this).errorCount = _data["errorCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.reportUrl = _data["reportUrl"];
            this.serverId = _data["serverId"];
            this.creator = _data["creator"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isNew = _data["isNew"];
            this.notifyType = _data["notifyType"];
            this.description = _data["description"];
            this.title = _data["title"];
            this.repeatCount = _data["repeatCount"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImportPushNotification {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPushNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profileId"] = this.profileId;
        data["profileName"] = this.profileName;
        data["jobId"] = this.jobId;
        data["estimatingRemaining"] = this.estimatingRemaining;
        data["estimatedRemaining"] = this.estimatedRemaining;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorCount"] = this.errorCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["reportUrl"] = this.reportUrl;
        data["serverId"] = this.serverId;
        data["creator"] = this.creator;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isNew"] = this.isNew;
        data["notifyType"] = this.notifyType;
        data["description"] = this.description;
        data["title"] = this.title;
        data["repeatCount"] = this.repeatCount;
        data["id"] = this.id;
        return data;
    }
}

export interface IImportPushNotification {
    profileId?: string | undefined;
    profileName?: string | undefined;
    jobId?: string | undefined;
    estimatingRemaining?: boolean;
    estimatedRemaining?: string | undefined;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorCount?: number;
    errors?: string[] | undefined;
    reportUrl?: string | undefined;
    serverId?: string | undefined;
    creator?: string | undefined;
    created?: Date;
    isNew?: boolean;
    notifyType?: string | undefined;
    description?: string | undefined;
    title?: string | undefined;
    repeatCount?: number;
    id?: string | undefined;
}

export class ImportRunHistory implements IImportRunHistory {
    userId?: string | undefined;
    userName?: string | undefined;
    jobId?: string | undefined;
    profileId?: string | undefined;
    profileName?: string | undefined;
    executed?: Date;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorsCount?: number;
    errors?: string[] | undefined;
    fileUrl?: string | undefined;
    reportUrl?: string | undefined;
    readonly typeName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;

    constructor(data?: IImportRunHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.jobId = _data["jobId"];
            this.profileId = _data["profileId"];
            this.profileName = _data["profileName"];
            this.executed = _data["executed"] ? new Date(_data["executed"].toString()) : <any>undefined;
            this.finished = _data["finished"] ? new Date(_data["finished"].toString()) : <any>undefined;
            this.totalCount = _data["totalCount"];
            this.processedCount = _data["processedCount"];
            this.errorsCount = _data["errorsCount"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.fileUrl = _data["fileUrl"];
            this.reportUrl = _data["reportUrl"];
            (<any>this).typeName = _data["typeName"];
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(ObjectSettingEntry.fromJS(item));
            }
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.modifiedDate = _data["modifiedDate"] ? new Date(_data["modifiedDate"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.modifiedBy = _data["modifiedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ImportRunHistory {
        data = typeof data === 'object' ? data : {};
        let result = new ImportRunHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["jobId"] = this.jobId;
        data["profileId"] = this.profileId;
        data["profileName"] = this.profileName;
        data["executed"] = this.executed ? this.executed.toISOString() : <any>undefined;
        data["finished"] = this.finished ? this.finished.toISOString() : <any>undefined;
        data["totalCount"] = this.totalCount;
        data["processedCount"] = this.processedCount;
        data["errorsCount"] = this.errorsCount;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["fileUrl"] = this.fileUrl;
        data["reportUrl"] = this.reportUrl;
        data["typeName"] = this.typeName;
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["modifiedDate"] = this.modifiedDate ? this.modifiedDate.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["modifiedBy"] = this.modifiedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface IImportRunHistory {
    userId?: string | undefined;
    userName?: string | undefined;
    jobId?: string | undefined;
    profileId?: string | undefined;
    profileName?: string | undefined;
    executed?: Date;
    finished?: Date | undefined;
    totalCount?: number;
    processedCount?: number;
    errorsCount?: number;
    errors?: string[] | undefined;
    fileUrl?: string | undefined;
    reportUrl?: string | undefined;
    typeName?: string | undefined;
    settings?: ObjectSettingEntry[] | undefined;
    createdDate?: Date;
    modifiedDate?: Date | undefined;
    createdBy?: string | undefined;
    modifiedBy?: string | undefined;
    id?: string | undefined;
}

export class MemberInfo implements IMemberInfo {
    readonly memberType?: MemberInfoMemberType;
    readonly name?: string | undefined;
    readonly declaringType?: string | undefined;
    readonly reflectedType?: string | undefined;
    readonly module?: Module | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).memberType = _data["memberType"];
            (<any>this).name = _data["name"];
            (<any>this).declaringType = _data["declaringType"];
            (<any>this).reflectedType = _data["reflectedType"];
            (<any>this).module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType;
        data["reflectedType"] = this.reflectedType;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IMemberInfo {
    memberType?: MemberInfoMemberType;
    name?: string | undefined;
    declaringType?: string | undefined;
    reflectedType?: string | undefined;
    module?: Module | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export enum MemberTypes {
    Constructor = "Constructor",
    Event = "Event",
    Field = "Field",
    Method = "Method",
    Property = "Property",
    TypeInfo = "TypeInfo",
    Custom = "Custom",
    NestedType = "NestedType",
    All = "All",
}

export enum MethodAttributes {
    ReuseSlot = "ReuseSlot",
    PrivateScope = "PrivateScope",
    Private = "Private",
    FamANDAssem = "FamANDAssem",
    Assembly = "Assembly",
    Family = "Family",
    FamORAssem = "FamORAssem",
    Public = "Public",
    MemberAccessMask = "MemberAccessMask",
    UnmanagedExport = "UnmanagedExport",
    Static = "Static",
    Final = "Final",
    Virtual = "Virtual",
    HideBySig = "HideBySig",
    NewSlot = "NewSlot",
    VtableLayoutMask = "VtableLayoutMask",
    CheckAccessOnOverride = "CheckAccessOnOverride",
    Abstract = "Abstract",
    SpecialName = "SpecialName",
    RTSpecialName = "RTSpecialName",
    PinvokeImpl = "PinvokeImpl",
    HasSecurity = "HasSecurity",
    RequireSecObject = "RequireSecObject",
    ReservedMask = "ReservedMask",
}

export enum MethodImplAttributes {
    IL = "IL",
    Managed = "Managed",
    Native = "Native",
    OPTIL = "OPTIL",
    Runtime = "Runtime",
    CodeTypeMask = "CodeTypeMask",
    Unmanaged = "Unmanaged",
    ManagedMask = "ManagedMask",
    NoInlining = "NoInlining",
    ForwardRef = "ForwardRef",
    Synchronized = "Synchronized",
    NoOptimization = "NoOptimization",
    PreserveSig = "PreserveSig",
    AggressiveInlining = "AggressiveInlining",
    AggressiveOptimization = "AggressiveOptimization",
    InternalCall = "InternalCall",
    MaxMethodImplVal = "MaxMethodImplVal",
}

export class MethodInfo implements IMethodInfo {
    readonly memberType?: MethodInfoMemberType;
    readonly returnParameter?: ParameterInfo | undefined;
    readonly returnType?: string | undefined;
    readonly returnTypeCustomAttributes?: ICustomAttributeProvider | undefined;
    readonly attributes?: MethodInfoAttributes;
    readonly methodImplementationFlags?: MethodInfoMethodImplementationFlags;
    readonly callingConvention?: MethodInfoCallingConvention;
    readonly isAbstract?: boolean;
    readonly isConstructor?: boolean;
    readonly isFinal?: boolean;
    readonly isHideBySig?: boolean;
    readonly isSpecialName?: boolean;
    readonly isStatic?: boolean;
    readonly isVirtual?: boolean;
    readonly isAssembly?: boolean;
    readonly isFamily?: boolean;
    readonly isFamilyAndAssembly?: boolean;
    readonly isFamilyOrAssembly?: boolean;
    readonly isPrivate?: boolean;
    readonly isPublic?: boolean;
    readonly isConstructedGenericMethod?: boolean;
    readonly isGenericMethod?: boolean;
    readonly isGenericMethodDefinition?: boolean;
    readonly containsGenericParameters?: boolean;
    readonly methodHandle?: RuntimeMethodHandle;
    readonly isSecurityCritical?: boolean;
    readonly isSecuritySafeCritical?: boolean;
    readonly isSecurityTransparent?: boolean;
    readonly name?: string | undefined;
    readonly declaringType?: string | undefined;
    readonly reflectedType?: string | undefined;
    readonly module?: Module | undefined;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly isCollectible?: boolean;
    readonly metadataToken?: number;

    constructor(data?: IMethodInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).memberType = _data["memberType"];
            (<any>this).returnParameter = _data["returnParameter"] ? ParameterInfo.fromJS(_data["returnParameter"]) : <any>undefined;
            (<any>this).returnType = _data["returnType"];
            (<any>this).returnTypeCustomAttributes = _data["returnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"]) : <any>undefined;
            (<any>this).attributes = _data["attributes"];
            (<any>this).methodImplementationFlags = _data["methodImplementationFlags"];
            (<any>this).callingConvention = _data["callingConvention"];
            (<any>this).isAbstract = _data["isAbstract"];
            (<any>this).isConstructor = _data["isConstructor"];
            (<any>this).isFinal = _data["isFinal"];
            (<any>this).isHideBySig = _data["isHideBySig"];
            (<any>this).isSpecialName = _data["isSpecialName"];
            (<any>this).isStatic = _data["isStatic"];
            (<any>this).isVirtual = _data["isVirtual"];
            (<any>this).isAssembly = _data["isAssembly"];
            (<any>this).isFamily = _data["isFamily"];
            (<any>this).isFamilyAndAssembly = _data["isFamilyAndAssembly"];
            (<any>this).isFamilyOrAssembly = _data["isFamilyOrAssembly"];
            (<any>this).isPrivate = _data["isPrivate"];
            (<any>this).isPublic = _data["isPublic"];
            (<any>this).isConstructedGenericMethod = _data["isConstructedGenericMethod"];
            (<any>this).isGenericMethod = _data["isGenericMethod"];
            (<any>this).isGenericMethodDefinition = _data["isGenericMethodDefinition"];
            (<any>this).containsGenericParameters = _data["containsGenericParameters"];
            (<any>this).methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"]) : <any>undefined;
            (<any>this).isSecurityCritical = _data["isSecurityCritical"];
            (<any>this).isSecuritySafeCritical = _data["isSecuritySafeCritical"];
            (<any>this).isSecurityTransparent = _data["isSecurityTransparent"];
            (<any>this).name = _data["name"];
            (<any>this).declaringType = _data["declaringType"];
            (<any>this).reflectedType = _data["reflectedType"];
            (<any>this).module = _data["module"] ? Module.fromJS(_data["module"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).isCollectible = _data["isCollectible"];
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        let result = new MethodInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType;
        data["returnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["returnType"] = this.returnType;
        data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>undefined;
        data["attributes"] = this.attributes;
        data["methodImplementationFlags"] = this.methodImplementationFlags;
        data["callingConvention"] = this.callingConvention;
        data["isAbstract"] = this.isAbstract;
        data["isConstructor"] = this.isConstructor;
        data["isFinal"] = this.isFinal;
        data["isHideBySig"] = this.isHideBySig;
        data["isSpecialName"] = this.isSpecialName;
        data["isStatic"] = this.isStatic;
        data["isVirtual"] = this.isVirtual;
        data["isAssembly"] = this.isAssembly;
        data["isFamily"] = this.isFamily;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["isPrivate"] = this.isPrivate;
        data["isPublic"] = this.isPublic;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["isGenericMethod"] = this.isGenericMethod;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["containsGenericParameters"] = this.containsGenericParameters;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>undefined;
        data["isSecurityCritical"] = this.isSecurityCritical;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["isSecurityTransparent"] = this.isSecurityTransparent;
        data["name"] = this.name;
        data["declaringType"] = this.declaringType;
        data["reflectedType"] = this.reflectedType;
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible;
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IMethodInfo {
    memberType?: MethodInfoMemberType;
    returnParameter?: ParameterInfo | undefined;
    returnType?: string | undefined;
    returnTypeCustomAttributes?: ICustomAttributeProvider | undefined;
    attributes?: MethodInfoAttributes;
    methodImplementationFlags?: MethodInfoMethodImplementationFlags;
    callingConvention?: MethodInfoCallingConvention;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    methodHandle?: RuntimeMethodHandle;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
    name?: string | undefined;
    declaringType?: string | undefined;
    reflectedType?: string | undefined;
    module?: Module | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    isCollectible?: boolean;
    metadataToken?: number;
}

export class Module implements IModule {
    readonly assembly?: Assembly | undefined;
    readonly fullyQualifiedName?: string | undefined;
    readonly name?: string | undefined;
    readonly mdStreamVersion?: number;
    readonly moduleVersionId?: string;
    readonly scopeName?: string | undefined;
    readonly moduleHandle?: ModuleHandle;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"]) : <any>undefined;
            (<any>this).fullyQualifiedName = _data["fullyQualifiedName"];
            (<any>this).name = _data["name"];
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
            (<any>this).moduleVersionId = _data["moduleVersionId"];
            (<any>this).scopeName = _data["scopeName"];
            (<any>this).moduleHandle = _data["moduleHandle"] ? ModuleHandle.fromJS(_data["moduleHandle"]) : <any>undefined;
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        let result = new Module();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["fullyQualifiedName"] = this.fullyQualifiedName;
        data["name"] = this.name;
        data["mdStreamVersion"] = this.mdStreamVersion;
        data["moduleVersionId"] = this.moduleVersionId;
        data["scopeName"] = this.scopeName;
        data["moduleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IModule {
    assembly?: Assembly | undefined;
    fullyQualifiedName?: string | undefined;
    name?: string | undefined;
    mdStreamVersion?: number;
    moduleVersionId?: string;
    scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export class ModuleHandle implements IModuleHandle {
    readonly mdStreamVersion?: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).mdStreamVersion = _data["mdStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdStreamVersion"] = this.mdStreamVersion;
        return data;
    }
}

export interface IModuleHandle {
    mdStreamVersion?: number;
}

export class ObjectSettingEntry implements IObjectSettingEntry {
    readonly itHasValues?: boolean;
    objectId?: string | undefined;
    objectType?: string | undefined;
    isReadOnly?: boolean;
    value?: any | undefined;
    id?: string | undefined;
    restartRequired?: boolean;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isRequired?: boolean;
    isHidden?: boolean;
    valueType?: ObjectSettingEntryValueType;
    allowedValues?: any[] | undefined;
    defaultValue?: any | undefined;
    isDictionary?: boolean;

    constructor(data?: IObjectSettingEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).itHasValues = _data["itHasValues"];
            this.objectId = _data["objectId"];
            this.objectType = _data["objectType"];
            this.isReadOnly = _data["isReadOnly"];
            this.value = _data["value"];
            this.id = _data["id"];
            this.restartRequired = _data["restartRequired"];
            this.moduleId = _data["moduleId"];
            this.groupName = _data["groupName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isRequired = _data["isRequired"];
            this.isHidden = _data["isHidden"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["allowedValues"])) {
                this.allowedValues = [] as any;
                for (let item of _data["allowedValues"])
                    this.allowedValues!.push(item);
            }
            this.defaultValue = _data["defaultValue"];
            this.isDictionary = _data["isDictionary"];
        }
    }

    static fromJS(data: any): ObjectSettingEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ObjectSettingEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itHasValues"] = this.itHasValues;
        data["objectId"] = this.objectId;
        data["objectType"] = this.objectType;
        data["isReadOnly"] = this.isReadOnly;
        data["value"] = this.value;
        data["id"] = this.id;
        data["restartRequired"] = this.restartRequired;
        data["moduleId"] = this.moduleId;
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isRequired"] = this.isRequired;
        data["isHidden"] = this.isHidden;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["defaultValue"] = this.defaultValue;
        data["isDictionary"] = this.isDictionary;
        return data;
    }
}

export interface IObjectSettingEntry {
    itHasValues?: boolean;
    objectId?: string | undefined;
    objectType?: string | undefined;
    isReadOnly?: boolean;
    value?: any | undefined;
    id?: string | undefined;
    restartRequired?: boolean;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isRequired?: boolean;
    isHidden?: boolean;
    valueType?: ObjectSettingEntryValueType;
    allowedValues?: any[] | undefined;
    defaultValue?: any | undefined;
    isDictionary?: boolean;
}

export enum ParameterAttributes {
    None = "None",
    In = "In",
    Out = "Out",
    Lcid = "Lcid",
    Retval = "Retval",
    Optional = "Optional",
    HasDefault = "HasDefault",
    HasFieldMarshal = "HasFieldMarshal",
    Reserved3 = "Reserved3",
    Reserved4 = "Reserved4",
    ReservedMask = "ReservedMask",
}

export class ParameterInfo implements IParameterInfo {
    readonly attributes?: ParameterInfoAttributes;
    readonly member?: MemberInfo | undefined;
    readonly name?: string | undefined;
    readonly parameterType?: string | undefined;
    readonly position?: number;
    readonly isIn?: boolean;
    readonly isLcid?: boolean;
    readonly isOptional?: boolean;
    readonly isOut?: boolean;
    readonly isRetval?: boolean;
    readonly defaultValue?: any | undefined;
    readonly rawDefaultValue?: any | undefined;
    readonly hasDefaultValue?: boolean;
    readonly customAttributes?: CustomAttributeData[] | undefined;
    readonly metadataToken?: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).attributes = _data["attributes"];
            (<any>this).member = _data["member"] ? MemberInfo.fromJS(_data["member"]) : <any>undefined;
            (<any>this).name = _data["name"];
            (<any>this).parameterType = _data["parameterType"];
            (<any>this).position = _data["position"];
            (<any>this).isIn = _data["isIn"];
            (<any>this).isLcid = _data["isLcid"];
            (<any>this).isOptional = _data["isOptional"];
            (<any>this).isOut = _data["isOut"];
            (<any>this).isRetval = _data["isRetval"];
            (<any>this).defaultValue = _data["defaultValue"];
            (<any>this).rawDefaultValue = _data["rawDefaultValue"];
            (<any>this).hasDefaultValue = _data["hasDefaultValue"];
            if (Array.isArray(_data["customAttributes"])) {
                (<any>this).customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    (<any>this).customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            (<any>this).metadataToken = _data["metadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["name"] = this.name;
        data["parameterType"] = this.parameterType;
        data["position"] = this.position;
        data["isIn"] = this.isIn;
        data["isLcid"] = this.isLcid;
        data["isOptional"] = this.isOptional;
        data["isOut"] = this.isOut;
        data["isRetval"] = this.isRetval;
        data["defaultValue"] = this.defaultValue;
        data["rawDefaultValue"] = this.rawDefaultValue;
        data["hasDefaultValue"] = this.hasDefaultValue;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken;
        return data;
    }
}

export interface IParameterInfo {
    attributes?: ParameterInfoAttributes;
    member?: MemberInfo | undefined;
    name?: string | undefined;
    parameterType?: string | undefined;
    position?: number;
    isIn?: boolean;
    isLcid?: boolean;
    isOptional?: boolean;
    isOut?: boolean;
    isRetval?: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    readonly value?: any;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): RuntimeMethodHandle {
        data = typeof data === 'object' ? data : {};
        let result = new RuntimeMethodHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IRuntimeMethodHandle {
    value?: any;
}

export class SearchImportProfilesCriteria implements ISearchImportProfilesCriteria {
    userId?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchImportProfilesCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchImportProfilesCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new SearchImportProfilesCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchImportProfilesCriteria {
    userId?: string | undefined;
    userName?: string | undefined;
    name?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SearchImportProfilesResult implements ISearchImportProfilesResult {
    totalCount?: number;
    results?: ImportProfile[] | undefined;

    constructor(data?: ISearchImportProfilesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ImportProfile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchImportProfilesResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchImportProfilesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchImportProfilesResult {
    totalCount?: number;
    results?: ImportProfile[] | undefined;
}

export class SearchImportRunHistoryCriteria implements ISearchImportRunHistoryCriteria {
    userId?: string | undefined;
    userName?: string | undefined;
    profileId?: string | undefined;
    jobId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    readonly sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;

    constructor(data?: ISearchImportRunHistoryCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.profileId = _data["profileId"];
            this.jobId = _data["jobId"];
            this.responseGroup = _data["responseGroup"];
            this.objectType = _data["objectType"];
            if (Array.isArray(_data["objectTypes"])) {
                this.objectTypes = [] as any;
                for (let item of _data["objectTypes"])
                    this.objectTypes!.push(item);
            }
            if (Array.isArray(_data["objectIds"])) {
                this.objectIds = [] as any;
                for (let item of _data["objectIds"])
                    this.objectIds!.push(item);
            }
            this.keyword = _data["keyword"];
            this.searchPhrase = _data["searchPhrase"];
            this.languageCode = _data["languageCode"];
            this.sort = _data["sort"];
            if (Array.isArray(_data["sortInfos"])) {
                (<any>this).sortInfos = [] as any;
                for (let item of _data["sortInfos"])
                    (<any>this).sortInfos!.push(SortInfo.fromJS(item));
            }
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): SearchImportRunHistoryCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new SearchImportRunHistoryCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["profileId"] = this.profileId;
        data["jobId"] = this.jobId;
        data["responseGroup"] = this.responseGroup;
        data["objectType"] = this.objectType;
        if (Array.isArray(this.objectTypes)) {
            data["objectTypes"] = [];
            for (let item of this.objectTypes)
                data["objectTypes"].push(item);
        }
        if (Array.isArray(this.objectIds)) {
            data["objectIds"] = [];
            for (let item of this.objectIds)
                data["objectIds"].push(item);
        }
        data["keyword"] = this.keyword;
        data["searchPhrase"] = this.searchPhrase;
        data["languageCode"] = this.languageCode;
        data["sort"] = this.sort;
        if (Array.isArray(this.sortInfos)) {
            data["sortInfos"] = [];
            for (let item of this.sortInfos)
                data["sortInfos"].push(item.toJSON());
        }
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data;
    }
}

export interface ISearchImportRunHistoryCriteria {
    userId?: string | undefined;
    userName?: string | undefined;
    profileId?: string | undefined;
    jobId?: string | undefined;
    responseGroup?: string | undefined;
    objectType?: string | undefined;
    objectTypes?: string[] | undefined;
    objectIds?: string[] | undefined;
    keyword?: string | undefined;
    searchPhrase?: string | undefined;
    languageCode?: string | undefined;
    sort?: string | undefined;
    sortInfos?: SortInfo[] | undefined;
    skip?: number;
    take?: number;
}

export class SearchImportRunHistoryResult implements ISearchImportRunHistoryResult {
    totalCount?: number;
    results?: ImportRunHistory[] | undefined;

    constructor(data?: ISearchImportRunHistoryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ImportRunHistory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchImportRunHistoryResult {
        data = typeof data === 'object' ? data : {};
        let result = new SearchImportRunHistoryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISearchImportRunHistoryResult {
    totalCount?: number;
    results?: ImportRunHistory[] | undefined;
}

export enum SecurityRuleSet {
    None = "None",
    Level1 = "Level1",
    Level2 = "Level2",
}

export class SettingDescriptor implements ISettingDescriptor {
    id?: string | undefined;
    restartRequired?: boolean;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isRequired?: boolean;
    isHidden?: boolean;
    valueType?: SettingDescriptorValueType;
    allowedValues?: any[] | undefined;
    defaultValue?: any | undefined;
    isDictionary?: boolean;

    constructor(data?: ISettingDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.restartRequired = _data["restartRequired"];
            this.moduleId = _data["moduleId"];
            this.groupName = _data["groupName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isRequired = _data["isRequired"];
            this.isHidden = _data["isHidden"];
            this.valueType = _data["valueType"];
            if (Array.isArray(_data["allowedValues"])) {
                this.allowedValues = [] as any;
                for (let item of _data["allowedValues"])
                    this.allowedValues!.push(item);
            }
            this.defaultValue = _data["defaultValue"];
            this.isDictionary = _data["isDictionary"];
        }
    }

    static fromJS(data: any): SettingDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new SettingDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["restartRequired"] = this.restartRequired;
        data["moduleId"] = this.moduleId;
        data["groupName"] = this.groupName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isRequired"] = this.isRequired;
        data["isHidden"] = this.isHidden;
        data["valueType"] = this.valueType;
        if (Array.isArray(this.allowedValues)) {
            data["allowedValues"] = [];
            for (let item of this.allowedValues)
                data["allowedValues"].push(item);
        }
        data["defaultValue"] = this.defaultValue;
        data["isDictionary"] = this.isDictionary;
        return data;
    }
}

export interface ISettingDescriptor {
    id?: string | undefined;
    restartRequired?: boolean;
    moduleId?: string | undefined;
    groupName?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    isRequired?: boolean;
    isHidden?: boolean;
    valueType?: SettingDescriptorValueType;
    allowedValues?: any[] | undefined;
    defaultValue?: any | undefined;
    isDictionary?: boolean;
}

export enum SettingValueType {
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    SecureString = "SecureString",
    Json = "Json",
    PositiveInteger = "PositiveInteger",
}

export enum SortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class SortInfo implements ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortInfoSortDirection;

    constructor(data?: ISortInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sortColumn = _data["sortColumn"];
            this.sortDirection = _data["sortDirection"];
        }
    }

    static fromJS(data: any): SortInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SortInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sortColumn"] = this.sortColumn;
        data["sortDirection"] = this.sortDirection;
        return data;
    }
}

export interface ISortInfo {
    sortColumn?: string | undefined;
    sortDirection?: SortInfoSortDirection;
}

export class ValidationResult implements IValidationResult {
    errors?: string[] | undefined;
    readonly errorsCount?: number;

    constructor(data?: IValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            (<any>this).errorsCount = _data["errorsCount"];
        }
    }

    static fromJS(data: any): ValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["errorsCount"] = this.errorsCount;
        return data;
    }
}

export interface IValidationResult {
    errors?: string[] | undefined;
    errorsCount?: number;
}

export enum AssemblySecurityRuleSet {
    None = "None",
    Level1 = "Level1",
    Level2 = "Level2",
}

export enum ConstructorInfoMemberType {
    Constructor = "Constructor",
    Event = "Event",
    Field = "Field",
    Method = "Method",
    Property = "Property",
    TypeInfo = "TypeInfo",
    Custom = "Custom",
    NestedType = "NestedType",
    All = "All",
}

export enum ConstructorInfoAttributes {
    ReuseSlot = "ReuseSlot",
    PrivateScope = "PrivateScope",
    Private = "Private",
    FamANDAssem = "FamANDAssem",
    Assembly = "Assembly",
    Family = "Family",
    FamORAssem = "FamORAssem",
    Public = "Public",
    MemberAccessMask = "MemberAccessMask",
    UnmanagedExport = "UnmanagedExport",
    Static = "Static",
    Final = "Final",
    Virtual = "Virtual",
    HideBySig = "HideBySig",
    NewSlot = "NewSlot",
    VtableLayoutMask = "VtableLayoutMask",
    CheckAccessOnOverride = "CheckAccessOnOverride",
    Abstract = "Abstract",
    SpecialName = "SpecialName",
    RTSpecialName = "RTSpecialName",
    PinvokeImpl = "PinvokeImpl",
    HasSecurity = "HasSecurity",
    RequireSecObject = "RequireSecObject",
    ReservedMask = "ReservedMask",
}

export enum ConstructorInfoMethodImplementationFlags {
    IL = "IL",
    Managed = "Managed",
    Native = "Native",
    OPTIL = "OPTIL",
    Runtime = "Runtime",
    CodeTypeMask = "CodeTypeMask",
    Unmanaged = "Unmanaged",
    ManagedMask = "ManagedMask",
    NoInlining = "NoInlining",
    ForwardRef = "ForwardRef",
    Synchronized = "Synchronized",
    NoOptimization = "NoOptimization",
    PreserveSig = "PreserveSig",
    AggressiveInlining = "AggressiveInlining",
    AggressiveOptimization = "AggressiveOptimization",
    InternalCall = "InternalCall",
    MaxMethodImplVal = "MaxMethodImplVal",
}

export enum ConstructorInfoCallingConvention {
    Standard = "Standard",
    VarArgs = "VarArgs",
    Any = "Any",
    HasThis = "HasThis",
    ExplicitThis = "ExplicitThis",
}

export enum MemberInfoMemberType {
    Constructor = "Constructor",
    Event = "Event",
    Field = "Field",
    Method = "Method",
    Property = "Property",
    TypeInfo = "TypeInfo",
    Custom = "Custom",
    NestedType = "NestedType",
    All = "All",
}

export enum MethodInfoMemberType {
    Constructor = "Constructor",
    Event = "Event",
    Field = "Field",
    Method = "Method",
    Property = "Property",
    TypeInfo = "TypeInfo",
    Custom = "Custom",
    NestedType = "NestedType",
    All = "All",
}

export enum MethodInfoAttributes {
    ReuseSlot = "ReuseSlot",
    PrivateScope = "PrivateScope",
    Private = "Private",
    FamANDAssem = "FamANDAssem",
    Assembly = "Assembly",
    Family = "Family",
    FamORAssem = "FamORAssem",
    Public = "Public",
    MemberAccessMask = "MemberAccessMask",
    UnmanagedExport = "UnmanagedExport",
    Static = "Static",
    Final = "Final",
    Virtual = "Virtual",
    HideBySig = "HideBySig",
    NewSlot = "NewSlot",
    VtableLayoutMask = "VtableLayoutMask",
    CheckAccessOnOverride = "CheckAccessOnOverride",
    Abstract = "Abstract",
    SpecialName = "SpecialName",
    RTSpecialName = "RTSpecialName",
    PinvokeImpl = "PinvokeImpl",
    HasSecurity = "HasSecurity",
    RequireSecObject = "RequireSecObject",
    ReservedMask = "ReservedMask",
}

export enum MethodInfoMethodImplementationFlags {
    IL = "IL",
    Managed = "Managed",
    Native = "Native",
    OPTIL = "OPTIL",
    Runtime = "Runtime",
    CodeTypeMask = "CodeTypeMask",
    Unmanaged = "Unmanaged",
    ManagedMask = "ManagedMask",
    NoInlining = "NoInlining",
    ForwardRef = "ForwardRef",
    Synchronized = "Synchronized",
    NoOptimization = "NoOptimization",
    PreserveSig = "PreserveSig",
    AggressiveInlining = "AggressiveInlining",
    AggressiveOptimization = "AggressiveOptimization",
    InternalCall = "InternalCall",
    MaxMethodImplVal = "MaxMethodImplVal",
}

export enum MethodInfoCallingConvention {
    Standard = "Standard",
    VarArgs = "VarArgs",
    Any = "Any",
    HasThis = "HasThis",
    ExplicitThis = "ExplicitThis",
}

export enum ObjectSettingEntryValueType {
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    SecureString = "SecureString",
    Json = "Json",
    PositiveInteger = "PositiveInteger",
}

export enum ParameterInfoAttributes {
    None = "None",
    In = "In",
    Out = "Out",
    Lcid = "Lcid",
    Retval = "Retval",
    Optional = "Optional",
    HasDefault = "HasDefault",
    HasFieldMarshal = "HasFieldMarshal",
    Reserved3 = "Reserved3",
    Reserved4 = "Reserved4",
    ReservedMask = "ReservedMask",
}

export enum SettingDescriptorValueType {
    ShortText = "ShortText",
    LongText = "LongText",
    Integer = "Integer",
    Decimal = "Decimal",
    DateTime = "DateTime",
    Boolean = "Boolean",
    SecureString = "SecureString",
    Json = "Json",
    PositiveInteger = "PositiveInteger",
}

export enum SortInfoSortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* eslint-disable */